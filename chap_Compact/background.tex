\section{Background and Related Works}
\label{sec:background}
%UPPRESSO is designed to be compatible with OpenID Connect (OIDC) and provide privacy protections based on the discrete logarithm problem. Next,

This section introduces OIDC \cite{OpenIDConnect},
 to describe typical SSO login flows.
Then, we discuss existing privacy-preserving SSO solutions and other related works.

\subsection{OpenID Connect}
\label{subsec:OIDC}
OIDC is one of the most popular SSO protocols for web applications. %As other SSO protocols \cite{SAMLIdentifier}, OIDC
%It involves three entities, i.e., {\em users}, the {\em identity provider (IdP)}, and {\em relying parties (RPs)}.
Users and RPs initially register at the IdP with their identities %($ID_U$, $ID_{RP}$ and $PID_U$ in some schemes) %(or $PID_{RP}$ in some schemes)
and other necessary information such as user credentials (i.e., passwords or public keys)
 and RP endpoints (i.e., the URLs to receive identity tokens).
% below can be removed
%The IdP should maintain these attributes securely.

%\vspace{1mm}
%\noindent\textbf{Implicit Login Flow.}
OIDC supports three types of login flows: implicit flow, authorization code flow, and hybrid flow (i.e., a mix-up of the previous two).
%In the implicit flow, an {\em id token} is generated as the identity token, which contains a user identifier, an RP identifier, the issuer (i.e., IdP), the validity period, and other requested attributes. The IdP signs the id token using its private key to ensure integrity, and sends it to the RP through the user.
%In the authorization code flow, the IdP binds an authorization code with the RP, and sends it to the RP through the user; then, the RP establishes an HTTPS connection to the IdP and uses the authorization code with the RP's credential to obtain the user's identifier and other attributes.
%UPPRESSO is compatible with all three flows.
These flows work with different steps to request and receive identity tokens,
    but with the common security requirements of identity tokens.
We introduce the implicit flow and present our design and implementation based on this flow,
    and Section \ref{sec:discussion} presents the extensions to support the authorization code flow.

\begin{figure}[b]
  \centering
  \includegraphics[width=0.88\linewidth]{fig/OIDC1.pdf}
  \caption{The implicit SSO login flow of OIDC.}
  \label{fig:OpenID}
%  \vspace{-5mm}
\end{figure}

As shown in Figure \ref{fig:OpenID}, a user firstly initiates a login request to an RP.
Then, the RP constructs an identity-token request with its own identity
% the endpoint to receive the identity token % endpoint应该预先注册、固定的；这里不必强调这个
 and the scope of requested user attributes.
This identity-token request is redirected to the IdP.
After authenticating the user,
    the IdP issues an identity token
        which is forwarded by the user to the RP endpoint.
The token contains a user identity (or pseudo-identity),
    the RP identity, a validity period, the requested user attributes, etc.
%% If the RP endpoint has not been registered at the IdP, the IdP will return a warning to notify the user about potential identity token leakage. % 这里只是谈主线；各种错误情况太多，举不胜举
Finally, the RP verifies the received identity token and
 allows the user to login as the (pseudo-)identity enclosed in this token.

Before issuing the identity token,
    the IdP obtains the user's authorization to enclose the requested user attributes,
    which are maintained at the IdP.
%The identity token is usually signed by the IdP,
%    and transmitted through secure channels such as TLS/HTTPS.
The user's operations including redirection, authorization, and forwarding,
    are implemented in a software called \emph{user agent} (i.e., a browser for web applications).

%extracts user's identifier and returns the authentication result to the user (Step 7).

As described above, a ``pure'' SSO protocol does not include any authentication step:
the authentication between a user and the IdP is conducted independently of the SSO protocol.
There is no authentication step between users and an RP,
        and an RP only verifies tokens issued by the IdP.
This feature of commonly-used SSO protocols \cite{OpenIDConnect,rfc6749,SAML} brings advantages as below.
It enables the IdP to authenticate a user by any appropriate means (e.g., password,
one-time password, multi-factor authentication, and smart card).
Moreover, if a credential was lost or compromised,
    the user only needs renew it at the IdP.
On the other hand, if a user needs to prove some secret to the RP and this secret is valid across multiple login instance
    (i.e., some authentication steps are actually involved),
                the user has to notify each RP if this secret was leaked  or lost. %(or even the user logins from another computer).


%\vspace{1mm}
%\noindent\textbf{RP Dynamic Registration.}
%In addition to manual registrations,
%    OIDC also supports dynamic registrations
%    for an RP to register by online means \cite{DynamicRegistration}.
%The (unregistered) RP sends a registration request
%        with endpoints to receive identity tokens (and other information),
%        to the IdP.
%After a successful registration,
% the IdP assigns a unique RP identity in the response.
%

%UPPRESSO leverages this function and slightly modifies the dynamic registration process to implement the {\em $PID_{RP}$ registration} process (see details in Section \ref{sec:UPPRESSO}.C), which allows an RP to generate different privacy-preserving RP identifiers and register them with the IdP.





\begin{table*}[tb]
\footnotesize
    \caption{Comparison of Existing Privacy-Preserving SSO Solutions.}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
  \hline
  \multirow{3}*{\textbf{~~Solution~~}} &
  \multicolumn{3}{c|}{\textbf{SSO Feature} - supported or not} & \multicolumn{3}{c|}{\textbf{Privacy Threat} - prevented or not} \\ \cline{2-7}
  & Non-anonymous & Independency of & Maintenance of & IdP-based & RP-based & Collusive Attacks \\
  & User Identity & User Authentication & User Attributes & Login Tracing & Identity Linkage & by the IdP and RPs \\\hline
  ABC\cite{x} & X & X & X & X & X & X \\ \hline
  UPPRESSO & X & X & X & X & X & X \\ \hline
\end{tabular}
    \label{tbl:comparison-protocol}
\end{table*}





\subsection{Existing Privacy-Preserving Solutions for SSO}
\label{subsec-solutions}
Pairwise pseudonymous identifiers (PPIDs) are recommended by NIST \cite{NIST2017draft}
 and specified in several SSO protocols \cite{OpenIDConnect, SAMLIdentifier} to protect user privacy against curious RPs.
When issuing an identity token,
        the IdP encloses a user pseudo-identity (but not the user identity at the IdP) in the token.
Given a user,
    the IdP assigns a unique PPID based on the target RP,
    so that collusive RPs cannot link the user's different PPIDs across these RPs.
PPID-based approaches cannot prevent the IdP-based login tracing,
 since in the generation of identity tokens the IdP needs to know which RP the user is visiting.

BrowserID \cite{BrowserID} and SPRESSO \cite{SPRESSO} are proposed to defend SSO services against the IdP-based login tracing,
    but both solutions are instead vulnerable to the threat of RP-based identity linkage.
In BrowserID (and its prototypes known as Mozilla Persona \cite{persona} and Firefox Accounts \cite{FirefoxAccount}),
 the IdP (called the primary identity authority in BrowserID \cite{BrowserID})
  issues a special ``token'' to bind the user identity to an ephemeral public key,
 so that the user uses the corresponding private key to sign a ``subsidiary'' identity token
    to bind his identity with the target RP's identity and then sends both tokens to the RP.
When a user logins to different RPs, the RPs could still extract the identical user identities
    from different pairs of tokens and link these login instances.
Meanwhile,
    in SPRESSO an RP creates a one-time but verifiable pseudo-identity for itself in each login instance.
Then, the IdP generates an identity token binding this RP pseudo-identity and the user identity. %and returns it through a trusted third-party entity called forwarder.
Similarly, collusive RPs could link a user based on his permanent user identity in these tokens.

PPIDs cannot be directly integrated in either BrowserID or SPRESSO.
PPIDs are assigned in identity tokens based on the visited RP \cite{NIST2017draft,OpenIDConnect, SAMLIdentifier},
    but the IdP receives (\emph{a}) nothing about the RP in BrowserID
     or (\emph{b}) only an ephemeral pseudo-identity of the RP in SPRESSO.




A user of EL PASSO \cite{ZhangKSZR21}
    keeps a secret on his device.
After authenticating the user,
    the IdP certifies a credential binding the secret,
         also kept on the user's device.
When attempting to login to any RP,
    the user proves that he is the owner of this credential to the RP without exposing the secret;
when such a credential is verified by multiple RPs,
        user-maintained pseudonyms and anonymous credentials \cite{anon-credential} prevent collusive RPs from linking the login instances.
UnlimitID \cite{IsaakidisHD16} presents similar designs,
    also based on anonymous credentials \cite{anon-credential}.
PseudoID \cite{PseudoID} introduces an independent token service in addition to the IdP,
    to  blindly sign (or certify) a pseudonym credential binding a user's secret.
Then, the user proves to the RP that he owns this secret to login.
These RP-verified credentials protect user privacy well %and enable the visits to multiple RPs,
        and two kinds of privacy threats are prevented  \cite{ZhangKSZR21,IsaakidisHD16,PseudoID},
    but a user has to by himself manage pseudonyms for different RPs.
For example,
    the domain of an RP is used as a factor to locally generate the user's account (or pseudonym) at this RP.
It brings some burdens to users,
    while PPIDs are maintained by the IdP and in UPPRESSO the accounts are determined automatically.

%FIDO \cite{fidouaf} allows a user to generate a key pair on his FIDO-certified device
%    and register the public key at an RP, so that the user logins to this RP with the private key.
%FIDO supports multiple key pairs for different RPs on one device,
%        and the RP-based linkage is also prevented in the registration flow.

Although EL PASSO
 calls itself an SSO scheme
    and the service signing tokens or credentials in EL PASSO, UnlimitID and PseudoID is called the IdP \cite{ZhangKSZR21,IsaakidisHD16,PseudoID},
    there are some authentication steps between the user and RPs to verify the user secrets.
Therefore, in these systems
    a user needs to notify each RP if a credential was lost or compromised,
for the user is authenticated by the RP with his credentials
            to prove that he owns the long-term secret.
Moreover,
    a user has to change its account at each RP if its long-term secret was lost,
        because the account is calculated based on this secret \cite{ZhangKSZR21,IsaakidisHD16}.
On the contrary,
    in the commonly-used SSO systems \cite{OpenIDConnect,rfc6749,SAML} and privacy-preserving schemes
    such as BrowserID \cite{BrowserID}, SPRESSO \cite{SPRESSO} and also UPPRESSO,
        a user only renews his credential at the IdP if it was compromised,
    because (\emph{a}) authentication happens only between the user and the IdP
    and (\emph{b}) an RP verifies only tokens generated by the IdP.









\begin{comment}

\subsection{Discrete Logarithm Problem}
\label{sec:dlp}


Based on the discrete logarithm problem, UPPRESSO designs the identifier-transformation functions. %$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ to generate privacy-preserving user identifier (e.g. $PID_U$) and RP identifier (e.g. $PID_{RP}$), respectively.
Here, we briefly review the discrete logarithm problem.
%A number $g$ ($0<g<p$) is called a primitive root modular a prime $p$, if for ${\forall}y$ ($0<y<p$), there is a  number $x$ ($0\le x <p-1$) satisfying $y=g^x \pmod p$.
For the finite field $GF(p)$ where $p$ is a large prime, a number $g$ is called a generator of order $q$, if it constructs a cyclic  group of $q$ elements by calculating $y=g^x \ mod\ p$.
And $x$ is called the discrete logarithm of $y$ modulo $p$. Given a large prime $p$, a generator $g$ and a number $y$, it is computationally infeasible to solve the discrete logarithm (i.e., $x$) of $y$ \cite{WXWM}, which is called the discrete logarithm problem.
The hardness of solving discrete logarithms is utilized to design several secure cryptographic primitives, including Diffie-Hellman key exchange and the digital signature algorithm (DSA).

%In the process of $F_{PID_{RP}}$ and $F_{PID_U}$, we needs to calculate the primitive root for a  large prime $p$ as follows \cite{Shoup,Wang}. First, we retrieve a primitive root $g_m$  modulo $p$ from all the integers by finding the first integer passing  the primitive root checking.  A lemma is propose to simply the checking, that if $p=2q+1$ ($q$ is a prime),  an integer $\mu \in (1, p-1)$ is a primitive root if and only if $\mu^2\neq 1 \ mod \ p$ and $\mu^q\neq 1 \ mod \ p$. Then, based on $g_m$, we can calculate a new primitive root $g = g_{m}^{t} mod \ p$, where $t$ is an integer coprime to $p-1$.
\end{comment}
