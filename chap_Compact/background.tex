\section{Background and Related Works}
\label{sec:background}
%UPPRESSO is designed to be compatible with OpenID Connect (OIDC) and provide privacy protections based on the discrete logarithm problem. Next,

This section introduces OIDC \cite{OpenIDConnect},
 to describe typical SSO login flows.
Then, we discuss existing privacy-preserving SSO solutions and other related works.

\subsection{OpenID Connect and SSO Features}
\label{subsec:OIDC}
OIDC is one of the most popular SSO protocols for web applications. %As other SSO protocols \cite{SAMLIdentifier}, OIDC
%It involves three entities, i.e., {\em users}, the {\em identity provider (IdP)}, and {\em relying parties (RPs)}.
Users and RPs initially register at the IdP with their identities %($ID_U$, $ID_{RP}$ and $PID_U$ in some schemes) %(or $PID_{RP}$ in some schemes)
and other necessary information such as user credentials (i.e., passwords or public keys)
 and RP endpoints (i.e., the URLs to receive identity tokens).
% below can be removed
%The IdP should maintain these attributes securely.

%\vspace{1mm}
%\noindent\textbf{Implicit Login Flow.}
OIDC supports three types of login flows: implicit flow, authorization code flow, and hybrid flow (i.e., a mix-up of the previous two).
%In the implicit flow, an {\em id token} is generated as the identity token, which contains a user identifier, an RP identifier, the issuer (i.e., IdP), the validity period, and other requested attributes. The IdP signs the id token using its private key to ensure integrity, and sends it to the RP through the user.
%In the authorization code flow, the IdP binds an authorization code with the RP, and sends it to the RP through the user; then, the RP establishes an HTTPS connection to the IdP and uses the authorization code with the RP's credential to obtain the user's identifier and other attributes.
%UPPRESSO is compatible with all three flows.
These flows work with different steps to request and receive identity tokens,
    but with the common security requirements of identity tokens.
We introduce the implicit flow and present our design and implementation based on this flow,
    and Section \ref{sec:discussion} presents the extensions to support the authorization code flow.

\begin{figure}[htb]
  \centering
  \includegraphics[width=0.88\linewidth]{fig/OIDC1.pdf}
  \caption{The implicit SSO login flow of OIDC.}
  \label{fig:OpenID}
%  \vspace{-5mm}
\end{figure}

As shown in Figure \ref{fig:OpenID}, a user firstly initiates a login request to an RP.
Then, the RP constructs an identity-token request with its own identity
% the endpoint to receive the identity token % endpoint应该预先注册、固定的；这里不必强调这个
 and the scope of requested user attributes.
This identity-token request is redirected to the IdP.
After authenticating the user,
    the IdP issues an identity token
        which is forwarded by the user to the RP endpoint.
The token contains a user identity (or pseudo-identity),
    the RP identity, a validity period, the requested user attributes, etc.
Finally, the RP verifies the received identity token and
 allows the user to login as the (pseudo-)identity enclosed in this token.

Before issuing the identity token,
    the IdP obtains the user's authorization to enclose the requested user attributes,
    which are maintained at the IdP by the user. The IdP is also a web service.
%The identity token is usually signed by the IdP,
%    and transmitted through secure channels such as TLS/HTTPS.
The user's operations including redirection, authorization, and forwarding,
    are implemented in a software called \emph{user agent} (i.e., a browser for web applications).

%extracts user's identifier and returns the authentication result to the user (Step 7).

In addition to the basic login flows enabling
    an RP to verify that the user has been authenticated by the IdP,
    the following features are supported by widely-used popular SSO solutions.

\noindent \textbf{User Identity at an RP.}
The identity tokens facilitate the target RP to identify each user as a unique account at this RP,
    and this account links the user's multiple login instances to this RP
        for customized information services.
On the contrary, in anonymous SSO systems \cite{WangWS13,HanCSTW18,HanCSTWW20}
        the RP only verifies whether he is a legitimate user authenticated by the IdP
            and receives no information to identify or distinguish the users.

\noindent \textbf{User Authentication Only to the IdP.}
A ``pure'' SSO protocol  \cite{OpenIDConnect,rfc6749,SAML} does not include authentication steps:
    the authentication between a user and the IdP is conducted independently.
It eliminates the authentication step between users and an RP,
        and an RP only verifies tokens issued by the IdP.
This feature
    enables the IdP to authenticate users by any appropriate means (e.g., password,
one-time password, multi-factor authentication, and smart card).
So a user \emph{only} needs to hold the credential to authenticate himself to the IdP,
    and then the user burden is mitigated.
Thus, if a user's computer or device was compromised or lost,
    the user only renews the credential at the IdP.
On the other hand, if a user proves some non-ephemeral secret to the RP and this secret is valid across multiple login instances
    (i.e., some authentication steps are actually involved),
                the user has to notify each RP if this secret was leaked  or lost during its validity period. %(or even the user logins from another computer).

\noindent \textbf{IdP-Confirmed Selective Attribute Provision.}
The IdP usually provides also user attributes in the tokens \cite{OpenIDConnect,rfc6749,SAML},
    in addition to user (pseudo-)identities.
These attributes are maintained by users at the IdP;
    for example,
        when Facebook provides social networking services,
         it also runs as an IdP with identity tokens enclosing user identities and various attributes.
Before enclosing attributes in an identity token for any RP,
    the IdP needs to obtain the user's authorization;
    or the provided attributes are selected by the user.
Thus,
    no distinctive attributes such as such as telephone number, Email, etc.,
        are enclosed in the tokens of privacy-preserving SSO systems.

%\vspace{1mm}
%\noindent\textbf{RP Dynamic Registration.}
%In addition to manual registrations,
%    OIDC also supports dynamic registrations
%    for an RP to register by online means \cite{DynamicRegistration}.
%The (unregistered) RP sends a registration request
%        with endpoints to receive identity tokens (and other information),
%        to the IdP.
%After a successful registration,
% the IdP assigns a unique RP identity in the response.
%

%UPPRESSO leverages this function and slightly modifies the dynamic registration process to implement the {\em $PID_{RP}$ registration} process (see details in Section \ref{sec:UPPRESSO}.C), which allows an RP to generate different privacy-preserving RP identifiers and register them with the IdP.





\begin{table*}[htb]
\footnotesize
    \caption{Privacy-Preserving Solutions of SSO and Federated Identity Management.}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
  \hline
  \multirow{3}*{\textbf{~~Solution~~}} &
  \multicolumn{3}{c|}{\textbf{SSO Feature} - supported $\CIRCLE$, unsupported $\Circle$, or partially $\LEFTcircle$} & \multicolumn{3}{c|}{\textbf{Privacy Threat} - prevented $\CIRCLE$ or not $\Circle$} \\ \cline{2-7}
  & User Identity & User Authentication & IdP-Confirmed Selective  & IdP-based & RP-based & Collusive Attack \\
  & at an RP & Only to the IdP &  Attribute Provision & Login Tracing & Identity Linkage & by the IdP and RPs \\\hline\hline
  OIDC with PPID & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\Circle$ & $\CIRCLE$ & - \\ \hline
  BrowserID & $\CIRCLE$ & $\LEFTcircle$$^1$ & $\Circle$ & $\CIRCLE$ & $\Circle$ & - \\ \hline
  PRIMA & $\CIRCLE$ & $\Circle$ & $\CIRCLE$ & $\CIRCLE$ & $\Circle$ & - \\ \hline
  SPRESSO & $\CIRCLE$ & $\CIRCLE$ & $\Circle$$^2$ & $\CIRCLE$ & $\Circle$ & - \\ \hline
  PseudoID & $\CIRCLE$ & $\Circle$ & $\Circle$$^3$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ \\ \hline
  EL PASSO & $\CIRCLE$ & $\Circle$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ \\ \hline
  UnlimitID & $\CIRCLE$ & $\Circle$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ \\ \hline
  Opaak & $\CIRCLE$$^4$ & $\Circle$ & $\Circle$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ \\ \hline
  Hyperledger Idemix & $\Circle$$^5$ & $\Circle$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ \\ \hline
  U-Prove & $\CIRCLE$ & $\Circle$ & $\LEFTcircle$$^6$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ \\ \hline
  UPPRESSO & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\CIRCLE$ & $\Circle$ \\ \hline
\end{tabular}
    \label{tbl:comparison-protocol}
\flushleft
{\footnotesize
1. A user generates an \emph{ephemeral} private key to sign every ``subsidiary'' token,
 which is verified by the RP.\\
2. SPRESSO can be extended to provide user attributes in then tokens, while the prototype does not support it.\\
3. Blindly-signed user attributes can be selectively provided using zero-knowledge proofs,
    not implemented in the preliminary version of PseudoID.\\
4. Two options: anonymous and non-anonymous.\\
5. However, in its original version \cite{idemix}, user identity is non-anonymous at an RP.\\
6. IdP-confirmed attribute and unconfirmed attributes are both enclosed.}
\end{table*}





\subsection{Privacy-Preserving Solutions of SSO and Federated Identity Management}
\label{subsec-solutions}
Pairwise pseudonymous identifiers (PPIDs) are recommended by NIST \cite{NIST2017draft}
 and specified in several SSO protocols \cite{OpenIDConnect, SAMLIdentifier} to protect user privacy against curious RPs.
When issuing an identity token,
        the IdP encloses a user pseudo-identity (but not the user identity at the IdP) in the token.
Given a user,
    the IdP assigns a unique PPID based on the target RP,
    so that collusive RPs cannot link the user's different PPIDs across these RPs.
PPID-based approaches cannot prevent the IdP-based login tracing,
 since in the generation of identity tokens the IdP needs to know which RP the user is visiting.

Some solutions prevent the IdP-based login tracing,
    but vulnerable to the threat of RP-based identity linkage.
In BrowserID \cite{BrowserID} (and its prototypes known as Firefox Accounts \cite{FirefoxAccount} and Mozilla Persona \cite{persona}),
 the IdP %(called the primary identity authority in BrowserID)
  issues a special ``token'' to bind the user identity to an \emph{ephemeral} public key,
 so that the user utilizes the corresponding private key to sign a ``subsidiary'' identity token
    to bind his identity with the target RP's identity and then sends both tokens to the RP.
%When a user logins to different RPs, the RPs still extract the identical user identities
%    from different pairs of tokens and link these login instances.
In PRIMA the IdP signs an authentication credential to bind a verification key with a set of user attributes \cite{prima}, where the verification key is considered as his unique identity.
And then the user provides selective IdP-confirmed attributes to any RP using his signing key \cite{Oblivion}, cooperatively with the IdP.
In SPRESSO \cite{SPRESSO} an RP creates a one-time but verifiable pseudo-identity for itself in each login instance.
Then, the IdP generates an identity token binding this RP pseudo-identity and the user identity.
In these schemes,
    collusive RPs could link a user based on his unique identity in the tokens (or credentials).

PseudoID \cite{PseudoID} introduces an independent token service in addition to the IdP,
    to  \emph{blindly} sign an access token binding a pseudonym and a user secret.
Then, the IdP will assert this access token,
    which allows the user to login to the RP using his secret.
Two kinds of privacy threats are prevented, because (\emph{a}) the RP's identity is not enclosed in the access token,
    and (\emph{b}) the user by himself encloses different pseudonyms when visiting RPs.
Moreover, collusive privacy attacks by the IdP and RPs are also prevented,
    because even the IdP and the token service cannot link two blindly-signed access tokens.

% the user must use the secret to login to RP, because no RP identity is enclosed in the token.
    

%However, the user has to permanently keep the secret preimage for each account in an RP.

A user of EL PASSO \cite{ELPASSO}
    keeps a secret on his device.
After authenticating the user,
    the IdP signs an anonymous credential \cite{anon-credential} binding the secret,
         also kept on the user's device.
When attempting to login to any RP,
    the user proves that he is the owner of this credential to the RP without exposing the secret,
        and selectively discloses some attributes in the credential.
Although such a credential is proved to multiple RPs,
        user-maintained pseudonyms and anonymous credentials prevent the IdP, even when collusive with some RPs, from linking the login instances.
UnlimitID \cite{UnlimitID} presents similar designs,
    also based on anonymous credentials \cite{anon-credential},
        and prevents collusive attacks by the IdP and RPs.
NEXTLEAP \cite{nextleap} adopts UnlimitID for secure messaging.

%    but a user has to by himself manage pseudonyms for different RPs.
%For example,
%    the RP domain (e.g., \verb+www.RP.com+) is used as a factor to locally generate the user's account (or pseudonym) at this RP.

+++++

Anonymous credentials \cite{anon-credential-2001} can be utilized in flexible ways.
Opaak \cite{opaak} keeps anonymous credentials in mobile phones as ,
    which are .
Hyperledger Idemix \cite{hyperledge-idemix}.



U-Prove \cite{uprov}

%Moreover,
%    a user has to change its account at each RP if its long-term secret was lost,
%        because the account is calculated based on this secret \cite{ELPASSO,UnlimitID}.
% 这一点，就不作为讨论了。因为account与RP ID相关，用域名就会是这个结果；如果类似于引入RP Cert，就不会变化。

%On the contrary,
%    in the commonly-used SSO systems \cite{OpenIDConnect,rfc6749,SAML} and privacy-preserving schemes
%    such as BrowserID \cite{BrowserID}, SPRESSO \cite{SPRESSO} and also UPPRESSO,
%        a user only renews his credential at the IdP if it was compromised,
%    because (\emph{a}) authentication happens only between the user and the IdP
%    and (\emph{b}) an RP verifies only tokens generated by the IdP.





Table \ref{tbl:comparison-protocol} summaries these privacy-preserving solutions of SSO and federated identity management.
A ``pure'' SSO protocol allows the user to authenticate himself a \emph{single} time by ,
    but need no any permanent secret when attempting to login to an RP.
Some identity federation solutions \cite{ELPASSO,UnlimitID,opaak} protect user privacy against collusive attacks by the IdP and RPs,
    while a user has to hold long-term secret in addition to the credentials (or tokens).
On the other hand,
    identity federation enables identity to be accepted by any one more than the issuer (where registration),
    with or without more secret.
Some privacy-preserving SSO schemes and UPPRESSO try to keep the user convenience lightweight,
In EL PASSO, UnlimitID and PseudoID \cite{ELPASSO,UnlimitID,PseudoID}
    there are some authentication steps between the user and RPs to verify the user secrets.
Therefore, in these systems
    a user needs to notify each RP if a credential was lost or compromised,
for the user is authenticated by the RP with his credentials
            to prove that he owns the long-term secret.



It brings some burdens to users,
    while PPIDs are maintained by the IdP and in UPPRESSO the accounts are determined automatically.


\begin{comment}

\subsection{Discrete Logarithm Problem}
\label{sec:dlp}


Based on the discrete logarithm problem, UPPRESSO designs the identifier-transformation functions. %$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ to generate privacy-preserving user identifier (e.g. $PID_U$) and RP identifier (e.g. $PID_{RP}$), respectively.
Here, we briefly review the discrete logarithm problem.
%A number $g$ ($0<g<p$) is called a primitive root modular a prime $p$, if for ${\forall}y$ ($0<y<p$), there is a  number $x$ ($0\le x <p-1$) satisfying $y=g^x \pmod p$.
For the finite field $GF(p)$ where $p$ is a large prime, a number $g$ is called a generator of order $q$, if it constructs a cyclic  group of $q$ elements by calculating $y=g^x \ mod\ p$.
And $x$ is called the discrete logarithm of $y$ modulo $p$. Given a large prime $p$, a generator $g$ and a number $y$, it is computationally infeasible to solve the discrete logarithm (i.e., $x$) of $y$ \cite{WXWM}, which is called the discrete logarithm problem.
The hardness of solving discrete logarithms is utilized to design several secure cryptographic primitives, including Diffie-Hellman key exchange and the digital signature algorithm (DSA).

%In the process of $F_{PID_{RP}}$ and $F_{PID_U}$, we needs to calculate the primitive root for a  large prime $p$ as follows \cite{Shoup,Wang}. First, we retrieve a primitive root $g_m$  modulo $p$ from all the integers by finding the first integer passing  the primitive root checking.  A lemma is propose to simply the checking, that if $p=2q+1$ ($q$ is a prime),  an integer $\mu \in (1, p-1)$ is a primitive root if and only if $\mu^2\neq 1 \ mod \ p$ and $\mu^q\neq 1 \ mod \ p$. Then, based on $g_m$, we can calculate a new primitive root $g = g_{m}^{t} mod \ p$, where $t$ is an integer coprime to $p-1$.
\end{comment}
