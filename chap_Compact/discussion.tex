\section{Discussions}
\label{sec:discussion}

\noindent{\textbf{Collusive Attack by an IdP and RPs.}}
Privacy-preserving identity federation solutions \cite{ELPASSO,UnlimitID,idemix,PseudoID,Opaak,uprov}
 prevent the collusive attacks by an IdP and RPs,
    at the cost of (\emph{a}) a long-term secret held by a user but verified by RPs
        and (\emph{b}) user-managed accounts \cite{PseudoID} for different RPs.
Such accounts may be derived from an RP domain and this secret locally \cite{ELPASSO,UnlimitID,Opaak,uprov,idemix},
  but it still brings inconveniences.
For web applications, a user needs to install a browser extension to handle this long-term secret;
  and if it is lost or leaked,
       a user has to notify all RPs to update his accounts which are derived from the secret
        (if the accounts are not masked by the user's secret, the colluding IdP and RPs can eventually link them).
Meanwhile,
UPPRESSO does not protect user privacy against such collusive attacks,
    but a user is authenticated to \emph{only} an IdP:
         the user identity at the IdP
                are transformed to the accounts at RPs, unrelated to any user credential (e.g., password, one-time password or smart card).

%When the IdP is kept honest-but-curious but shares messages in the login flow (i.e.,
%$ID_U$, $PID_{RP}$, and $PID_U$)
%        with some colluding RPs,
%UPPRESSO still provides secure SSO services,
%    provided that the signed identity tokens are sent to the authenticated users only;
%however,
%    the colluding adversaries are able to track the users' login activities to these RPs.
%Even in this case, a user's login activities at the other RPs not collusive with the IdP,
%        are still kept unknown to the IdP and these colluding RPs,
%        because a triad of $t$, $PID_U$ and $PID_{RP}$ is ephemeral and independent of each other.



\vspace{0.4mm}
\noindent{\textbf{Scalability and Uniqueness.}}
$ID_{RP}$ is generated uniquely in an RP's initial registration,
    and the capacity of RPs is $n$ (i.e., the order of $G$). For the NIST P256 elliptic curve, $n$ is approximately $2^{256}$.
Adversaries cannot exhaust $PID_{RP}$, either.
We ensure $PID_{RP}$ is unique in \emph{unexpired} tokens,
    the number of which is $\sigma$.
The probability that at least two $PID_{RP}$s are identical among the $\sigma$ ones,
    is $1-\prod_{i=0}^{\sigma-1}(1-i/n)$.
If the system serves $10^{8}$ requests per second and the validity period is 10 minutes,
     $\sigma$ is less than $2^{36}$ and the $PID_{RP}$-collision probability is negligible (i.e., less than $2^{-183}$) for the P256 curve.

The capacity of accounts at any RP is also $n$.
$\mathbb{E}$ is a finite cyclic group,
    so $ID_{RP} = [r]G$ is also a generator of order $n$.
Thus, given any RP,
    a \emph{unique} account is automatically assigned to every user,
        because $Acct =  [ID_U]ID_{RP} = [u]ID_{RP}$.

Besides, stronger elliptic curves accommodate more RPs and users;
e.g., $n$ is nearly $2^{384}$ for the NIST P384 curves.


\vspace{0.4mm}\noindent{\textbf{Alternative Way to Generate $ID_{RP}$ and Bind $Enpt_{RP}$.}}
In the prototype an RP certificate binds $ID_{RP}$ and $Enpt_{RP}$,
    verified by the honest IdP script.
RP certificates ensure the target RP has already registered itself at the IdP,
 which prevents unauthorized RPs from accessing the IdP's services.

This binding may be finished in another way:
    $ID_{RP}$ is \emph{deterministically} calculated based on the RP's \emph{unambiguous} name.
For example, $Hs()$ encodes an RP's domain (or the RP script's origin, e.g., \verb+https://RP.com+) to a point on $\mathbb{E}$ as $ID_{RP}$,
where
    hashing to elliptic curves $Hs()$ \cite{irtf-cfrg-hash-to-curve-16} provides collision resistance and does not reveal the discrete logarithm of the output
    (i.e., $ID_{RP} = [r]G$ is \emph{unique} and $r$ is \emph{unknown}).
Then,  in Step 2.2 the RP script will send the endpoint but not its RP certificate,
  %to the IdP script,
 and $ID_{RP}$ is calculated by the IdP script.
%This elimination of RP certificates improves the downloading of scripts,
%        and on average \textcolor[rgb]{1,0,0}{xxx} ms are saved.
However, if an RP updates its domain, for instance, from \verb+https://RP.com+ to \verb+https://theRP.com+,
$Acct = [ID_U]ID_{RP}$ will change \emph{inevitably}.
In such cases,
    it needs special operations by each user to migrate his account
            to the updated RP system.
This account migration requires extra operations explicitly by each user;
    otherwise,
        colluding RPs could actually link a user's accounts across RPs.

\vspace{0.4mm}\noindent{\textbf{Restriction of the RP Script's Origin.}}
When identity tokens are forwarded by the IdP script to the RP script, % within the user browser,
    the receiver is restricted by the \verb+postMessage+ targetOrigin mechanism \cite{postm-targeto},
        to ensure it will forward the tokens to $Enpt_{RP}$
        that is bound in RP certificates.
A targetOrigin is specified as
    a domain (e.g., \verb+RP.com+) and a pair of protocol and port (if not presented, implicitly 80 for \verb+http+ and 443 for \verb+https+),
        and it requires the RP script's origin \emph{accurately} matches the targetOrigin.

Although the URL path part of $Enpt_{RP}$ %, e.g., \verb+/uploadTkn+,
 is not checked by the targetOrigin mechanism,
  which assumes only \emph{one} RP runs on a domain,
   it brings no \emph{extra} risk.
For example, if two RPs run on one domain but with different endpoints to receive identity tokens
        (e.g., \verb+https://RP.com/honest/tkn+ and \verb+https://RP.com/malicious/tkn+),
         they cannot be distinguished by \verb+postMessage+.
Meanwhile, browsers enforce
 the same-origin policy (SOP) in the access control of web resources \cite{sop}.
So
    a malicious RP could always access the other RP's resources in browsers,
        e.g., steal cookies
        by the script
        \verb+window.open('https://RP.com/honest').document.cookie+,
    even if the honest RP restricts only HTTP requests to specific paths carry its cookies.
This risk resuts from the SOP design.


\vspace{0.4mm}\noindent{\textbf{Support for the Authorization Code Flow.}}
In the authorization code flow of OIDC \cite{OpenIDConnect},
    an IdP does not directly issue identity tokens;
        instead,
            an authorization code is sent to the RP,
            which uses this code to ask for identity tokens.
The identity-transformation functions $\mathcal{F}_{PID_{U}}$, $\mathcal{F}_{PID_{RP}}$ and $\mathcal{F}_{Acct}$
    can be integrated into the authorization code flow:
    %similar with the login flow introduced in Section \ref{implementations},
            an authorization code is forwarded to the RP script by the IdP script
                and this code is used to ask for an identity token binding $PID_U$ and $PID_{RP}$.
An authorization code is usually an index to retrieve identity tokens from the IdP,
        and does not disclose any information on the authenticated user.


After receiving an authorization code, an RP uses it and another secret credential
         which is issued by the IdP during the initial registration \cite{OpenIDConnect},
     to retrieve identity tokens from the IdP.
Thus, in order to protect RP identities from the IdP,
        privacy-preserving credentials (e.g., ring or group signatures \cite{ring-sig,chaum1991group})
        and anonymous networks (e.g., Tor \cite{tor}) need to be adopted for RPs in the final retrieval of identity tokens.


%Moreover, IdP can also issue the access token to RP beside of identity token, while the specifications\cite{rfc6749, rfc6750} define mechanisms to obtain and use access tokens to access resources but do not define standard methods to provide identity information.
%    That is, the access token is not required to carry any RP and user's information explicitly, therefore, it would not expose any user's information to RP.



%\noindent{\textbf{Implementation with Browser Extensions.}}
%If the user functions of UPPRESSO are implemented with browser extensions,
%    it results in better performance.
%A user downloads and installs the browser extension,
%    before he visits the RPs.
%We have tested such a browser extension while the IdP and RPs are unmodified,
% \textcolor[rgb]{1,0,0}{and experiments show that at least 102 ms will be saved for each login (i.e., about 208 ms in total),}
%    compared with the version with portable web scripts.

\vspace{0.4mm}
\noindent{\textbf{Applicability of Identity Transformations.}}
These identity-transformation functions, i.e., $\mathcal{F}_{PID_{RP}}()$, $\mathcal{F}_{PID_U}()$, and $\mathcal{F}_{Acct}()$,
    are applicable to various SSO scenarios
        (e.g., web application, mobile App, and native software),
    because these functions follow the common model of popular SSO protocols
    and do not depend on any special implementation or runtime.
%Although the prototype runs for web applications,
%    it is feasible to apply the identity-transformation functions to other SSO scenarios
%        to protect user privacy.




% 解决IdP数据泄露
% 如果IdP的数据库泄露，用户列表u公开，则RP就可以，针对每一个u，计算[u]ID_{RP}；然后，
