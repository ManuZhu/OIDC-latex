\section{Discussions}
\label{sec:discussion}

\noindent{\textbf{IdP-RP collusive attacks.}}
Privacy-preserving identity federation solutions~\cite{ELPASSO, UnlimitID, idemix, PseudoID, Opaak, uprov}
 prevent collusive attacks by an IdP and RPs
 but require (\emph{a}) a long-term secret held by a user and verified by RPs,
  as well as (\emph{b}) user-managed accounts~\cite{PseudoID} for different RPs.
These accounts may be derived from an RP's domain and the user's secret~\cite{ELPASSO, UnlimitID, Opaak, uprov,idemix},
 but can still bring inconvenience to users.
For web applications, users need to install a browser extension to handle this long-term secret.
If it is lost or leaked, the user must notify all RPs to update his accounts derived from the user secret.
Note that if the accounts are not masked by the user secret, the colluding IdP and RPs can eventually link them.
Unlike these approaches, \usso~does not protect user privacy against such collusive attacks,
 because a user is authenticated only \emph{once} in the login flow.
 The user's identity at the IdP is transformed into accounts at RPs,
  which are unrelated to any user credentials such as passwords, one-time passwords, smart cards, or FIDO devices.

%\vspace{0.75mm}
\noindent \textbf{Scalability.} $ID_{RP}$ is generated uniquely during the initial registration of an RP,
 with a capacity of $n$, which is the order of $G$. For the NIST P256 elliptic curve, $n$ is approximately $2^{256}$.
$PID_{RP}$ is ensured to be unique in unexpired tokens.
The probability of having at least two identical $PID_{RP}$s among $\sigma$ unexpired tokens is $1-\prod_{i=0}^{\sigma-1}(1-i/n)$.
If the system serves $10^{8}$ requests per second and has a validity period of 10 minutes, $\sigma$ is less than $2^{36}$,
 and the $PID_{RP}$-collision probability is negligible, i.e., less than $2^{-183}$ for the NIST P256 curve.

The capacity of accounts at any RP is the same as the capacity of user identities at the IdP,
 which is also $n$. Since $\mathbb{E}$ is a finite cyclic group, $ID_{RP} = [r]G$ is also a generator of order $n$.
 Therefore, for any RP, a unique account is automatically assigned to every user because $Acct =  [ID_U]ID_{RP} = [u]ID_{RP}$.
In addition, stronger elliptic curves accommodate more RPs and users, e.g., $n$ is about $2^{384}$ for the NIST P384 curve.


%\vspace{0.75mm}
\noindent \textbf{Support for the authorization code flow.} In OIDC authorization code flow~\cite{OpenIDConnect},
 the IdP does not directly provide identity tokens.
 Instead, it sends an authorization code to the RP, which uses this code to request identity tokens.
 The identity-transformation algorithms, namely $\mathcal{F}_{PID_{U}}$, $\mathcal{F}_{PID_{RP}}$, and $\mathcal{F}_{Acct}$,
  can be integrated into this flow as below. %similar with the login flow introduced in Section \ref{implementations},

The IdP script can forward an authorization code to the RP script,
 and then to the RP. %that binds $PID_U$ and $PID_{RP}$.
 An authorization code only serves as an index to retrieve identity tokens from the IdP
  and does not reveal any information about the authenticated user.
After receiving an authorization code,
 an RP uses it along with a secret credential issued by the IdP during the initial registration \cite{OpenIDConnect}
  to retrieve identity tokens from the IdP.
  However, to protect the RP identities from the IdP, privacy-preserving tokens
   (e.g., ring or group signatures~\cite{ring-sig,chaum1991group} and TrustToken \cite{trusttoken})
   and anonymous networks (e.g., Tor \cite{tor}) need to be adopted for RPs in the retrieval of identity tokens.

%\vspace{0.75mm}
\noindent \textbf{Alternative methods for generating $ID_{RP}$ and binding $Enpt_{RP}$.}
\usso~generates random $ID_{RP}$ and uses an RP certificate to bind $ID_{RP}$ and $Enpt_{RP}$, which is verified by the IdP script.
This ensures the target RP has already registered itself at the IdP and prevents unauthorized RPs from accessing the IdP's services.

An alternative method for binding $ID_{RP}$ and $Enpt_{RP}$ is
 to \emph{deterministically} calculate $ID_{RP}$ based on the RP's unambiguous name such as its domain.
 This can be achieved by encoding the domain using a hashing-to-elliptic-curves function \cite{irtf-cfrg-hash-to-curve-16},
  to generate a point on the elliptic curve $\mathbb{E}$ as $ID_{RP}$.
This function \cite{irtf-cfrg-hash-to-curve-16} provides collision resistance
 and does not reveal the discrete logarithm of the output,
  ensuring the \emph{uniqueness} of $ID_{RP} = [r]G$ while keeping $r$ \emph{unknown}. %For example, using a hash function $Hs()$ to encode an RP's domain or the RP script's origin, e.g., verb+https://RP.com+)

In this case, the RP script sends only the endpoint but not its RP certificate in Step 2.2, and the IdP script calculates $ID_{RP}$ by itself. %This elimination of RP certificates improves the downloading of scripts, and on average \textcolor[rgb]{1,0,0}{xxx} ms are saved.
However, if the RP changes its domain, such as from \verb+https://RP.com+ to \verb+https://theRP.com+,
$Acct = [ID_U]ID_{RP}$ will inevitably change.
This requires users to perform special operations to migrate their accounts to the updated RP system
 as failure to migrate accounts could allow colluding RPs to link a user's accounts across RPs.
 However, account migration requires extra operations by each user.

%\vspace{0.75mm}
\noindent \textbf{Restriction of the RP script's origin.}
When the IdP script forwards identity tokens to the RP script, the \verb+postMessage+ targetOrigin mechanism~\cite{postm-targeto} is used to restrict the recipient of the tokens, to ensure that the tokens will be sent to the intended $Enpt_{RP}$, as specified in the RP certificate. The targetOrigin is specified as a combination of protocol, port (if not presented, 80 for \verb+http+ and 443 for \verb+https+), and domain (e.g., \verb+RP.com+).
The RP script's origin must accurately match the targetOrigin to receive the tokens.

Although it does not check the URL path in $Enpt_{RP}$,
the targetOrigin mechanism introduces no {\em additional} risk.
%This assumes only one RP runs on a domain.
For example, if two RPs run on the same domain with different endpoints to receive tokens,
 e.g., \verb+https://RP.com/honest/tk+ and \verb+https://RP.com/malicious/tk+,
  they cannot be distinguished by \verb+postMessage+ when the IdP script is sending tokens.
Since browsers control access to web resources with the same-origin policy (SOP)~\cite{sop},
   an RP's resources in browsers could still be accessed maliciously by the other RP running on the same domain,
    such as stealing cookies using the script \verb+window.open('https://RP.com/honest').document.cookie+,
even if it restricts that only HTTP requests to specific paths carry its cookies.
 This risk actually arises from the SOP design of browsers. %and is not related to the \usso~protocol.



%\vspace{0.75mm}
\noindent \textbf{Applicability of identity transformations.}
The proposed identity-transformation algorithms %i.e., $\mathcal{F}_{PID_{RP}}()$, $\mathcal{F}_{PID_U}()$, and $\mathcal{F}_{Acct}()$,
can be applied to a wide range of SSO scenarios, including web applications, mobile Apps, and native software.
These algorithms follow the common model of popular SSO protocols and do not depend on any specific implementation or runtime.%, making them highly versatile and adaptable to different use cases.



%%%%%%%%%%%%%%%%%%%%% 几个方面的扩展
% 1. 解决IdP数据泄露
% 如果IdP的数据库泄露，用户列表u公开，则RP就可以，针对每一个u，计算[u]ID_{RP}；然后，
% 2. 授权码模式
% 可以使用PKCE方式，直接在前端获取。通常，PKCS模式用在没有后端的RP（例如，纯客户端）。
% 对于有后端，可以将​code_verifier传给RP后端？也能够达到目标。
% 3. RP后端访问IdP，需要通过TOR
% 为了不传递RP ID和Secret，可以是：传递PKCE的code_verifier [user将code_verifier传递给RP]，
% 也可以是群签名/环签名之类的。
% 4. 要求RP有授权
% 可以有2种方式：
%   去掉RP Cert；采取授权码方式 + 群签名/环签名之类凭证。
%   去掉RP Cert：采取授权码方式 + PrivacyPass之类匿名凭证（还可以有准确计费）。
% 5. 还有一种方式
% 隐式模式 + PrivacyPass之类匿名凭证（还可以有准确计费）。因为其它方式都需要通过TOR。
