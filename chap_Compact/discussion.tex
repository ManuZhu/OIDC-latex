\section{Discussion}
\label{sec:discussion}
In this section, we provide some discussion about UPRESSO.

%兼容:目前只提供隐式模式,对其他模式与协议的兼容方法
\noindent{\textbf{Authorization code flow.}} UPRESSO may be extended to hide the users' access trace in  the authorization code flow. The RP obtains the authorization code in the same way as the  identity proof in implicit protocol flow. However, the RPs needs to connect to the IdP directly, and  use this code with  the RP identifier and secret for the \verb+id token+. To avoid the IdP obtaining the IP address from the connection, the anonymous network (e.g., Tor) may be used to establish the connection. And the RP's identifier and secret are issued by the IdP in the dynamic registration described forementioned.


%SPRESSO跨平台:我们目前的方案只在browser实现
\noindent{\textbf{Multi-platform user agent.}} UPRESSO doesn't store any persistent information in the platform and may be implemented to be platform independent. Firstly, all the information (e.g., $Cert_{RP}$, $PID_{RP}$, $N_U$, $ID_{RP}$ and one-time endpoint) processed and cached in the user's platform is only correlated with the current session, which allows the user to log in to any RP with a new platform without any synchronization. Secondly, in the current implementation of UPRESSO, a browser extension is adopted to capture the redirection from the RP and IdP, to reduce the modification at the RP and IdP.
However, to comfort the requirement of using UPRESSO in multiple platforms (e.g., mobile phones), UPRESSO is able to be implemented based on HTML5, without the use of any browser extensions, or plug-ins. The assumption for secure cross-platform user agent is the IdP must always be honest without providing any malicious JavaScript code which is similar with it in SPRESSO (requiring the honest entity, FWD). But it is required the code should be trustful, which is ensured to be correct and unmodifiable by any adversary. As the IdP is considered honest, it could take the responsibility for providing the same trustful JavaScript code as chrome extension to accomplish the $PID_{RP}$ negotiation and other missions. While the code has been already loaded from IdP, if the code is honest (without any prior inserted malicious code) it cannot be modified or monitored. Moreover, the new mechanism called SRI (subresource integrity) under development enables the opener of an iframe to require the hash of document loaded in it to equal with the one set by opener, which ensures the code cannot be malicious even the IdP try to insert the malicious code. For each start, RP opens the iframe with the SRT hash (of correct user agent code) and the iframe downloads the code from IdP, so that, as the RP will never collude with the IdP, the code cannot be malicious.

\noindent{\textbf{DoS attack.}} The adversary may perform the DoS attack. The malicious RPs may try to exhaust the $ID_{RP}$  by applying the $Cert_{RP}$ frequently. However the large $p$ provides a large set of $ID_{RP}$, and IdP may provide the offline check for $Cert_{RP}$ as it occurs only once for a RP (i.e., the initial registration). The malicious users may attempt to make the other users' $PID_{RP}$ be rejected at the IdP, by registering a large set of $PID_{RP}$s at IdP. However, the large $p$ makes a huge number of dynamic registration required, and IdP may adopt existing DoS mitigation to limit the number of adversary's dynamic registrations. Moreover, for IdP's dynamic registration storage, the data contains RP's client\_id (no more than 256-bit length) and redirect\_uri (tens-Byte length). We consider that each dynamic registration data cost no more than 100 Bytes storage. And for each client\_id IdP can set the lifetime of validity. It is assumed that for each client\_id its lifetime is 5 minutes and during 5 minutes there are 1 billion requests for dynamic registration. So IdP need to offer about 100 GB storage for dynamic registration. The extra cost of storage can be ignored.

\noindent{\textbf{Identity injection by malicious IdP.}} It has been discussed in~\cite{SPRESSO} that even the impersonate attack by malicious IdP is not considered, the malicious IdP might lead the user to access the RP as the identity of the adversary (identity injection). That is the IdP might generate an identity proof representing the adversary's identity while an honest user log in to an honest RP. However, in SPRESSO, the user is required to send her email to RP at the very beginning of authentication and IdP must provide the relevant identity proof. It is also available in UPRESSO that user upload her extra user name (defined by user for each RP) before the login to the RP.

\noindent{\textbf{RP certificate.}} The honest IdP is assumed to generate the correct $r$ and $ID_{RP}$.
However, based on the idea of certificate transparency \cite{rfc6962},
an external check may be performed to ensure that  no two valid $Cert_{RP}$ assigned to a same $ID_{RP}$ and $ID_{RP}$ is a primitive root modulo $p$.
The external check needs to be performed by a third party instead of RP, as the RP will benefit from incorrect $ID_{RP}$, e.g., linking the user among RPs with the same  $ID_{RP}$.
In UPRESSO, the RP certificate $Cert_{RP}$ is used to provide the trusted binding between the $ID_{RP}$ and the RP's endpoint. RP certificate could be compatible with the X.509 certificate. To integrate RP certificate in X.509 certificate, the CA generates the $ID_{RP}$ for the RP, and combines it in the subject  filed (in detail, the common name)  of the certificate while the endpoint is already contained. Instead of sending  in Step 2.1.2 in Figure~\ref{fig:process}, $Cert_{RP}$  is sent to the user during the key agreement in TLS. Moreover, the mechanisms (e.g., the Certificate Transparency) to avoid illegal certificate issued by the CA being adopted to ensure the correctness of $ID_{RP}$, i.e., globally unique and being the primitive root.


