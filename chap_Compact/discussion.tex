\section{Discussions}
\label{sec:discussion}

%Some related issues are discussed in this section.


%\vspace{1mm}
\noindent{\textbf{Applicability of Identity Transformations.}}
Three identity-transformation functions, i.e., $\mathcal{F}_{PID_{RP}}()$, $\mathcal{F}_{PID_U}()$, and $\mathcal{F}_{Acct}()$,
    are applicable to various SSO scenarios
        (e.g., web application, mobile App, and native software),
    because these functions follow the common model of SSO protocols
    and do not depend on any special implementation or runtime environment.
Although the prototype system runs for web applications,
    it is feasible to apply the identity-transformation functions to other SSO scenarios
        to protect user privacy.
%Moreover,
%    because the authentication steps are independent of the UPPRESSO protocol,
%the IdP can choose any appropriate mechanism to authenticate users.


%In this paper, the functions are implemented based on the elliptic curve algorithm and the mechanism provided by OIDC system.
%However, the transformation functions can also be implemented based on other mechanisms according to the protocol and environment, for example, the TPM may be used to take responsibility to transform identities.

\vspace{1mm}\noindent{\textbf{Scalability.}} Adversaries cannot exhaust $ID_{RP}$ or $PID_{RP}$.
$ID_{RP}$ is generated uniquely only in every RP's initial registration,
    and the capacity is $n$ (i.e., the order of $G$). For example, for the NIST P256 elliptic curve, $n$ is approximately $2^{256}$.
As for $PID_{RP}$,  we only need to ensure $PID_{RP}$ is unique among \emph{unexpired} identity tokens,
    the number of which is denoted as $\sigma$.
The probability that at least two $PID_{RP}$s are identical among these $\sigma$ ones,
    is $1-\prod_{i=0}^{\sigma-1}(1-i/n)$.
For example,
    when the IdP serves $10^{8}$ requests per second and the validity period of identity tokens is 10 minutes,
     $\sigma$ is less than $2^{36}$ and the probability is less than $2^{-183}$ for the NIST P256 elliptic curve.
This probability is negligible.

The capacity of accounts at any RP is also $n$.
$\mathbb{E}$ is a finite cyclic group,
    so $ID_{RP} = [r]G$ is also a generator and the order of $ID_{RP}$ is $n$.
Therefore, given an RP,
    a unique account is inherently assigned to every user,
        because $Acct =  [ID_U]ID_{RP} = [u]ID_{RP}$ ($1 < u < n$).

%%DoS
%%Security against ID exhaustion DoS
%%1.用户被鉴别过的，可以事后审计的； 2. IdP， 本来对OIDC是做一次数字签名， 加了一次模幂，资源消耗 --> DoS attack
%\vspace{1mm}\noindent{\textbf{Security against DoS attack.}}
%The adversary may attempt to perform DoS attack on the IdP and RP. For example, the adversary may act as a user to invoke the $PID_{RP}$ registration and identity token generation at the IdP, which requires the IdP to perform two signature generations and one modular exponentiation.
%However, as the user has already been authenticated at the IdP, the IdP could identify the malicious users based on audit, in addition to the existing DoS mitigation schemes.
%%The adversary may act as a user requesting to log into an RP, and make the RP perform two modular exponentiations.
%%The RP could previously calculated a set of $Y_{RP}$s to mitigate this attack.


%授权码
%兼容:目前只提供隐式模式,对其他模式与协议的兼容方法
\vspace{1mm}\noindent{\textbf{Compatibility with the Authorization Code and Access Token.}}
In the authorization code flow of OIDC \cite{OpenIDConnect},
    the IdP does not directly issue the identity token;
        instead,
            an authorization code is forwarded to the RP,
            and then the RP uses this code to ask for identity token from the IdP.         
The identity-transformation functions $\mathcal{F}_{PID_{U}}$, $\mathcal{F}_{PID_{RP}}$ and $\mathcal{F}_{Acct}$
    can be integrated into the authorization code flow, similar with the login flow introduced in section~\ref{implementations}, by replacing the identity token with the authorization code.
    The implementation of authorization code is not clearly defined by OIDC specification~\cite{OpenIDConnect}, while usually it should be the character string used as the index into IdP database storing the data, such as generated identity tokens.
    Thus, the authorization would not expose user's information to RP. 
    However, after receiving the authorization code, RP server would use the authorization code and a secret (issued by IdP while registering at IdP) to retrieve the identity token from IdP directly. 
    To avoid the IdP recognizing the RP's identity, the RPs should use the same secret, or use the secrets to generate indistinguishable proofs, such as group signatures~\cite{chaum1991group}.
    It allows the IdP to obtain the RP's network information (e.g., IP address).
To prevent this leakage,
    the RP needs to integrate anonymous networks (e.g., Tor) to ask for identity tokens in the authorization code flow.
    
    Moreover, IdP can also issue the access token to RP beside of identity token, while the specifications\cite{rfc6749, rfc6750} define mechanisms to obtain and use access tokens to access resources but do not define standard methods to provide identity information. 
    That is, the access token is not required to carry any RP and user's information explicitly, therefore, it would not expose any user's information to RP.
    % to generate and verify two types of tokens.
%That is,
 %   $PID_{RP}$ but not $ID_{RP}$ is enclosed in access tokens by the IdP,
  %      and the RP accepts an access token with matching $PID_{RP}$ only.
%Then,
 %   the RP uses the access token to request the identity token with $PID_U$,
% so the privacy threats are still prevented in authorization code flow.

%However,
 %   as the RP receives the identity token directly from the IdP in this flow,
 %           it allows the IdP to obtain the RP's network information (e.g., IP address).
%To prevent this leakage,
 %   the RP needs to integrate anonymous networks (e.g., Tor) to ask for identity tokens  in the authorization code flow.

%平台无关
%Similar as SPRESSO, we can integrated for***
%SPRESSO跨平台:我们目前的方案只在browser实现
%我们现在的实现使得一个用户不需要在机器上存任何东西，只有装那个插件。这个实现可以进一步推广到这个插件都不用安装***
%\vspace{1mm}\noindent{\textbf{Platform independent.}}
%Our current implementation only requires the user to install a Chrome extension and doesn't need to store any persistent data at the user's machine.
%Moreover, the implementation could  be further extended to remove the Chrome extension, whose JavaScript program is then fetched from the honest IdP. The processing is similar as SPRESSO. That is, 1) the RP's window (window A)  opens a new iframe (window B) to visit the RP's web page, while the RP's web page redirects window B to the IdP; 2) window B downloads the JavaScript  program from the IdP and performs the processing in Steps 1.3, 1.5, 2.1, 3.2 and 3.5; 3) then postMessages are adopted to exchange messages between window A and B for Steps 1.2, 1.3, 1.4, 2.3, 3.1 and 3.5.
%The opener handle of window B is preserved (i.e., window A) for the postMessage, as window A  opens window B with a web page from the RP;
 %and window B is redirected to the IdP with \emph{noreferrer} attribute set, to prevent the browser from sending RP's URL in the Referrer header to the IdP.



%malicious IdP
%标题，collusive RPs-->PSI PSI实现的前提条件被破坏。 PSI使得RP在不侵犯用户隐私的前提下，进行idenity linkage。
%RP designation --> RP specification / binding
%The primary goal of SSO services is to implement secure user authentication [6], ---> 6多加几个参考文献
%User privacy leaks in all existing SSO protocols and implementations. -->加几个参考文献






%1) RP's window opens a new window to download a document from RP; 2) the document uses JavaScript to navigate this window to IdP, while the noreferrer attribute is set to clear Referer header and prevent the browser from sending RP's URL to the IdP; 3) this window downloads the  JavaScript  program from IdP and performs the processing in Steps 2.1.3, 2.2.1, 2.4 and 5.2; 4) the opener handle of this new window is preserved (i.e., RP's window) and then postMessages can be adopted to exchange messages between the two windows for Steps 2.1.4, 2.1.6, 2.2.4, 2.3 and 5.3.

%the RP's web page initiates the loading of IdP's web page and sets the attribute (rel="noreferrer") to prevent the browser from sending Referer header with RP's URL to the IdP; 2) the IdP's web page contains the JavaScript program for user's processing in Steps 2.1.3, 2.2.1, 2.4 and 5.2; 3) postMessages is adopted
%; and 4) the correct RP sets subresource integrity (SRI) to prevent the IdP from providing incorrect JavaScript programs.
%A native web technology called subresource integrity (SRI)7 is currently under development at the W3C. SRI allows a document to create an iframe with an attribute integrity that takes a hash value. The browser now would guarantee that the document loaded into the iframe hashes to exactly the given value. So, essentially the creator of the iframe can enforce the iframe to be loaded with a aspecific document. This would enable SPRESSO to automatically check the integrity of FWDdoc without any extensions.



%While USPRESS is designed for semi-honest IdP, it could be extended to prevent


%\noindent{\textbf{Malicious IdP mitigation.}} The IdP is assumed to assign a unique $ID_{RP}$ in $Cert_{RP}$ for each RP and generate the correct $PID_U$ for each login. The malicious IdP may attempt to provide the incorrect $ID_{RP}$ and $PID_U$, which could be prevented by integrating certificate transparency \cite{rfc6962} and user's identifier check \cite{SPRESSO}. With certificate transparency \cite{rfc6962}, the monitors  check the uniqueness of $ID_{RP}$ among all the certificates stored in the log server. To prevent the malicious IdP from injecting any incorrect $PID_U$, the user could provide a nickname to the RP for an extra check as in SPRESSO \cite{SPRESSO}.

\vspace{1mm}
\noindent{\textbf{Collusive Attack by the IdP and RPs.}}
When the IdP is still kept curious-but-honest but shares messages in the login flow (i.e.,
$ID_U$, $PID_{RP}$, and $PID_U$)
        with some collusive RPs,
UPPRESSO still provides secure SSO services,
    provided that the signed identity tokens are sent to the authenticated users only;
however,
    the collusive adversaries are able to trace the users' login activities to these RPs.
Anyway, even in this case, a user's login activities at the other RPs not collusive with the IdP,
        are still protected from the IdP and these collusive RPs,
        because a triad of $t$, $PID_U$ and $PID_{RP}$ is ephemeral and independent of each other.

\vspace{1mm}\noindent{\textbf{Implementation with Browser Extensions.}}
To improve the portability of user agents,
    the user functions of UPPRESSO are implemented by web scripts in the prototype.
However,
    when these functions are implemented with browser extensions,
    it results in better performance.
In this case,
    a user downloads and installs the browser extension,
    before he visits the RPs.
We have implemented such a browser extension while the IdP and RPs are unmodified,
 \textcolor[rgb]{1,0,0}{and experiments show that at least 102 ms will be saved for each login instance (i.e., about 208 ms in total),}
    compared with the version implemented with portable web scripts.

\vspace{1mm}\noindent{\textbf{Restriction of the RP Script's Origin.}}
When the IdP script forwards identity tokens to the RP script within the user browser,
    the receiver is restricted by the \verb+postMessage+ targetOrigin mechanism \cite{postm-targeto},
        to ensure it will forward the tokens to $Enpt_{RP}$,
        which is bound in the RP certificate.
A targetOrigin is specified as
    a domain (e.g., \verb+www.RP.com+) and the parts of protocol and port (if not presented, implicitly 80 for \verb+http+ and 443 for \verb+https+),
        and it requires the RP script's origin accurately matches the targetOrigin.

Although the path part of $Enpt_{RP}$, e.g., \verb+/SSO/uploadTkn+,
 is not checked by the targetOrigin mechanism,
  which means that only one RP is assumed to run on a domain,
   it brings no extra risk.
For example, if two independent RPs run on one domain but with different endpoints to receive identity tokens
        (e.g., \verb+https://www.RP.com/honest/uploadTkn+ and \verb+https://www.RP.com/attack/uploadTkn+),
         they cannot be distinguished by web scripts and \verb+postMessage+.
On the other hand, browsers enforce
 the same-origin policy \cite{sop} in the access control of web resources,
    and the control granularity is also origins only.
Therefore,
    a malicious RP could always access the other's resources within a user's browser,
        e.g., steal the cookie
        by web scripts such as 
        \verb+vw = window.open('http://www.RP.com/honest')+
    and \verb+vw.document.cookie+,
    even when the honest RP restricts that only HTTP requests to specific paths carry its cookie.
%Anyway, such RPs are distinguished by the implementation with browser extensions.

%We do not consider two hostile RPs on a domain.
%Similar attacks exist in HTTPS, because an HTTPS server certificate
%only binding the domain.
%So, since they share the domain and the private key of HTTPS server certificate,
%    RP1 can always be the MitM attackers of RP2.
%RP1 exploits the vulnerability of HTTPS server certificate is fine to attack,
%    by the shared private key.

\vspace{1mm}\noindent{\textbf{Alternative Way to Bind $ID_{RP}$ and $Enpt_{RP}$.}}
In the prototype, we bind $ID_{RP}$ and $Enpt_{RP}$ by RP certificates,
    verified by the honest IdP script.
The RP certificates ensure that the target RP has already registered itself at the IdP,
 which prevents unauthorized RPs from accessing the IdP's SSO services.


This binding may be finished in another way:
    $ID_{RP}$ is deterministically calculated based on the RP's unambiguous domain (e.g.,
    \verb+https://www.RP.com/+).
For example,
    $Hs()$ encodes an RP's domain (or the RP script's origin) to a point on an elliptic curve $\mathbb{E}$ as $ID_{RP}$,
where
    hashing to elliptic curves $Hs()$ \cite{irtf-cfrg-hash-to-curve-16} provides collision resistance and does not reveal the discrete logarithm of the output
    (i.e., $ID_{RP} = [r]G$ but $r$ is unknown).
Then, the RP script will send the endpoint but not its RP certificate,
to the IdP script in Step 2.2,
 and $ID_{RP}$ is calculated by the IdP script.
%This elimination of RP certificates improves the downloading of scripts,
%        and on average \textcolor[rgb]{1,0,0}{xxx} ms are saved.
However, once the RP updates its domain, for instance, from \verb+https://www.theRP.com/+ to \verb+https://www.RP.com/+, 
$Acct = [ID_U]ID_{RP}$ will change inevitably.
When such an event happens,
    the RP needs special operations by each user to migrate an account
            to the updated RP system.
Note that this migration of accounts requires extra cooperations explicitly by each user;
    otherwise,
        two collusive RPs could actually link a user's accounts across RPs.


%\vspace{1mm}
%\noindent{\textbf{Active Identity Linkage by Malicious RPs.}}
%When a user logins to multiple RPs \emph{concurrently} on one device as different accounts,
%        malicious RPs might actively correlate the accounts by online means.
%For instance,
%     when the user has logined to $RP_j$ with $Acct_j$,
%         malicious $RP_j$ might try to redirect $Acct_j$ to another $RP_{j'}$ through a hidden iframe in the browser.
%As long as he has logined to $RP_{j'}$,
%     two accounts would be correlated by $RP_{j'}$.
%This active attack appears not only in SSO systems, but also exists in all web applications.
%Anyway,
%    this attack can be prevented through various methods,
% such as checking hidden iframes in the script
%  and detecting the redirection by browser extensions.
%
