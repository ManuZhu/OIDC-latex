\section{Discussions}
\label{sec:discussion}

\noindent{\textbf{Collusive Attack by an IdP and RPs.}}
Privacy-preserving identity federation solutions \cite{ELPASSO,UnlimitID,idemix,PseudoID,Opaak,uprov}
 prevent the collusive attacks by an IdP and RPs,
    at the cost of (\emph{a}) a long-term secret held by a user but verified by RPs
        and (\emph{b}) user-managed accounts \cite{PseudoID} for different RPs.
Such accounts may be derived from an RP's domain and this secret locally \cite{ELPASSO,UnlimitID,Opaak,uprov,idemix},
  but it still brings inconveniences.
For web applications, a user needs to install a browser extension to handle this long-term secret;
  and if it is lost or leaked,
       a user has to notify all RPs to update his accounts which are derived from the secret
        (if the accounts are not masked by the user's secret, the colluding IdP and RPs can eventually link them).

UPPRESSO does not protect user privacy against such collusive attacks,
    but a user is authenticated to \emph{only} an IdP:
         the user identity at the IdP
                are transformed to the accounts at RPs, unrelated to any user credential
                 (e.g., password, one-time password, smart card or FIDO device).


\vspace{0.75mm}
\noindent{\textbf{Scalability.}}
$ID_{RP}$ is generated uniquely in an RP's initial registration,
    and the capacity of RPs is $n$ (i.e., the order of $G$). For the NIST P256 elliptic curve, $n$ is approximately $2^{256}$.
$PID_{RP}$ cannot be exhausted, either.
We ensure $PID_{RP}$ is unique in unexpired tokens,
    the number of which is $\sigma$.
The probability that at least two $PID_{RP}$s are identical among the $\sigma$ ones,
    is $1-\prod_{i=0}^{\sigma-1}(1-i/n)$.
If the system serves $10^{8}$ requests per second and the validity period is 10 minutes,
     $\sigma$ is less than $2^{36}$ and the $PID_{RP}$-collision probability is negligible (i.e., less than $2^{-183}$)
      for the NIST P256 curve.

The capacity of accounts at any RP is also $n$,
    the same as that of user identities at the IdP.
$\mathbb{E}$ is a finite cyclic group,
    so $ID_{RP} = [r]G$ is also a generator of order $n$.
Thus, given any RP,
because $Acct =  [ID_U]ID_{RP} = [u]ID_{RP}$,
    a unique account is automatically assigned to every user.

Besides, stronger elliptic curves accommodate more RPs and users;
e.g., $n$ is nearly $2^{384}$ for the NIST P384 curve.


\vspace{0.75mm}
\noindent{\textbf{Support for the Authorization Code Flow.}}
In the authorization code flow of OIDC \cite{OpenIDConnect},
    an IdP does not directly response with identity tokens;
        instead,
            an authorization code is sent to the RP,
            which uses this code to ask for identity tokens.
The identity-transformation algorithms $\mathcal{F}_{PID_{U}}$, $\mathcal{F}_{PID_{RP}}$ and $\mathcal{F}_{Acct}$
    can be integrated into the authorization code flow:
    %similar with the login flow introduced in Section \ref{implementations},
            an authorization code is forwarded to the RP script by the IdP script
                and this code is used to ask for an identity token binding $PID_U$ and $PID_{RP}$.
An authorization code is an index to retrieve identity tokens from the IdP,
        and does not disclose information about the authenticated user.


After receiving an authorization code, an RP uses it and another secret credential
         which is issued by the IdP during the initial registration \cite{OpenIDConnect},
     to retrieve identity tokens from the IdP.
To protect RP identities from the IdP,
        anonymous tokens (e.g., ring or group signatures \cite{ring-sig,chaum1991group},
         and TrustToken \cite{trusttoken})
        and anonymous networks (e.g., Tor \cite{tor}) need to be adopted for RPs
         in the retrieval of identity tokens.

\vspace{0.75mm}
\noindent{\textbf{Alternative Way to Generate $ID_{RP}$ and Bind $Enpt_{RP}$.}}
In the prototype an RP certificate binds $ID_{RP}$ and $Enpt_{RP}$,
    verified by the honest IdP script.
RP certificates ensure the target RP has already registered itself at the IdP,
 which prevents unauthorized RPs from accessing the IdP's services.

This binding may be finished in another way:
    $ID_{RP}$ is \emph{deterministically} calculated based on the RP's unambiguous name.
For example, $Hs()$ encodes an RP's domain (or the RP script's origin, e.g., \verb+https://RP.com+) to
 a point on $\mathbb{E}$ as $ID_{RP}$,
where
    hashing to elliptic curves $Hs()$ \cite{irtf-cfrg-hash-to-curve-16} provides collision resistance
     and does not reveal the discrete logarithm of the output
    (i.e., $ID_{RP} = [r]G$ is \emph{unique} and $r$ is \emph{unknown}).
Then,  in Step 2.2 the RP script will send the endpoint but not its RP certificate,
  %to the IdP script,
 and $ID_{RP}$ is calculated by the IdP script.
%This elimination of RP certificates improves the downloading of scripts,
%        and on average \textcolor[rgb]{1,0,0}{xxx} ms are saved.
However, if an RP updates its domain, for instance, from \verb+https://RP.com+ to \verb+https://theRP.com+,
$Acct = [ID_U]ID_{RP}$ will change inevitably.
In such cases,
    it needs special operations by each user to migrate his account
            to the updated RP system.
This account migration requires extra operations explicitly by each user;
    otherwise,
        colluding RPs could actually link a user's accounts across RPs.


\vspace{0.75mm}
\noindent{\textbf{Restriction of the RP Script's Origin.}}
When identity tokens are forwarded by the IdP script to the RP script, % within the user browser,
    the receiver is restricted by the \verb+postMessage+ targetOrigin mechanism \cite{postm-targeto},
        to ensure it will forward the tokens to $Enpt_{RP}$
        that is bound in RP certificates.
A targetOrigin is specified as
a pair of protocol and port (if not presented, implicitly 80 for \verb+http+ and 443 for \verb+https+)
    and a domain (e.g., \verb+RP.com+),
        and it requires the RP script's origin accurately matches the targetOrigin.

Although the URL path part of $Enpt_{RP}$ %, e.g., \verb+/uploadTkn+,
 is not checked by the targetOrigin mechanism,
  which assumes only one RP runs on a domain,
   it brings no \emph{extra} risk.
For example, if two RPs run on one domain but with different endpoints to receive identity tokens
        (e.g., \verb+https://RP.com/honest/tk+ and \verb+https://RP.com/malicious/tk+),
         they cannot be distinguished by \verb+postMessage+.
Meanwhile, browsers enforce
 the same-origin policy (SOP) in the access control of web resources \cite{sop}.
So
    a malicious RP could always access the other RP's resources in browsers,
        e.g., steal cookies
        by the script
        \verb+window.open('https://RP.com/honest').document.cookie+,
    even if the honest RP restricts only HTTP requests to specific paths carry its cookies.
That is, this risk actually results from the SOP design of browsers.



\vspace{0.75mm}
\noindent{\textbf{Applicability of Identity Transformations.}}
The proposed identity-transformation algorithms %i.e., $\mathcal{F}_{PID_{RP}}()$, $\mathcal{F}_{PID_U}()$, and $\mathcal{F}_{Acct}()$,
    are applicable to various SSO scenarios
        (e.g., web application, mobile App, and native software),
    because these algorithms follow the common model of popular SSO protocols
    and do not depend on any special implementation or runtime.



%%%%%%%%%%%%%%%%%%%%% 几个方面的扩展
% 1. 解决IdP数据泄露
% 如果IdP的数据库泄露，用户列表u公开，则RP就可以，针对每一个u，计算[u]ID_{RP}；然后，
% 2. 授权码模式
% 可以使用PKCE方式，直接在前端获取。通常，PKCS模式用在没有后端的RP（例如，纯客户端）。
% 对于有后端，可以将​code_verifier传给RP后端？也能够达到目标。
% 3. RP后端访问IdP，需要通过TOR
% 为了不传递RP ID和Secret，可以是：传递PKCE的code_verifier [user将code_verifier传递给RP]，
% 也可以是群签名/环签名之类的。
% 4. 要求RP有授权
% 可以有2种方式：
%   去掉RP Cert；采取授权码方式 + 群签名/环签名之类凭证。
%   去掉RP Cert：采取授权码方式 + PrivacyPass之类匿名凭证（还可以有准确计费）。
% 5. 还有一种方式
% 隐式模式 + PrivacyPass之类匿名凭证（还可以有准确计费）。因为其它方式都需要通过TOR。
