\section{Security and Privacy Analysis}
\label{sec:analysis}
In this section, we analyze the security and privacy guarantees provided by \usso~and show that it achieves all four required security properties defined in Section~\ref{subsec:basicrequirements} and prevents both types of privacy threats against SSO services.

%\subsection{Extended Adversarial Models}
\label{adver-model}

% \textcolor{blue}{Based on the threat model and assumptions proposed in Section \ref{sec:UPPRESSO},
%     different types of adversaries are considered in the analysis of security and privacy.
% First of all, in the proofs of security,
%     malicious RPs collude with malicious users,
%         attempting
%         to break any of the four security properties of SSO identity tokens for an honest user to visit an honest RP.
% Then, in the analysis of privacy against the IdP-based login tracing,
%    an honest-but-curious IdP is the only adversary.
% Finally,
%     in the privacy analysis against the RP-based identity linkage,
%     a number of malicious RPs collude, attempting to link an honest user's accounts across these RPs.}

% We first analyzed UPPRESSO %especially confidentiality and integrity,
%      based on a Dolev-Yao-style model \cite{SPRESSO}.
% % which has been used in the formal analysis of SSO protocols such as OAuth 2.0 \cite{FettKS16} and OIDC \cite{FettKS17}.
% The model abstracts the entities in a web system,
%     such as web servers and browsers,
%     as \emph{atomic processes}. %which communicate with each other through events. % such as HTTPS request and response.
% It defines \emph{script processes} to formulate client-side scripts.
% %The script is dependently invoked by the browser to process the server-defined logic.
%   %such as verifying $Certificate_{RP}$.
% %
% %postmessage events;
% %
% %atomic process <-> script process, communication.
% %
% %Other events change self-trigger.
% %
% UPPRESSO contains atomic processes including:
% an IdP process,
%     a finite set of web servers for honest RPs, a finite set of honest browsers, and a finite set of attacker processes.
% The processes communicate with each other through events such as HTTPS requests and responses.
% %We consider all RP and browser processes are honest,
% An RP or a browser controlled by adversaries is modeled as an attacker process.
% Within a browser,
%  an honest IdP script, an honest RP script, and also attacker scripts which are downloaded from attacker processes,
%   are invoked.
% %Although the scripts coexist in the same browser, they are strictly separated.
% Script processes communicate with each other through \verb+postMessage+,
%     modelled as transmitted-to-itself events of a browser process.
% %To clearly indicate the action of postMessage communication, we define it as the transmitting-to-itself event of the browser (which is not defined in SPRESSO).


% \textcolor{blue}{After formulating the system by this model,
%     we analyze the following data for the proofs in Sections \ref{analysis-security} and \ref{sec-:analysis},
%      when there are corresponding adversaries.
% We (\emph{a}) trace the lifecycle of an identity token for an honest user to visit an honest RP,
%         starting when it is generated and ending when accepted by the RP,
%     to ensure it is not leaked to adversaries,
% (\emph{b})
%     locate all places
%         where $PID_U$, $PID_{RP}$ and other parameters enclosed in the token are processed,
%      to ensure no adversary able to manipulate them,
% and (\emph{c})
%     locate the places where $PK$ is transmitted and used in the IdP script,
%         to ensure no adversary tampering with it.
% These conclusions are used to prove security of the UPPRESSO protocols.}
% %
% % to ensure it is not leaked to attackers or tampered with by any adversary without checking.
% \textcolor{blue}{In the meantime,
%         this model ensures that (\emph{a}) $t$ is unaccessible to the honest-but-curious IdP,
%  which is necessary to prevent the IdP-based login tracing,
%  and (\emph{b}) $u$ and $r$ are not leaked to RPs in the protocols,
%     necessary to prevent the RP-based identity linkage.}

\newc
The threat model defined in Section~\ref{subsec:threatmodel} depicts potential adversaries against SSO as honest-but-curious IdPs, malicious RPs, and malicious users, where malicious RPs and users could collude. Based on their objectives, we consider three adversarial scenarios in the security analysis and present our goals in each scenario: {\bf \emph{(S1)}} a malicious user colludes with each other or with malicious RPs to impersonate an honest user to log in to an honest RP or entice an honest user to log in to an honest RP on her behalf. To prevent both types of impersonation attacks, the SSO should provide all {\em four SSO security properties}; {\bf \emph{(S2)}} the honest-but-curious IdP infers the identity of the RP(s) that the user requests to access, which requires SSO to provide {\em privacy against the IdP}; and {\bf \emph{(S3)}} malicious RPs collude with each other or with malicious users to deduce the user identity or link her pseudo-identities, which requires the SSO to provide {\em privacy against colluding RPs}.

Next, we prove that \usso~is secure in the first adversarial scenario in Section~\ref{analysis-security} and it can prevent privacy threats in the other two adversarial scenarios in Section~\ref{sec-:analysis}.
\oldc

%======move to security analysis
%The RP cannot derive $ID_U$ from either $PID_U$ or $Acct$ due to the elliptic curve discrete logarithm problem (ECDLP). Since $t$ is random in $\mathbb{Z}_n$ and unknown to the IdP, from the IdP's view, $PID_{RP}$ is indistinguishable from a random variable on $\mathbb{E}$. So, the IdP cannot learn anything about $ID_{RP}$ from $PID_{RP}$.
%Section \ref{sec:analysis} presents more detailed analyses.

\subsection{Security}
\label{analysis-security}
%UPPRESSO satisfies four sufficient conditions (i.e., RP designation, user identification, integrity, and confidentiality of identity tokens) of secure SSO services \cite{ArmandoCCCT08,FettKS16, FettKS17}, as stated in Section \ref{subsec:basicrequirements}.

\newc
In a secure SSO that is robust against impersonation attacks, an honest user should be able to prove her identity to the target RP with an identity token issued by the IdP. As pseudo-identities are used in \usso, an RP needs to verify that ({\em a}) $PID_{RP}$ in the received identity token is a transformation from its own $ID_{RP}$ and tied to the current login instance, which requires {\em RP designation}; and ({\em b}) $PID_U$ included in the identity token can be associated with a unique, long-term user account it maintains, which requires {\em user identification}. Besides, the identity token for an honest RP should not be intercepted by malicious users or RPs, requiring a guarantee for the {\em confidentiality of identity tokens}, nor be forged or tampered with to include a fake $PID_U$ or $PID_{RP}$, requiring a guarantee for the {\em integrity of identity tokens}.
\oldc


To prove that \usso~satisfies these four properties, we first formalize its login flow using a Dolev-Yao-style model \cite{SPRESSO}, % which has been used in the formal analysis of SSO protocols such as OAuth 2.0 \cite{FettKS16} and OIDC \cite{FettKS17}.
which abstracts the entities in a web system, such as web servers and browsers, as \emph{atomic processes} %which communicate with each other through events. % such as HTTPS request and response.
and then defines \emph{script processes} to formulate client-side scripts.
%The script is dependently invoked by the browser to process the server-defined logic.%such as verifying $Certificate_{RP}$. %postmessage events; %atomic process <-> script process, communication. %Other events change self-trigger.
Therefore, the atomic processes of \usso~include an {\em IdP process}, a finite set of {\em web servers} for honest RPs, a finite set of honest {\em browsers}, and a finite set of {\em attacker processes} that model malicious RPs and malicious users. The processes communicate with each other through events such as HTTPS requests and responses. A browser may have an honest IdP script and multiple RP scripts that could be honest or malicious.
%Although the scripts coexist in the same browser, they are strictly separated.
The script processes communicate with each other through \verb+postMessage+, which are modeled as transmitted-to-itself events of a browser process.
%To clearly indicate the action of postMessage communication, we define it as the transmitting-to-itself event of the browser (which is not defined in SPRESSO).

\newc
With this formal model (referred to as the \dy~model), we could (\emph{a}) trace the identity token lifecycle from its generation at the IdP to its acceptance at the RP to prove that it cannot be leaked to adversaries; (\emph{b}) locate the places where $PID_U$, $PID_{RP}$, and other elements in the identity token are processed to prove that they cannot be manipulated by any adversary; and (\emph{c}) locate the places where the IdP script uses $PK$ for verification to prove that it cannot be replaced by any adversary. Besides, we show that the IdP cannot view $t$ shared only between the user and the RP, while the RPs cannot view $u$ shared between the user and the IdP. It is trivial to prove the security of $r$, as it never leaves the IdP.

Next, we present the proofs of four security properties supported by \usso.
%These conclusions are used to prove the security of the UPPRESSO protocols.
We consider an arbitrary login instance in which an arbitrary RP with $ID_{RP}$ receives an integer $t$ and an identity token $T$ issued by the IdP, binding a $PID_U$ and a $PID_{RP}$, from the RP script in a user browser. $T$ is considered a valid identity token if the RP could verify its signature using the IdP's public key $PK$.


%\noindent{\textbf{RP Designation:} {\em Provided that $r$ is known only to the IdP, $PID_{RP}$ in the identity token uniquely designates the RP with $ID_{RP} = [r]G$.}}
\vspace{1mm}
\noindent\textsc{Theorem 1. (RP Designation)} {\em If $T$ is a valid identity token and $PID_{RP} = [t]ID_{RP}$ is satisfied, $PID_{RP}$ uniquely designates the RP that receives $T$.}

\vspace{0.75mm}
\noindent\textsc{Proof.} To prove this designation relationship, we need to verify that $PID_{RP}$ is a valid pseudo-identity, which is associated with the RP receiving the identity token and cannot be associated with any other RPs in the system.
First, $PID_{RP}$ in a valid $T$ is considered a valid pseudo-identity based on Lemma 1. The RP then computes $[t]ID_{RP}$ itself. If $PID_{RP} = [t]ID_{RP}$ holds, it can confirm that $PID_{RP}$ is its own pseudo-identity, which is transformed using the trapdoor $t$.

Next, the RP receives $t$ and $T$ from the RP script, which could be honest or malicious. Hence, from a malicious RP script, the RP could receive a valid identity token issued by the honest IdP for a malicious user and a colluding RP, according to the \dy~model. However, Lemma 2 shows that the probability of associating $PID_{RP}$ with any other RPs is negligible if $PID_{RP} = [t]ID_{RP}$ is satisfied. Therefore, $PID_{RP}$ designates the receiving RP and only this RP in the system.  \hfill $\square$

\vspace{1mm}
\noindent\textcolor{blue}{\textsc{Lemma 1.} {\em A valid identity token cannot be forged by any adversaries.}}

\vspace{0.75mm}
\noindent\textcolor{blue}{\textsc{Proof.} According to the \dy~model, the RP obtains the IdP's public key $PK$ directly from the IdP server over HTTPS. Hence, $PK$ and the token $T$ (and its content) cannot be manipulated by adversaries. \hfill $\square$}


\vspace{1mm}
\noindent\textsc{Lemma 2.} {\em  For any two different RPs in a finite set of registered RPs, the probability of finding two different random numbers $t \in [1,n)$ and $t' \in [1,n)$ that satisfy $[t]ID_{RP_j} = [t']ID_{RP_{j'}}$ is negligible, where $ID_{RP_j}=[r]G$, $ID_{RP_{j'}}=[r']G$, $r$ and $r'$ are two different integers, and $G$ is a point on an elliptic curve $\mathbb{E}$.}

%Based on the ECDLP we prove that, for adversaries, the probability of finding $t$ and $t'$ satisfying $[t]ID_{RP_j} = [t']ID_{RP_{j'}}$ is negligible, where $RP_j$ and $RP_{j'}$ are any two RPs in the finite set of RPs (i.e., $ID_{RP_j} = [r_j]G$ and $ID_{RP_{j'}} = [r_{j'}]G$, while $r_j$ and $r_{j'}$ are kept secret to the adversaries). This negligible probability means $PID_{RP_j} = [t]ID_{RP_j}$ designates \emph{only} the target RP with $ID_{RP_j}$.

\oldc
\vspace{0.75mm}
\noindent\textsc{Proof.} Finding $t$ and $t'$ satisfying $[t]ID_{RP_j} = [t']ID_{RP_{j'}}$ is a $PID_{RP}$-collision attack, which can be described as a game $\mathcal{G}_c$ between an adversary and a challenger: the adversary receives a finite set of RP identities, denoted as ($ID_{RP_1}$, ..., $ID_{RP_m}$), from the challenger, where $m$ is the number of the RPs in the system, and outputs $(a, b, t, t')$.
If $[t]ID_{RP_a}=[t']ID_{RP_b}$, the adversary succeeds in the game.
%If the adversary has the non-negligible probability on succeeding in this game, RP designation is broken.
The attack success probability is defined as ${\rm Pr}_s$.

For $ID_{RP}=[r]G$, let $Q=[t]ID_{RP}=[tr]G=[x]G$, where $Q$ is also a point on $\mathbb{E}$ of order $n$, and $x$ is also a random number in $\mathbb{Z}_n$. Given $Q$ on the curve, finding a number $x$ satisfying $Q = [x]G$ is an elliptic curve discrete logarithm problem (ECDLP). The probability of solving this problem using a probabilistic polynomial time (PPT) algorithm $\mathcal{D}$ can be defined as:
%For any PPT algorithm $\mathcal{D}$ is used to calculate $x$, we define the probability of finding $x$ as: %Therefore, the probability of finding $x$ using a probabilistic polynomial time (PPT) algorithm is negligible.
\begin{equation*}
{\rm Pr}\{\mathcal{D}(G, [x]G)=x\} = \epsilon_{c}(k)
\end{equation*}
%where ${\rm Pr}\{\}$ denotes the probability.
where $k$ denotes the security parameter. The probability, i.e. $\epsilon_{c}(k)$, becomes negligible, when $k$ is sufficiently large.
%For any sufficiently large $k$, $m \ll 2^k$ since $m$ is a finite integer.

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.97\linewidth]{fig/ecdlp_algorithm.pdf}
  \caption{The algorithm based on the $PID_{RP}$ collision, to solve the ECDLP}
  \label{fig:ecdlp_algorithm}
\end{figure}

Figure \ref{fig:ecdlp_algorithm} depicts the game %for solving the ECDLP problem
using a PPT algorithm $\mathcal{D}^*_c$ and the input ($G$, $Q$).
Upon receiving an input, the challenger first randomly chooses $r_1, \cdots, r_m$ in $\mathbb{Z}_n$ to calculate $[r_1]G, \cdots, [r_m]G$, randomly replaces a $[r_j]G$ with $Q$, and sends $m$ RP identities to the adversary, which then returns the result ($a$, $b$, $t$, $t'$).
Finally, the challenger calculates $s = t^{-1}t'r_b \bmod n$ and returns $s$ as the output of $\mathcal{D}^*_c$.

If $[r_a]G$ happens to be $Q$, the adversary of the game $\mathcal{G}_c$ succeeds. From $Q = [s]G$, we can find $x=s$ because $[tr_a]G = [t]Q = [t'r_b]G$. For the adversary, $Q$ is indistinguishable from any other RP identities in the input set, as $[r_j]G$ is randomly replaced by the challenger. Hence, the attack success probability can be formulated as:
\begin{equation*}
{\rm Pr}\{\mathcal{D}^*_c(G, [x]G)=x\} = {\rm Pr}\{x = s\}={\rm Pr}\{a=j\}{\rm Pr}_s=\frac{1}{m}{\rm Pr}_s
\end{equation*}

\newc
If there exists a means for the adversary to find $t$ and $t'$ satisfying $[t]ID_{RP_j} = [t']ID_{RP_{j'}}$, he would have advantages in $\mathcal{G}_c$. This indicates a non-negligible attack success probability regardless of $k$, from which we could deduce ${\rm Pr}_s$ is also non-negligible, as $m$ is a finite integer and $m \ll 2^k$ when $k$ is sufficiently large.
\oldc
This violates the ECDLP assumption. Therefore, the probability of finding $t$ and $t'$ that satisfy $[t]ID_{RP_j} = [t']ID_{RP_{j'}}$ in \usso~is negligible. \hfill $\square$

\newc
\vspace{1mm}
\noindent\textsc{Theorem 2. (User Identification)} {\em If $T$ is a valid token and $PID_{RP} = [t]ID_{RP}$ is satisfied, $PID_U$ in $T$ maps to a unique user account $Acct$ at the RP that receives $T$, and this account can be uniquely associated with a user registered with the IdP in the system.}


%\noindent\textcolor{blue}{\textbf{User Identification.}~~In the identity token binding $PID_U$ and $PID_{RP}$, the user pseudo-identity $PID_U$ identifies the authenticated user with $ID_U$, % as $Acct = [ID_U][ID_{RP}]$,
%and only this user,  at the target RP with $ID_{RP} = [r]G$.}
%That is, in UPPRESSO, $Acct$ identifies the mapping $[ID_u][ID_{RP}]$.

\vspace{0.75mm}
\noindent{\textsc{Proof.}
According to the \dy~model, the RP may receive a $T$ issued for another RP from a malicious RP script. However, if $PID_{RP} = [t]ID_{RP}$ holds, the RP can verify its designation by $PID_{RP}$ based on Theorem 1 and associates both $t$ and $T$ with the current login instance. Meanwhile, according to Lemma 1, $PID_U$ is a valid pseudo-identity, which cannot be forged by adversaries. Then, the RP can calculate $Acct$ using $t$ and $PID_U$ following Eq.~\ref{equ:Account}. $Acct$ is determined only by $ID_U$ and $ID_{RP}$ based on Eq.~\ref{equ:AccountNotChanged}, which are permanent identifiers issued by the IdP during registration. Hence, $Acct$ cannot be manipulated by adversaries and is independent of login instances. Therefore, in a user's multiple login instances to the same RP, $PID_U$s are always mapped to one and only one $Acct$ at that RP.


\oldc
Next, we prove that $Acct$ identifies one and only one user in the system. Since $\mathbb{E}$ is a finite cyclic group, $ID_{RP} = [r]G = Q$ is a generator on the curve of order $n$. Given a user with $ID_U = u$, $Acct = [ID_U]ID_{RP} = uQ$ is a unique point on the curve for $1 \leq u < n$, which is uniquely associated with $u$. \hfill $\square$

%The detailed process of proof is shown in Appendix.

\newc
\vspace{1mm}
\noindent{\textsc{Theorem 3. (Identity Token Integrity)}} {\em Consider an arbitrary identity token $T$ binding $PID_{RP}$ and $PID_U$. An honest RP accepts $T$ if and only if $T$ is valid, $PID_{RP}$ designates this RP with $ID_{RP}$, and $PID_U$ uniquely identifies a user account $Acct=[ID_U]ID_{RP}$ at this RP, indicating that $T$ binds $ID_{RP}$ and $Acct$.}

%it is designated by $PID_{RP}$, and then authenticates the requesting user under a unique account maintained at that RP.
%where $PID_U$ and $PID_{RP}$ are pseudo-identities of $ID_U$ and $ID_{RP}$, respectively.

%An honest RP accepts only identity tokens binding its pseudo-identity $PID_{RP}$ and the authenticated user's pseudo-identity $PID_U$, and actually binding $ID_{RP}$ and $Acct=[ID_U]ID_{RP}$, when $SK$ is held by only the IdP.

\vspace{0.75mm}
\noindent{\textsc{Proof.}
If any adversary modifies $T$ in any form, according to Lemma 1, $T$ would not be valid and would be rejected by the RP. Otherwise, $PID_{RP}$ and $PID_U$ in $T$ are valid pseudo-identities that cannot be forged by adversaries. According to Theorems 1 and 2, $PID_{RP}$ and $PID_U$ uniquely identify one RP and one user in the system, where the user holds an account $Acct = [t^{-1}]PID_{U}$ at the RP. Due to the one-to-one mapping between (\emph{a}) the pair of $Acct$ and $PID_{RP}$ and (\emph{b}) the triad of $PID_U$, $PID_{RP}$, and $t$, $T$ binds $ID_{RP}$ and $Acct$ implicitly. \hfill $\square$
\oldc

% A signed identity token binds $PID_{RP} = [t]ID_{RP}$ and $PID_U = [ID_U]PID_{RP}$, % $Acct$ and $ID_{RP}$ implicitly,
% and any breaking results in some failed checking or verification in the login flow as below.
%First of all, the identity token is signed by the honest IdP using $SK$ and verified by the RP using $PK$, so any modification will be rejected by the RP.
% According to the proof of RP designation, % there is no $t' \neq t$ but satisfying that $PID_{RP} = [t]ID_{RP_j} = [t']ID_{RP_{j'}}$.
% $PID_{RP}$ identifies only the RP with $ID_{RP}$; according to the proof of user identification, $PID_U$ identifies only the user with $Acct = [ID_U]ID_{RP}$ at the RP.
%Therefore, the identity token explicitly binding $PID_U$ and $PID_{RP}$, matches \emph{only} one $ID_{RP}$ and \emph{only} one $Acct = [t^{-1}]PID_{U}$.
%Therefore, $Acct$ and $ID_{RP}$ are actually bound in the token by the IdP's signatures,



\vspace{1mm}
\noindent\textcolor{blue}{\textbf{Confidentiality.}~~An identity token
    is accessible to only
                the authenticated user and the target RP, in addition to the IdP signing this token.}

\vspace{0.75mm}
\noindent\textbf{Proof.}
\textcolor{blue}{As analyzed in the Dolev-Yao-style model, no event leaks an identity token to any malicious entity other than the authenticated user and the designated RP.}
First of all, the communications among the IdP, RPs and users,
    are protected by HTTPS,
    and the \verb+postMessage+ HTML5 API ensures the dedicated channels between two scripts within the browser,
    so no other entities can eavesdrop the identity tokens.
Further, the IdP sends an identity token only to the authenticated user
        (i.e., the IdP script).
The IdP script forwards the token to the RP script
 only if it is downloaded from the same origin as $Enpt_{RP}$,
while the binding of $Enpt_{RP}$ and $ID_{RP}$ is ensured by a verified RP certificate
    and $PK$ is well set in the honest IdP script.
  %  which is verified by the IdP script.
So only the RP that owns $Enpt_{RP}$ and $ID_{RP}$,
    receives this token. $\square$



\subsection{Privacy}
\label{sec-:analysis}
UPPRESSO effectively prevents the privacy threats of IdP-based login tracing and RP-based identity linkage.

\textcolor{blue}{The information accessible to the IdP and derived from the RP's identity,
    is only $PID_{RP}$ in identity-token requests, where $PID_{RP} = [t]ID_{RP}$ is calculated by a user.
    % and $t$ is kept secret to the IdP.
So the prevention against the IdP-based login tracing in UPPRESSO
    is expressed formally as below.}

\vspace{1mm}
\noindent\textcolor{blue}{\textbf{Privacy against the IdP.}~~If $t$ is random in $\mathbb{Z}_n$ and unknown to the IdP,
the IdP
 cannot infer any information about $ID_{RP_j}$ or link any pair of $PID_{RP_j}^i$ and $PID_{RP_{j'}}^{i'}$
  ($i \neq i'$ but $j = j'$),
    from a user's identity-token requests for $PID_{RP_j}^i$ ($i,j = 1, 2, \cdots$).}

\vspace{0.75mm}
\noindent\textbf{Proof.}
Because (\emph{a}) $ID_{RP} = [r]G$ is also a generator of order $n$,
        where $G$ is a generator of finite cyclic group $\mathbb{E}$,
    \textcolor{blue}{and (\emph{b}) $t$ is a random number in $\mathbb{Z}_n$ and kept unknown to the IdP,}
 from the IdP's view,
 $PID_{RP}$
is \emph{indistinguishable} from a random variable on $\mathbb{E}$.
Thus,
    the IdP cannot infer any information about $ID_{RP}$ from $PID_{RP} = [t]ID_{RP}$,
or distinguish $[t]ID_{RP_j} = [tr]G$ from any other $[t']ID_{RP_{j'}} = [t'r']G$.
So the IdP-based login tracing is impossible. $\square$

\vspace{1mm}
\textcolor{blue}{In every login instance,
    without knowing $u$ and $r$,
    an RP holds $ID_{RP}$ and $Acct$, receives $t$, calculates $PID_{RP}$,
    and verifies $PID_{RP}$ and $PID_U$ in the identity token.
After filtering out the redundant information (i.e., $PID_{RP}= [t]{ID_{RP}}$ and $Acct = [t^{-1}]PID_{U}$),
    the RP actually receives $(ID_{RP}, t, Acct) = ([r]G, t, [ur]G)$.
Therefore, in UPPRESSO the prevention against the RP-based identity linkage is expressed as follows.}

\vspace{1mm}
\noindent\textcolor{blue}{\textbf{Privacy against Colluding RPs.}~~Provided that $u$ and $r$ are kept unknown to RPs,
based on the collected information of login instances by $v$ users,
$c$ colluding RPs cannot decide whether a login instance to another RP is initiated by one of these $v$ users or not,
    where
    the collected login instances are denoted as $\mathfrak{L}=\left\{ \begin{matrix}
L_{1,1}, & L_{1,2}, & \cdots, & L_{1,c}\\
L_{2,1}, & L_{2,2}, & \cdots, & L_{2,c}\\
\cdots, & \cdots, & \cdots, & \cdots\\
L_{v,1}, & L_{v,2}, & \cdots, & L_{v,c}
\end{matrix}\right\}$, $L_{i, j} = (ID_{RP_j}, t_{i, j}, [ID_{U_i}]{ID_{RP_j}}) = ([r_j]G, t_{i,j}, [u_ir_j]G)$,
    and the login instance to $RP_{c+1}$ is $L'=(ID_{RP_{c+1}}, t', [ID_{U'}]ID_{RP_{c+1}}) = ([r_{c+1}]G, t', [u'r_{c+1}]G)$.}


\vspace{0.75mm}
\noindent\textbf{Proof.}
We prove this privacy property,
 based on the elliptic curve decisional Diffie-Hellman (ECDDH) assumption. %\cite{GoldwasserK16}.
%That is, while there is the login to an RP, for colluded RPs, they cannot decide whether this login and any logins to other RPs are from the same user.
%
Let $\mathbb{E}$ be an elliptic curve,
    and $G$ be a point on $\mathbb{E}$ of order $n$.
For any PPT algorithm $\mathcal{D}$, the probability of distinguishing
 $([x]G$, $[y]G$, $[xy]G)$ and $([x]G$, $[y]G$, $[z]G)$
is negligible,
 where $x$, $y$ and $z$ are integers randomly and independently chosen in $\mathbb{Z}_n$.
Let  ${\rm Pr}\{\}$ denote the probability and
 we define
\begin{align*}
&{\rm Pr}_1 =  {\rm Pr}\{\mathcal{D}(G, [x]G, [y]G, [xy]G)=1\} \\
&{\rm Pr}_2 =  {\rm Pr}\{\mathcal{D}(G, [x]G, [y]G, [z]G)=1\}
\end{align*}
So $\epsilon_{r}(k) = |{\rm Pr}_1 - {\rm Pr}_2|$ becomes negligible as $k$ increases.

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.97\linewidth]{fig/dalgorithm.pdf}
  \caption{The algorithm based on the RP-based identity linkage, to solve the ECDDH problem}
  \label{fig:dalgorithm}
\end{figure}

We define the RP-based identity linkage game $\mathcal{G}_r$:
after receiving $\mathfrak{L}$ and $L'$ from a challenger,
    the adversary outputs the result $s = 1$ if it decides $u' \in \{u_1, u_2, \cdots, u_v\}$ or $s = 0$ if $u'$ is randomly chosen in $\mathbb{Z}_n$.
The adversary's advantage in $\mathcal{G}_r$ is defined as $\mathbf{Adv}_{A}$.
%If the adversary is able to distinguish whether $u' \in \{u_1, u_2, \cdots, u_v\}$ or not,
%    the adversary will have non-negligible advantages in $\mathcal{G}_r$
%        and ${\rm Adv}_A$ is non-negligible.
Then,
\begin{align*}
&{\rm Pr}'_1={\rm Pr}\{\mathcal{G}_r(\mathfrak{L}, L'|ID_{U'} \in \{ID_{U_1}, ID_{U_2}, \cdots, ID_{U_v}\})=1\} \\
&{\rm Pr}'_2={\rm Pr}\{\mathcal{G}_r(\mathfrak{L}, L'|ID_{U'} \in \mathbb{Z}_n)=1\}\\
&{\mathbf{Adv}}_{A}=|{\rm Pr}'_1-{\rm Pr}'_2|
\end{align*}

We design a PPT algorithm $\mathcal{D}^*_r$ based on $\mathcal{G}_r$, shown in Figure \ref{fig:dalgorithm}, to solve the ECDDH problem.
The input is in the form of $(G$, $Q_1=[x]G$, $Q_2=[y]G$, $Q_3=[z]G)$.
On receiving the input, the challenger of $\mathcal{G}_r$ randomly chooses
 $\{u_1, u_2, \cdots, u_v\}$, $\{r_1, r_2, \cdots, r_c\}$, $\{t_{1, 1}, t_{1, 2}, \cdots, t_{v, c}\}$, and $t'$ in $\mathbb{Z}_n$.
Then the challenger constructs $\mathfrak{L}$ and $L'$ as below.
It firstly assigns $L_{i, j} = ([r_j]G, t_{i, j}, [u_ir_j]G)$, %$1\leq i \leq v$ and $1\leq j \leq c$,
    and randomly chooses $d \in [1, v]$ to
 replace $[u_d r_j]G$ with $[r_j]Q_1=[xr_j]G$ for $1\leq j \leq c$.
So $\mathfrak{L}=\left \{ \begin{matrix}
L_{1,1},&L_{1,2},&\cdots,&L_{1,c}\\
L_{2,1},& L_{2,2},&\cdots,&L_{2,c}\\
\cdots,&\cdots,&\cdots,&\cdots\\
([r_{1}]G, t_{d, 1}, [r_{1}]Q_1),&\cdots,&\cdots,&([r_{c}]G, t_{d, c}, [r_{c}]Q_1)\\
\cdots,&\cdots,&\cdots,&\cdots\\
L_{v,1},&L_{v,2},&\cdots,&L_{v,c}
\end{matrix}\right\}$.
%$L=$\{($[r_1]G$, $t_{1, 1}$, $[[u_1][r_1]G$), ($[r_2]G$, $t_{1, 2}$, $[u_1][r_2]G$), $\cdots$, ($[r_{\beta}]G$, $t_{\alpha, \beta}$, $[r_{\beta}]Q_1$), $\cdots$, ($[r_b]G$, $t_{a, b}$, $[u_a][r_b]G$)\}
%
The challenger assigns $L' = (Q_2, t', Q_3) = ([y]G, t', [z/y][y]G)$.
Finally,
    $\mathfrak{L}$ and $L'$ are sent to the adversary,
        and the output $s$ of $\mathcal{G}_r$ is output by the challenger.
According to the above construction of $\mathfrak{L}$ and $L'$,
    $x$ is actually inserted into $\mathfrak{L}$ as $u_d$
    and $z/y$ is assigned to $u'$.
So, if $z = xy$, then $z/y=x$ and $ID_{U'} \in \{ID_{U_1}, ID_{U_2}, \cdots, ID_{U_v}\}$;
    otherwise, $ID_{U'} \in \mathbb{Z}_n$.
Thus,
\begin{align*}
&{\rm Pr}_1={\rm Pr}\{\mathcal{D}^*_r(G, [x]G, [y]G, [xy]G)=1\}={\rm Pr}'_1 \\=&  {\rm Pr}\{\mathcal{G}_r(\mathfrak{L}, L'|ID_{U'} \in \{ID_{U_1}, ID_{U_2}, \cdots, ID_{U_v}\})=1\} \\
&{\rm Pr}_2={\rm Pr}\{\mathcal{D}^*_r(G, [x]G, [y]G, [z]G)=1\} ={\rm Pr}'_2 \\=&  {\rm Pr}\{\mathcal{G}_r(\mathfrak{L}, L'|ID_{U'} \in \mathbb{Z}_n)=1\}\\
&{\mathbf{Adv}}_{A}=|{\rm Pr}'_1-{\rm Pr}'_2|=|{\rm Pr}_1-{\rm Pr}_2|=\epsilon_{r}(k)
\end{align*}

The ECDDH assumption means that in $\mathcal{G}_r$ the adversary does not have advantages,
    i.e., cannot distinguish a user $U'$ chosen from \{${U_1}, {U_2}, \cdots, {U_v}$\}
        or randomly from the universal user set.
%    (indistinguishability of users to colluding RPs).
So the RP-based identity linkage is impossible. $\square$