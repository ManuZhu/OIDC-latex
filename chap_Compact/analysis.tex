\section{Analysis}
\label{sec:analysis}
In this section, we analyze the security and privacy of UPRESSO.

\subsection{Security}
\label{subsec:security}
To prove the security of UPRESSO, we analyze its modifications on OIDC and demonstrate that these modifications never degrade the security of OIDC,
whose security  has been formally analyzed in~\cite{FettKS17}.

UPRESSO only introduces small modifications to OIDC. As analyzed in Section~\ref{subsec:compatible}, UPRESSO doesn't modify the mechanisms (i.e., digital signature and HTTPS) for integrity and confidentiality of the identity proof; but only slightly modify the receiver designation and user identification.
The detailed modifications include: (1) the $ID_{RP}$ and endpoint in the identity proof are replaced with $PID_{RP}$ and one-time endpoint, while the generation of $PID_{RP}$ further introduces  a negotiation process and a modified dynamic registration;
 (2) IdP generates $PID_U$ based on $PID_{RP}$ instead of $ID_{RP}$, (3) RP calculates $Account$ from the changing $PID_U$ instead of an unchanged value.

For the first modification, the use of $PID_{RP}$ and one-time endpoint guarantee the same security as $ID_{RP}$ and RP's endpoint. To prove that, we first analyze the objectives of using $ID_{RP}$ and RP's endpoint in OIDC, then demonstrate that these objectives are also be achieved with the $PID_{RP}$ and one-time endpoint in UPRESSO.
\begin{itemize}
  \item For $ID_{RP}$, OIDC uses it to ensure that identity proof is only valid to the designated correct RP. In OIDC, the correct IdP ensures that one $ID_{RP}$ is only assigned to one RP, and the correct RP only accepts the identity proof which has a same $ID_{RP}$ with the assigned one.
      In UPRESSO, the $PID_{RP}$ is also unique~\footnote{In practice, we only need to ensure all $PID_{RP}$s are different among the unexpired identity proof (the number denoted as $n$). We calculates this probability even when IdP doesn't check the uniqueness of $PID_{RP}$. It is $\prod_{i=0}^{n-1}(1-i/q)$, decreases with $n$. For  a 256-bit $q$, the probability is larger than $1-2^{-183}$, when $n=2^{36}$ which means IdP's throughput is about $2*10^8$ req/s when valid period is 5 minutes.}
       and one $PID_{RP}$ is  only accepted by one correct RP (who has the unique $ID_{RP}$ same as in OIDC), then identity proof bound with a $PID_{RP}$ is only valid to this RP.
      The uniqueness of $PID_{RP}$ is ensured by the correct IdP through the dynamic registration.
      And, one $PID_{RP}$ will only be accepted by one correct RP as
      (1) the correct RP checks that the negotiated $PID_{RP}$ is never used,  based on the dynamic registration result signed by the IdP;
      (2) the negotiating process prevents the adversary from generating a same $PID_{RP}$  in two negotiations with correct entities (either user or RP).
      This is ensured as no one can control the generation of $PID_{RP}={ID_{RP}}^{n_{RP}*n_{u}}$,  an RP  generates $n_{RP}$ before obtaining $n_{u}$, while the user fails to derive $n_{RP}$ from the $Y_{RP}={ID_{RP}}^{n_{RP}}$.


   \item For endpoint, OIDC uses it to ensure that the correct user could send the identity proof only to the designated RP. In OIDC, the correct user obtains the RP's correct endpoint from the IdP who provides the RP's registered endpoint. In UPRESSO, the correct user obtains this correct endpoint from $Cert_{RP}$, which is also generated by the IdP and can never be forged or modified by others due to the digital signature.
\end{itemize}

The second and third modifications change the ways of user identification at an RP, and also introduce no security degradation.
In OIDC, the correct RP uniquely identifies a user based on the identifier from the IdP, who provides a unique and unchanged identifier for a user $ID_U$ at an RP.
In UPRESSO,  the correct RP  computes an unchanged value $Accout = {PID_U}^t = {ID_{RP}}^{ID_U}\ mod\ p$  for a user's multiple logins, as shown in Equation~\ref{equ:AccountNotChanged};
 and one $Accout$ is only assigned to one user at an RP,  as IdP ensures that one $ID_U$ is only assigned to one user.
Moreover, the calculation can never be tampered by the adversary,  as  $PID_U$ is provided by the IdP and protected in the identity proof, while $t$ is stored at the RP itself, and the calculation is performed at the RP.

%CSRF有其他通用防御方案，这里谈不值得。 由于只有307，建议放到related work中
%\vspace{1mm}\noindent\textbf{Protection conducted by user agent.} The design of UPRESSO makes it immune to some existing known attacks~\cite{FettKS16} (e.g., CSRF, 307 Redirect). The Cross-Site Request Forgery (CSRF) attack is  usually exploited by the adversary to perform the identity injection. However, in UPRESSO, the honest user logs  $PID_{RP}$ and one-time endpoint in the session,  and performs the checks before sending the identity proof to the RP's endpoint, which prevents the CSRF attack. The 307 Redirect attacks~\cite{FettKS16} is due to the implementation error at the IdP, i.e. returning the incorrect status code (i.e., 307), which makes the IdP leak the user's credential to the RPs during the redirection. In UPRESSO, the redirection is intercepted by the trusted user agent which removes these sensitive information.

\subsection{Privacy}
\label{subsec:privacy}
In this section, we prove that UPRESSO prevents the IdP-based access tracing and RP-based identity linkage.

\noindent{\textbf{IdP-based access tracing.}}
UPRESSO prevents the IdP-based access tracing, as the curious IdP cannot derive RP's identifying information from one login, nor classify the logins based on which RP is visited.
The detailed proofs are as follows.

The IdP cannot derive RP's identifying information from any login.
UPRESSO prevents the leakage of RP's identifying information (Step 2 in Figure~\ref{fig:OpenID} in OIDC), as the user provides the IdP a random string as the one-time endpoint instead of the RP's exact endpoint, and sends $PID_{RP}$ instead of $ID_{RP}$.
From any $PID_{RP}$, the IdP cannot derive $ID_{RP}$, as the IdP doesn't know $n_U*n_{RP}$ and cannot determine which $ID_{RP}$ corresponds to this $PID_{RP}$.
That is because,
for any $PID_{RP}$, there always exists a $n=n_U*n_{RP}\ mod\ q$ for arbitrary $ID_{RP}$ making $PID_{RP}={ID_{RP}}^n \ mod\ p$.
We prove it in two steps.
First, for one arbitrary $PID_{RP}$ denoted  as $g^{r_1*n_1\ mod\ q}\ mod\ p$ and  an arbitrary  $ID_{RP}=g^{r_2}\ mod\ p$ ($r_2 \neq r_1$),  there always exists a $n_2$ satisfying $r_2*n_2=r_1*n_1\ mod\ q$, as $q$ is a prime.
Second, for arbitrary $n_2$, there always exists two numbers $n_{U2}$ and $n_{RP2}$ satisfying $n_2= n_{U2}*n_{RP2}\ mod\ q$. 
That is because, $q$ is a prime, for one $n_{U2}$, there exists a number $y$ making $n_{U2}*y=1\ mod\ q$, and then exists $n_{RP2}= y*n_2\ mod\ q$ making $n_{U2}*n_{RP2}=n_2\ mod\ q$.

   
%对已分配的ID_{RP}中的每一个值, 需要遍历所有q个value，才能确定其是否能够生成相应的PID_{RP}，这是计算不可信的；而且对于一个PID_{RP}而言，可能有不止一个ID_{RP} 与之对应; 以下是针对乘法子群不同的可能，即不规定生成元的情况。
%As the IdP doesn't know the value $n_U*n_{RP}$, the IdP has to calculate all the ${ID_{RP}}^x\ mod\ p, x\in[1, q-1]$ for each one of the already assigned $ID_{RP}$s, to determine whether this $ID_{RP}$ is a possible one corresponding to the received $PID_{RP}$. This is computational infeasible as $q$ is too large ($q>2^{N-1}$, $N\geq 256$). Moreover, there may be two or even more possible ones which  are indistinguishable to the IdP. For example, if the received $PID_{RP}$ is $g^{7}$ where $g$ is a generator and $q$ is 11, both $g^{2}$ and $g^{3}$ are the possible values for $ID_{RP}$ where the corresponding $n_U*n_{RP}$ are 9 and 6 respectively.

IdP fails to determine whether two or more logins are for a same RP. The only information that can be used for this classification is one-time endpoint and $PID_{RP}$. However, both one-time endpoints and $PID_{RP}$s are independent among the logins, as one-time endpoints are generated by the secure random number generators at the correct users, while $n_{RP}$s and $n_{U}$s are generated by the secure random number generators at the correct RP and user respectively.


\noindent{\textbf{RP-based identity linkage.}}
UPRESSO prevents the RP-based identity linkage, as collusive and malicious RPs cannot derive the user's identifying information (i.e., $ID_U$) from $PID_U$ and $Account$, nor classify the logins based on the visiting user.
The detailed proofs are as follows.

The RPs cannot derive $ID_U$ from any logins. In UPRESSO, the information relating with $ID_U$ obtained by the RPs are only $PID_{U}$ and $Account$. However, the RPs cannot derive $ID_U$ from $PID_U$ and $Account$.
\begin{itemize}
  %
  \item For $PID_U$, it equals to ${PID_{RP}}^{ID_U}\ mod\ p=g^{r*n_U*n_{RP}*ID_U\ mod\ q}\ mod\ p$. And it is computational infeasible to compute $ID_U$ with the known $PID_U$ and $PID_{RP}$, and $r*ID_U$ with the known $PID_U$ and $g$, not matter which value is provided  as $n_{RP}$ which is the only value controlled by the RP.
  \item For $Account$, it equals to ${ID_{RP}}^{ID_U}\ mod\ p=g^{r*ID_U\ mod\ q}\ mod\ p$. And it is also computational infeasible to compute $ID_U$ with the known $Account$ and $ID_{RP}$, or $r*ID_U$ with the known $Account$ and $g$, not matter which value is provided  as $n_{RP}$.
  \item The RPs can obtain no extra information by combining $PID_U$ and $Account$, as $Account= {PID_U}^t\ mod\ p$ while $t$ is already known to the RP.
\end{itemize}
 
The collusive and malicious RPs cannot determine whether two or more logins are initiated by a same user. The only information  that can be used for this
classification is $Account$ and $PID_U$. 
However,  the $Account$ and $PID_U$ cannot be controlled by the RPs, and are independent to RPs.
\begin{itemize}
  \item For $Account$, it equals to ${ID_{RP}}^{ID_U}\ mod\ p=g^{r*ID_U\ mod\ q}\ mod\ p$. Obviously, no value is controlled by the RPs. And a user's $Account$s at different RPs are independent to these RPs, as the unknown $r$s are   random numbers generated by the IdP. 
  \item For $PID_U$, it equals to ${PID_{RP}}^{ID_U}\ mod\ p=g^{r*n_U*n_{RP}*ID_U\ mod\ q}\ mod\ p$. The only value controlled by RPs is $n_{RP}$, however Diffie-Hellman key exchange protocol prevents the malicious RPs from controlling $PID_{RP}$. Therefore, the RPs cannot control $PID_U$. A user's $PID_U$s at different RPs are also independent to these RPs, due to the unknown and random $r$s.
\end{itemize}


%The user can user the Tor network (or similar means) while accessing the RPs to hide her IP address which prevents collusive RPs to classify the users based on IP addresses, even though currently many network providers only provide user the dynamic IP address based on which the user is unable to be classified.


