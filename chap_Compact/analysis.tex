\section{Analysis}
\label{sec:analysis}
In this section, we analyze the security and privacy of UPRESSO.

\subsection{Security}
\label{subsec:security}
To prove the security of UPRESSO, we analyze its modifications on OIDC and demonstrate that these modifications never degrade the security of OIDC,
whose security  has been formally analyzed in~\cite{FettKS17}.

UPRESSO only introduces small modifications to OIDC. As analyzed in Section~\ref{subsec:compatible}, UPRESSO doesn't modify the mechanisms (i.e., digital signature and HTTPS) for integrity and confidentiality of the identity proof; but only slightly modify the receiver designation and user identification.
The detailed modifications include: (1) the $ID_{RP}$ and endpoint in the identity proof are replaced with $PID_{RP}$ and one-time endpoint, while the generation of $PID_{RP}$ further introduces  a negotiation process and a modified dynamic registration;
 (2) IdP generates $PID_U$ based on $PID_{RP}$ instead of $ID_{RP}$, (3) RP calculates $Account$ from the changing $PID_U$ instead of an unchanged value.

For the first modification, the use of $PID_{RP}$ and one-time endpoint guarantee the same security as $ID_{RP}$ and RP's endpoint. To prove that, we first analyze the objectives of using $ID_{RP}$ and RP's endpoint in OIDC, then demonstrate that these objectives are also be achieved with the $PID_{RP}$ and one-time endpoint in UPRESSO.
\begin{itemize}
  \item For $ID_{RP}$, OIDC uses it to ensure that identity proof is only valid to the designated correct RP. In OIDC, the correct IdP ensures that one $ID_{RP}$ is only assigned to one RP, and the correct RP only accepts the identity proof which has a same $ID_{RP}$ with the assigned one.
      In UPRESSO, the $PID_{RP}$ is also unique~\footnote{In practice, we only need to ensure all $PID_{RP}$s are different among the unexpired identity proof (the number denoted as $n$). The  probability is $\prod_{i=0}^{n-1}(1-i/q)$, decreases with $n$. For  a 256-bit $q$, the probability is larger than $1-2^{-183}$ when $n=2^{36}$, which means IdP's throughput is about $2*10^8$ req/s when valid period is 5 minutes.}
       and one $PID_{RP}$ is  only accepted by one correct RP (who has the unique $ID_{RP}$ same as in OIDC), then identity proof bound with a $PID_{RP}$ is only valid to this RP.
      The uniqueness of $PID_{RP}$ is ensured by the correct IdP through the dynamic registration.
      And, one $PID_{RP}$ will only be accepted by one correct RP as
      (1) the correct RP checks that the negotiated $PID_{RP}$ is never used,  based on the dynamic registration result signed by the IdP;
      (2) the negotiating process prevents the adversary from generating a same $PID_{RP}$  in two negotiations with correct entities (either user or RP).
      This is ensured as no one can control the generation of $PID_{RP}={ID_{RP}}^{n_{RP}*n_{u}}$,  an RP  generates $n_{RP}$ before obtaining $n_{u}$, while the user fails to derive $n_{RP}$ from the $Y_{RP}={ID_{RP}}^{n_{RP}}$.


   \item For endpoint, OIDC uses it to ensure that the correct user could send the identity proof only to the designated RP. In OIDC, the correct user obtains the RP's correct endpoint from the IdP who provides the RP's registered endpoint. In UPRESSO, the correct user obtains this correct endpoint from $Cert_{RP}$, which is also generated by the IdP and can never be forged or modified by others due to the digital signature.
\end{itemize}

The second and third modifications change the ways of user identification at an RP, and also introduce no security degradation.
In OIDC, the correct RP uniquely identifies a user based on the identifier from the IdP, who provides a unique and unchanged identifier for a user $ID_U$ at an RP.
In UPRESSO,  the correct RP  computes an unchanged value $Accout = {PID_U}^t = {ID_{RP}}^{ID_U}\ mod\ p$  for a user's multiple logins, as shown in Equation~\ref{equ:AccountNotChanged};
 and the $Accout$ is unique for a user at an RP,  as IdP ensures that one $ID_U$ is only assigned to one user.
Moreover, the calculation can never be tampered by the adversary,  as  $PID_U$ is provided by the IdP and protected in the identity proof, while $t$ is stored at the RP itself, and the calculation is performed at the RP.

%CSRF有其他通用防御方案，这里谈不值得。 由于只有307，建议放到related work中
%\vspace{1mm}\noindent\textbf{Protection conducted by user agent.} The design of UPRESSO makes it immune to some existing known attacks~\cite{FettKS16} (e.g., CSRF, 307 Redirect). The Cross-Site Request Forgery (CSRF) attack is  usually exploited by the adversary to perform the identity injection. However, in UPRESSO, the honest user logs  $PID_{RP}$ and one-time endpoint in the session,  and performs the checks before sending the identity proof to the RP's endpoint, which prevents the CSRF attack. The 307 Redirect attacks~\cite{FettKS16} is due to the implementation error at the IdP, i.e. returning the incorrect status code (i.e., 307), which makes the IdP leak the user's credential to the RPs during the redirection. In UPRESSO, the redirection is intercepted by the trusted user agent which removes these sensitive information.

\subsection{Privacy}
\label{subsec:privacy}
\noindent{\textbf{Curious IdP.}}
In the SSO schemes that do not protect user's privacy form IdP, e.g. OIDC, IdP is able to know the user accessed RP directly from the RP identifier (known as $client id$). However, it fails to obtain the user's accessed RPs directly in UPRESSO. The curious IdP always fails to derive RP's identifying information (i.e., $ID_{RP}$ and correct endpoint) through a single login flow as IdP only receives $PID_{RP}$ and one-time endpoint, and fails to infer the $ID_{RP}$ from $PID_{RP}$ without the  trapdoor $t$
or the RP's endpoint from the independent one-time endpoint.

Moreover, IdP might also try to infer the correlation of RPs in two or more login flows, but fails to classify the accessed RPs for RP's information indirectly. IdP always fails to achieve the relationship between the $PID_{RP}$s as the secure random number generator ensures the random for generating $PID_{RP}$ and the random string for one-time endpoint are independent in multiple login flows. Therefore, curious IdP fails to classify the RPs based on $PID_{RP}$ and one-time endpoint.

\noindent{\textbf{Malicious RP.}}
In the SSO schemes that do not protect user's privacy form collusive RPs, e.g. SPRESSO, collusive RPs are always able to link the same user in multiple RPs through the user identifier (unchanged in different RP) passively. However, these RPs fail to obtain the $ID_U$ directly in UPRESSO.
\begin{itemize}
\item These RPs might try to find out the $ID_U$ presenting the unchanged user identity but fails to infer the user's unique information (e.g., $ID_U$ or other similar ones) in the passive way. The $PID_U$ is the only element received by RP that contains the user's unique information. However, RP fails to infer (1) $ID_U$ (the discrete logarithm) from $PID_U$, due to hardness of solving discrete logarithm; (2) or $g^{ID_U}$ as the $r$ in $ID_{RP}=g^r$ is only known by IdP and never leaked, which prevents the RP from calculating $r^{-1}$ to transfer $Account=ID_{RP}^{ID_U}$ into  $g^{ID_U}$.
\item Collusive RPs might try to find out whether the $Account$s in each RP are belong to one user or not but fail to link the user in the passive way. The analysis can only be performed based on $Account$ and $PID_U$. However, the $Account$ is independent among RPs, as the $ID_{RP}$ chosen by honest IdP is random and unique and the $PID_U$s are  also independent due to the unrelated $PID_{RP}$
\end{itemize}

Moreover, the malicious RPs may attempt to link the user actively by tampering with the provided elements (i.e., $Cert_{RP}$, $Y_{RP}$ and $PID_{RP}$), these RPs still fail to trigger the IdP to generate a same or derivable $PID_U$s in multiple authentication flows.
\begin{itemize}
\item These RPs fail to actively tamper with the messages to make $ID_U$ leaked. IdP fails to lead the $PID_U$ be generated based on the incorrect $ID_{RP}$, as the modification of  $Cert_{RP}$ will make the signature invalid and be found by the user. The malicious RP fails to manipulate  the calculation of $PID_{RP}$ by providing an incorrect $Y_{RP}$ as another element $n_U$ is  controlled by the user. Also, the malicious RP fails to make an incorrect $PID_{RP}$ (e.g., 1)  be used for $PID_U$, as the honest IdP only accepts a primitive root as the $PID_{RP}$ in the dynamic registration. The RP also fails to change the accepted $PID_{RP}$ in Step 2.3 in Figure~\ref{fig:process}, as the user checks it with the cached one.
\item Collusive RPs also might lead IdP to generate the $PID_U$s same or  derivable into same $Account$ in each RP. Since the $PID_U$ is generated related with the $PID_{RP}$, corrupted RPs might choose the related $n_{RP}$ to correlate their $PID_{RP}$, however, the $PID_{RP}$ is also generated with the participation of $n_{U}$, so that RP does not have the ability to control the generation of $PID_{RP}$. Moreover, corrupted RPs might choose the same $ID_{RP}$ to lead the IdP to generate the $PID_U$ derivable into same $Account$, however, $ID_{RP}$ is verified by the user with through the $Cert_{RP}$, where the tampered $ID_{RP}$ is not acceptable to the honest user.
\end{itemize}

The user can user the Tor network (or similar means) while accessing the RPs to hide her IP address
which prevents collusive RPs to classify the users based on IP addresses, even though currently many network providers only provide user the dynamic IP address based on which the user is unable to be classified.


