\section{Analysis}
\label{sec:analysis}
Here, we analyze the security and privacy of UPPRESSO.

\subsection{Security}
\label{subsec:security}
We prove that the basic requirements of SSO system, i.e., user identification, RP designation, integrity and confidentiality,  are still satisfied in UPPRESSO with the modifications on OIDC, whose security  has been formally analyzed in~\cite{FettKS17}.
In the following, we analyze the affects of the modifications listed in Section~\ref{subsec:compatible}, respectively.

The first modification may affect the RP designation, as the identity proof is bound with $PID_{RP}$ instead of $ID_{RP}$.
However, in UPPRESSO, $PID_{RP}$ provides the same binding as $ID_{RP}$, which is achieved by the \textbf{transformed RP designation} through $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$  with the protocols in  RP identifier transforming and RP identifier refreshing.
In OIDC, $ID_{RP}$ is used to ensure that  identity proof is only valid to the designated RP, as the correct IdP ensures that one $ID_{RP}$ is only assigned to one RP, and the correct RP only accepts the identity proof which has a same $ID_{RP}$ with the assigned one.
In UPPRESSO, the $PID_{RP}$ is also unique
and one $PID_{RP}$ is  only assigned to one RP when at least a correct user or correct RP exists, then identity proof bound with a $PID_{RP}$ is only valid to this RP. The detailed proofs are:
\begin{itemize} %correct beliving
  \item The correct IdP ensures the the uniqueness of $PID_{RP}$, while the correct user checks this uniqueness through the RP identifier refreshing directly, and the correct RP checks it based on the user-redirected RP identifier refreshing result, which is signed by the IdP.
  \item The correct user and RP check the freshness of $PID_{RP}$ based on the nonce $N_{RP}$ and $N_U$ respectively,
   which avoids the replay attack by reusing the unique $PID_{RP}$ incorrectly.
   %文字加上 用户、RP、用户和RP合谋能够进行。 a malicious RP may control by itself or acting as a user of beliving RP. These two cannot succeed
  \item The collusive RPs and users cannot make one specified (e.g., duplicated) $PID_{RP}$ be generated in the negotiation with a correct user or RP.
  For example,  the malicious RP may attempt to misuse the received identity proof at another RP by acting as a user to negotiate a same $PID_{RP}$ with this target RP.
  However, this is prevented and the adversary cannot control the values of $PID_{RP}$ due to the cooperated function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and the protocol in RP identifier transforming.
  The RP chooses $N_{RP}$ before obtaining $N_{U}$ and cannot change $N_{RP}$ after receiving $N_U$, while the user calculates $PID_{RP}$ by ${Y_{RP}}^N_{u} \bmod p$ and  cannot to derive $N_{RP}$ from the $Y_{RP}$.
  As $PID_{RP}$ is calculated based on two random numbers $N_{U}$ and $N_{RP}$, a same $PID_{RP}$ may indeed be generated in two negotiations,
   however the probability is $1/q$ ($\leqslant 2^{-255}$ when $L=256$), which is negligible.
\end{itemize}

%endpoint
The second modification makes the user obtain one-time endpoint instead of RP's correct endpoint from the IdP, and may affect the transmission of identity proof between the user and RP.
In UPPRESSO, $Cert_{RP}$ is introduced to ensure that the correct user sends the identity proof only to the correct endpoint of the designated RP.
In OIDC, the endpoint is used to ensure that the correct user sends the identity proof only to the designated RP, while the correct mapping between the endpoint and $ID_{RP}$ is ensured by the IdP.
In UPPRESSO, the correct user obtains the correct endpoint for $ID_{RP}$ from $Cert_{RP}$. While,  $Cert_{RP}$ is generated by the IdP to bind RP's endpoint with the $ID_{RP}$, and can never be forged or modified by others due to the digital signature.

The last two modifications affect user identification, which is still ensured in UPPRESSO by the \textbf{trapdoor user identification} provided by $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$.
In OIDC, the RP uniquely identifies a user based on the identifier from the IdP, who provides a unique and identical identifier for a user $ID_U$ at an RP.
In UPPRESSO,  the correct RP  computes an identical value $Accout = {PID_U}^T = {ID_{RP}}^{ID_U} \bmod p$  for a user's multiple logins, as shown in Equation~\ref{equ:AccountNotChanged};
 and one $Accout$ is only assigned to one user at an RP,  as IdP ensures that one $ID_U$ is only assigned to one user.
Moreover, the calculation can never be tampered by the adversary,  as  $PID_U$ is provided by the IdP and protected in the identity proof, while $T$ is stored at the RP itself, and the calculation is performed at the RP.

The above analysis demonstrates that (1) integrity and confidentiality are not affected by the modifications in UPPRESSO and could be  guaranteed by the mechanisms (i.e., digital signature and TLS) inherited from OIDC; and (2) these modifications on OIDC introduce no security degradation on user identification and RP designation.
Therefore, UPPRESSO provides the secure SSO service.

%CSRF有其他通用防御方案，这里谈不值得。 由于只有307，建议放到related work中
%\vspace{1mm}\noindent\textbf{Protection conducted by user agent.} The design of UPPRESSO makes it immune to some existing known attacks~\cite{FettKS16} (e.g., CSRF, 307 Redirect). The Cross-Site Request Forgery (CSRF) attack is  usually exploited by the adversary to perform the identity injection. However, in UPPRESSO, the honest user logs  $PID_{RP}$ and one-time endpoint in the session,  and performs the checks before sending the identity proof to the RP's endpoint, which prevents the CSRF attack. The 307 Redirect attacks~\cite{FettKS16} is due to the implementation error at the IdP, i.e. returning the incorrect status code (i.e., 307), which makes the IdP leak the user's credential to the RPs during the redirection. In UPPRESSO, the redirection is intercepted by the trusted user agent which removes these sensitive information.

\subsection{Privacy}
\label{subsec:privacy}
In this section, we prove that UPPRESSO prevents the IdP-based visit tracing and RP-based identity linkage.

\noindent{\textbf{IdP-based visit tracing prevention.}}
UPPRESSO prevents the IdP-based visit tracing, the curious IdP cannot derive RP's identifying information from one login, nor associate the logins based on which RP is visited.
The detailed proofs are as follows.

\emph{The IdP cannot derive RP's identifying information from any login.}
UPPRESSO prevents the leakage of RP's identifying information (Step 2 in Figure~\ref{fig:OpenID} in OIDC), as the user provides the IdP a random string as the one-time endpoint instead of the RP's exact endpoint, and sends $PID_{RP}$ instead of $ID_{RP}$.
\emph{From any $PID_{RP}$, the IdP cannot derive $ID_{RP}$}, as the IdP doesn't know $N_UN_{RP}$ and cannot determine which $ID_{RP}$ corresponds to this $PID_{RP}$.
That is because,
for any given $PID_{RP}$, all the already-assigned $ID_{RP}$s could be the one corresponding to it,
as for arbitrary $ID_{RP}$ there always exists $N_U$ and $N_{RP}$  making $PID_{RP}={ID_{RP}}^{N_UN_{RP} \bmod q} \bmod p$.
We prove it in two steps.
\begin{itemize}
  \item First, for an arbitrary $PID_{RP}$ (denoted  as $g^{r_1*N_1\ mod\ q}\ mod\ p$, $N_1=N_{U1}*N_{RP1}\ mod\ q$) and  an arbitrary  $ID_{RP}$ (denoted as $g^{r_2}\ mod\ p$, $r_2 \neq r_1$),  there always exists $N_2$ satisfying $r_2*N_2=r_1*N_1\ mod\ q$. That's because $q$ is a prime and co-prime to any $r_2$, then there always exists $N_2^{'}$ making $r_2*N_2^{'}=1\ mod\ q$, and $N_2=(r_1*N_1)*N_2^{'}\ mod\ q$ making the equality hold.
  \item Second, for the derived $N_2$, there always exists two numbers $N_{U2}$ and $N_{RP2}$ satisfying $N_2= N_{U2}*N_{RP2}\ mod\ q$.
That's because, $q$ is a prime and co-prime to any chosen $N_{U2}$, there always exists a number $N_{RP2}^{'}$ making $N_{U2}*N_{RP2}^{'}=1\ mod\ q$, and then exists $N_{RP2}= N_{RP2}^{'}*N_2\ mod\ q$ making $N_{U2}*N_{RP2}=N_2\ mod\ q$.
\end{itemize}


%对已分配的ID_{RP}中的每一个值, 需要遍历所有q个value，才能确定其是否能够生成相应的PID_{RP}，这是计算不可信的；而且对于一个PID_{RP}而言，可能有不止一个ID_{RP} 与之对应; 以下是针对乘法子群不同的可能，即不规定生成元的情况。
%As the IdP doesn't know the value $n_U*n_{RP}$, the IdP has to calculate all the ${ID_{RP}}^x\ mod\ p, x\in[1, q-1]$ for each one of the already assigned $ID_{RP}$s, to determine whether this $ID_{RP}$ is a possible one corresponding to the received $PID_{RP}$. This is computational infeasible as $q$ is too large ($q>2^{N-1}$, $N\geq 256$). Moreover, there may be two or even more possible ones which  are indistinguishable to the IdP. For example, if the received $PID_{RP}$ is $g^{7}$ where $g$ is a generator and $q$ is 11, both $g^{2}$ and $g^{3}$ are the possible values for $ID_{RP}$ where the corresponding $n_U*n_{RP}$ are 9 and 6 respectively.

\emph{IdP cannot to determine whether two or more logins are for a same RP.} The only information that can be used for this classification is one-time endpoint and $PID_{RP}$. However, both one-time endpoints and $PID_{RP}$s are independent among the logins, guaranteed by the secure random number generators that used to generate one-time endpoints and $N_{U}$s at the correct user, and $N_{RP}$s at the correct RPs.

\noindent{\textbf{RP-based identity linkage prevention.}}
UPPRESSO prevents the RP-based identity linkage, any malicious RPs cannot derive the user's identifying information (i.e., $ID_U$) from $PID_U$ and $Account$, nor associate a user's logins at different RPs.
The detailed proofs are as follows.

%one RP:   直接从PIDu->IDu, Account->IDu, PIDu&Account -> IDu,
\emph{Any RP cannot derive $ID_U$ from $PID_U$ and $Account$ in one login directly}, due to the one-way function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$.
\begin{itemize}
  \item For $PID_U$, it equals to ${PID_{RP}}^{ID_U}\ mod\ p$ according to $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, and further transformed to $g^{r*N_U*N_{RP}*ID_U\ mod\ q}\ mod\ p$ by combining $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ with Equation~\ref{equ:IDRP}.
      Here, $p$, $q$ and $g$ are public parameters, $PID_{RP}$, $N_{RP}$ and $N_U$ are known to the RP, while $r$ is secretly maintained by the IdP and never leaked to the RP.
      Then, it is computational infeasible to compute $ID_U$ from $PID_U$ with all the known values (e.g., $PID_{RP}$, $g$ and etc.) due to the discrete logarithm problem.
  \item For $Account$, it equals to ${ID_{RP}}^{ID_U}\ mod\ p$ according to Equation~\ref{equ:AccountNotChanged}, and further transformed to $g^{r*ID_U\ mod\ q}\ mod\ p$ with Equation~\ref{equ:IDRP}. Same as the above analysis, it is also computational infeasible to compute $ID_U$ from $Account$ with all the known values (e.g., $ID_{RP}$, $g$ and etc.).
  \item The RP cannot infer $ID_U$ by combining $Account$ and $PID_U$.
        $Account$ and $PID_U$ are both generated from $ID_U$, however $Accout={PID_U}^T\ mod\ p$ where $T$ is a random value known to RP and independent with $ID_U$.
\end{itemize}

%one RP 多个login中的PIDu-> IDu, 多个login中的Account->IDu
\emph{Any RP cannot directly derive $ID_U$ from $PID_U$s and $Account$s obtained in multiple logins.} All these $Account$s are equal,  while any $PID_{U}$ (e.g., $PID_{U1}$) can be computed from any other $PID_{U}$ (e.g., $PID_{U2}$),  $PID_{U1}$=$PID_{U2} * Account^{N_{U1}*N_{RP1}-N_{U2}*N_{RP2}}\ mod\ p$, where $N_{U2}$, $N_{RP2}$, $N_{U2}$ and $N_{RP2}$ are values known to the RP and independent with $ID_U$.

%two or more RPs 合谋， 不提供错误值
\emph{The collusive RPs cannot directly associate  a user's $Account$s and $PID_U$s.} The collusive RPs may attempt to link a user's accounts  by checking whether the equality $Account_2$=$(Account_1)^{r_2/r_1}\ mod\ p$ holds for $Account_1$ at an RP $ID\_{RP1}\ =\ g^{r_1}\ mod\ p$ and $Account_2$ at another RP $ID\_{RP2}\ =\ g^{r_2}\ mod\ p$.
But, the associating always fails, as RPs cannot derive $r$ (and therefore ${r_2/r_1}$) from $ID_{RP}$ due to the discrete logarithm problem.
The collusive RPs cannot associate a user's  $PID_U$s either, due to the unknown $r$s.


%一个RP在一个login中提供错误的N_{RP}，来直接推导ID_U
%一个RP在多个login中提供错误的N_{RP}，来直接推导ID_U （提供错误值）
%Two or more RPs合作关联 ID_U，（提供错误值）
%尽管不直接推导，Two or more RPs 合作associate user login （提供错误值、不提供错误值） provide an incorrect $N_{RP}$ in $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$
%Now, we consider malicious RPs.
\emph{Any malicious RP cannot derive $ID_U$ and collusive RPs cannot correlate $PID_U$s ($Account$s), by manipulating $N_{RP}$s.}
A malicious RP may attempt to manipulate $N_{RP}$s in one or multiple logins to make the generated $PID_U$s or $Account$s be vulnerable for deriving $ID_U$,
 and the collusive RPs may attempt to manipulate $N_{RP}$s cooperatively to make a user's $PID_U$s or $Account$s be correlated at these RPs and then to associate a user's multiple logins.
Here, $N_{RP}$s are the only values controlled by the RPs.
However, the manipulation on $N_{RP}$ is masked by $N_U$ in $PID_U$ due to cooperative function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$,
 and has no effect on $Account$ as shown in Equation~\ref{equ:AccountNotChanged}.
\begin{itemize}
  \item For $PID_U$, it equals to ${PID_{RP}}^{ID_U}\ mod\ p$ and $g^{r*N_U*N_{RP}*ID_U\ mod\ q}\ mod\ p$. The RP cannot control $PID_{RP}$ as it generates $N_{RP}$ before obtaining $N_U$ and cannot change $N_{RP}$ after obtaining $N_U$. The random and independent $N_U$ prevents the RPs from controlling $PID_U$.
  \item For $Account$, it equals to ${ID_{RP}}^{ID_U}\ mod\ p$ and $g^{r*ID_U\ mod\ q}\ mod\ p$. Obviously, $Account$ is independent with $N_{RP}$ and cannot be controlled by any RP.
\end{itemize}

%和恶意用户合谋，但是仅仅是被动攻击。
%victim user Account_v1 = ID_RP1^ID_Uv at RP1, malicious user Account_m1=ID_{RP1}^ID_Um
%victim user Account_v2 = ID_RP2^ID_Uv at RP2, malicious user Account_m2=ID_{RP2}^ID_Um
\emph{The collusive RPs and users cannot associate the victim user.}
The RPs may collude with  the users and attempt to associate a victim user's $Account$s  at the different RPs based on the relation among the $Account$s of the malicious user and victim user.
For example, at $ID_{RP1}$ and $ID_{RP2}$, the victim user's accounts are $Account_{v1}$ and $Account_{v2}$, while the malicious user's ones are $Account_{m1}$ and $Account_{m2}$, then the adversary may attempt to find whether exists a value $ID_{\Delta}$ satisfying both $Account_{m1}/Account_{v1}={ID_{RP1}}^{ID_{\Delta}}\ mod\ p$ and $Account_{m2}/Account_{v2}={ID_{RP2}}^{ID_{\Delta}}\ mod\ p$.
However, as $ID_U$s are independent while $ID_U$ is only known to the IdP and the corresponding user,
the adversary cannot derive the victim user's $ID_U$ (and then $ID_{\Delta}$) for this association.

%和恶意用户合谋，主动攻击
\emph{The malicious RPs and users cannot associate the victim user by manipulating $N_{RP}$s or $N_{U}$s}.
The malicious RPs may manipulate $N_{RP}$s while the colluded users may manipulate $N_{U}$s, attempting to link the victim user's logins at different RPs.
However, same as the above analysis, malicious RPs cannot control the victim user's $PID_U$s and $Account$s due to the independent $N_U$s from the victim user.


%The user can user the Tor network (or similar means) while accessing the RPs to hide her IP address which prevents collusive RPs to classify the users based on IP addresses, even though currently many network providers only provide user the dynamic IP address based on which the user is unable to be classified.


%temp backup
\begin{comment}
UPPRESSO only introduces small modifications to OIDC. As analyzed in Section~\ref{subsec:compatible}, UPPRESSO doesn't modify the mechanisms (i.e., digital signature and HTTPS) for integrity and confidentiality of the identity proof; but only slightly modify the RP designation and user identification.
The detailed modifications include: (1) the $ID_{RP}$ and endpoint in the identity proof are replaced with $PID_{RP}$ and one-time endpoint, while the generation of $PID_{RP}$ further introduces  a negotiation process and a modified dynamic registration;
 (2) IdP generates $PID_U$ based on $PID_{RP}$ instead of $ID_{RP}$, (3) RP calculates $Account$ from the changing $PID_U$ instead of an unchanged value.

For the first modification, the use of $PID_{RP}$ and one-time endpoint guarantee the same security as $ID_{RP}$ and RP's endpoint. To prove that, we first analyze the objectives of using $ID_{RP}$ and RP's endpoint in OIDC, then demonstrate that these objectives are also be achieved with the $PID_{RP}$ and one-time endpoint in UPPRESSO.
\begin{itemize}
  \item For $ID_{RP}$, OIDC uses it to ensure that identity proof is only valid to the designated correct RP. In OIDC, the correct IdP ensures that one $ID_{RP}$ is only assigned to one RP, and the correct RP only accepts the identity proof which has a same $ID_{RP}$ with the assigned one.
      In UPPRESSO, the $PID_{RP}$ is also unique~\footnote{In practice, we only need to ensure all $PID_{RP}$s are different among the unexpired identity proof (the number denoted as $n$). We calculates this probability even when IdP doesn't check the uniqueness of $PID_{RP}$. It is $\prod_{i=0}^{n-1}(1-i/q)$, decreases with $n$. For  a 256-bit $q$, the probability is larger than $1-2^{-183}$, when $n=2^{36}$ which means IdP's throughput is about $2*10^8$ req/s when valid period is 5 minutes.}
       and one $PID_{RP}$ is  only accepted by one correct RP (who has the unique $ID_{RP}$ same as in OIDC), then identity proof bound with a $PID_{RP}$ is only valid to this RP.
      The uniqueness of $PID_{RP}$ is ensured by the correct IdP through the dynamic registration.
      And, one $PID_{RP}$ will only be accepted by one correct RP as
      (1) the correct RP checks that the negotiated $PID_{RP}$ is never used,  based on the dynamic registration result signed by the IdP;
      (2) the negotiating process prevents the adversary from generating a same $PID_{RP}$  in two negotiations with correct entities (either user or RP).
      This is ensured as no one can control the generation of $PID_{RP}={ID_{RP}}^{N_{RP}*N_{u}}$,  an RP  generates $N_{RP}$ before obtaining $N_{U}$, while the user fails to derive $N_{RP}$ from the $Y_{RP}={ID_{RP}}^{N_{RP}}$.


   \item For endpoint, OIDC uses it to ensure that the correct user could send the identity proof only to the designated RP. In OIDC, the correct user obtains the RP's correct endpoint from the IdP who provides the RP's registered endpoint. In UPPRESSO, the correct user obtains this correct endpoint from $Cert_{RP}$, which is also generated by the IdP and can never be forged or modified by others due to the digital signature.
\end{itemize}

The second and third modifications change the ways of user identification at an RP, and also introduce no security degradation.
In OIDC, the correct RP uniquely identifies a user based on the identifier from the IdP, who provides a unique and unchanged identifier for a user $ID_U$ at an RP.
In UPPRESSO,  the correct RP  computes an unchanged value $Accout = {PID_U}^t\ mod\ p = {ID_{RP}}^{ID_U}\ mod\ p$  for a user's multiple logins, as shown in Equation~\ref{equ:AccountNotChanged};
 and one $Accout$ is only assigned to one user at an RP,  as IdP ensures that one $ID_U$ is only assigned to one user.
Moreover, the calculation can never be tampered by the adversary,  as  $PID_U$ is provided by the IdP and protected in the identity proof, while $t$ is stored at the RP itself, and the calculation is performed at the RP.


\noindent{\textbf{RP-based identity linkage.}}
UPPRESSO prevents the RP-based identity linkage, as collusive and malicious RPs cannot derive the user's identifying information (i.e., $ID_U$) from $PID_U$ and $Account$, nor classify the logins based on the visiting user.
The detailed proofs are as follows.

The RPs cannot derive $ID_U$ from any logins. In UPPRESSO, the information relating with $ID_U$ obtained by the RPs are only $PID_{U}$ and $Account$. However, the RPs cannot derive $ID_U$ from $PID_U$ and $Account$.

\begin{itemize}
  \item For $PID_U$, it equals to ${PID_{RP}}^{ID_U}\ mod\ p$ and $g^{r*N_U*N_{RP}*ID_U\ mod\ q}\ mod\ p$. And it is computational infeasible to compute $ID_U$ with the known $PID_U$ and $PID_{RP}$, and $r*ID_U$ with the known $PID_U$ and $g$, not matter which value is provided  as $N_{RP}$ which is the only value controlled by the RP.
  \item For $Account$, it equals to ${ID_{RP}}^{ID_U}\ mod\ p$ and $g^{r*ID_U\ mod\ q}\ mod\ p$. And it is also computational infeasible to compute $ID_U$ with the known $Account$ and $ID_{RP}$, or $r*ID_U$ with the known $Account$ and $g$, not matter which value is provided  as $N_{RP}$.
  \item While $Accont$ and $PID_U$ are generated from $ID_U$, however $Accout={PID_U}^t\ mod\ p$, $t$ is a random number, and independent with $ID_U$.
\end{itemize}

The collusive RPs cannot determine whether two or more logins are initiated by a same user. The only information  that can be used for this
classification is $Account$ and $PID_U$.
However,  the $Account$ and $PID_U$ cannot be controlled by the RPs, and are independent to RPs.
\begin{itemize}
  \item For $Account$, it equals to ${ID_{RP}}^{ID_U}\ mod\ p=g^{r*ID_U\ mod\ q}\ mod\ p$. Obviously, no value is controlled by the RPs. And a user's $Account$s at different RPs are independent to these RPs, as the unknown $r$s are   random numbers generated by the IdP.
  \item For $PID_U$, it equals to ${PID_{RP}}^{ID_U}\ mod\ p=g^{r*N_U*N_{RP}*ID_U\ mod\ q}\ mod\ p$. The only value controlled by RPs is $N_{RP}$, however Diffie-Hellman key exchange protocol prevents the malicious RPs from controlling $PID_{RP}$. Therefore, the RPs cannot control $PID_U$. A user's $PID_U$s at different RPs are also independent to these RPs, due to the unknown and random $r$s.
\end{itemize}
\end{comment}
