
\begin{appendices}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\newcommand{\deflet}{\textbf{let}}
\newcommand{\mystate}[1]{\STATE \textbf{let} {{}#1}}
\newcommand{\mystop}[1]{\STATE \textbf{stop} \myss{\myangle{{{}#1}}, s'}}
\newcommand{\myss}[1]{${{}#1}$}
\newcommand{\myangle}[1]{\langle {{}#1} \rangle}
\newcommand{\myif}[1]{\IF{\myss{{{}#1}}}}
\newcommand{\myelse}[1]{\ELSIF{\myss{{{}#1}}}}

\newcommand{\SWITCH}[1]{\STATE \textbf{switch} #1\ \textbf{do} \begin{ALC@g}}
\newcommand{\ENDSWITCH}{\end{ALC@g}\STATE \textbf{end switch}}
\newcommand{\CASE}[1]{\STATE \textbf{case} #1\textbf{:} \begin{ALC@g}}
\newcommand{\ENDCASE}{\end{ALC@g}}
\newcommand{\CASELINE}[1]{\STATE \textbf{case} #1\textbf{:} }
\newcommand{\DEFAULT}{\STATE \textbf{default:} \begin{ALC@g}}
\newcommand{\ENDDEFAULT}{\end{ALC@g}}
\newcommand{\DEFAULTLINE}[1]{\STATE \textbf{default:} }

\section{Web Model}
\subsection{Data Formate}
Here we provide the details of formate of some messages we use to construct the UPPRESSO model.

\vspace{1mm}\noindent\textbf{HTTP Messages}.
An HTTP request message is the term of the form 
\begin{equation*}
\myangle{\mathtt{HTTPReq}, nonce, method, host, path, parameters, headers, body}
\end{equation*}
, and an HTTP response message is the term of the form 
\begin{equation*}
    \myangle{\mathtt{HTTPResp}, nonce, status, headers, body}
\end{equation*}
 The details are dined as follows:
 \begin{itemize}
 \item \myss{\mathtt{HTTPReq}} and \myss{\mathtt{HTTPResp}} are the type of messages.
 \item \myss{nonce} is the constant nonce mapping the response with the specific request.
 \item \myss{method} is the HTTP method, such as \myss{\mathtt{GET}} and \myss{\mathtt{POST}}.
 \item \myss{host} is the constant string domain of visited server.
 \item \myss{path} is the constant string representing the concrete resource of the server.
 \item \myss{parameters} contains the parameters carried by the url as the form \myss{\myangle{\myangle{name, value}, \myangle{name, value}, \dotsc}}, , for example the \myss{parameters} HTTP request sent to the url \myss{http://www.example.com?type=confirm}  is \myss{\myangle{\myangle{type, confirm}}}.
 \item \myss{headers} is the header content of each HTTP messages as the form \myss{\myangle{\myangle{name, value}, \myangle{name, value}, \dotsc}}, such as \myss{\myangle{\myangle{Referer, http://www.example.com}, \myangle{Cookies, c}}}.
 \item \myss{body} is the body content carried by HTTP \myss{\mathtt{POST}} request or HTTP response in the form \myss{\myangle{\myangle{name, value}, \myangle{name, value}, \dotsc}}.
  \item \myss{status} is the HTTP status code defined by HTTP standard.
 \end{itemize}
 
\vspace{1mm}\noindent\textbf{URL}.
A URL is a term \myss{\myangle{\mathtt{URL}, protocol,host,path,parameters}}, where \myss{\mathtt{URL}} is the type, \myss{protocol} is chosen in {\myss{\mathtt{S}}, \myss{\mathtt{P}}} as \myss{\mathtt{S}} stands for HTTPS and \myss{\mathtt{P}} stands for HTTP. The \myss{host, path, and parameters} are same as in HTTP message. 

\vspace{1mm}\noindent\textbf{Origin}. 
An Origin is a term \myss{\myangle{host, protocol}} that stands for the specific domain used by the HTTP CORS policy, where \myss{host} and \myss{protocol} are defined as same as in URL.

\vspace{1mm}\noindent\textbf{POSTMESSAGE}.
PostMessage is used in the browser for transmitting messages between scripts from different origins. We define the postMessage as the form \myss{\myangle{\mathtt{POSTMESSAGE}, target, Content, Origin}}, where \myss{\mathtt{POSTMESSAGE}} is the type, \myss{target} is the constant nonce which stands the for the receiver, \myss{Content} is the message transmitted and Origin is restricts the receiver's origin.

\vspace{1mm}\noindent\textbf{XMLHTTPREQUEST}. 
XMLHTTPRequest is the HTTP message transmitted  by scripts in the browser. That is the XMLHTTPRequest is converted with the HTTP message by the browser. The XMLHTTPRequest in the form \myss{\myangle{\mathtt{XMLHTTPREQUEST}, URL, methods, Body, nonce}} can be converted into HTTP request message by the browser,and \myss{\myangle{\mathtt{XMLHTTPREQUEST}, Body, nonce}}  is converted from HTTP response message.

\vspace{1mm}\noindent\textbf{Data Operation}. 
The data used in UPPRESSO are defined in the following forms:
\begin{itemize}
\item \textbf{Standardized Data} is the data in the fixed format, for instance the HTTP request is the standardized data in the form \myss{\myangle{\mathtt{HTTPReq}, nonce, method, host, path, parameters, headers, body}}.  We assume there is an HTTP request \myss{r := \myangle{\mathtt{HTTPReq}, n, \mathtt{GET}, example.com, /path, \myangle{}, \myangle{}, \myangle{}}}, here we define the operation on the $r$. That is the elements in $r$ can be accessed in the form \myss{r.name}, such that \myss{r.method \equiv \mathtt{GET}},  \myss{r.path \equiv /path} and \myss{r.body \equiv \myangle{}}. 
\item \textbf{Dictionary Data} is the data in the form \myss{\myangle{\myangle{name, value}, \myangle{name, value}, \dotsc}}, for instance the \myss{body} in HTTP request is dictionary data. We assume there is a \myss{body := \myangle{\myangle{username, alice}, \myangle{password, 123}}}, here we define the operation on the $body$. That is we can access the elements in \myss{body} in the form \myss{body[name]}, such that \myss{body[username] \equiv alice} and \myss{body[password] \equiv 123}. We can also add the new attributes to the dictionary, for example after we set \myss{body[age] := 18}, the \myss{body} are changed into\myss{ \myangle{\myangle{username, alice}, \myangle{password, 123}, \myangle{age, 18}}}.
\end{itemize}

\vspace{1mm}\noindent\textbf{Patten Matching}.  We define the term with the variable $\star$ as the pattern, such as \myss{\myangle{a, b, \star}}. That is the pattern matches any terms which is in the same form of the pattern but replacing the $\star$ with other terms. For instance,  \myss{\myangle{a, b, \star}} matches \myss{\myangle{a, b, c}}.

\subsection{Browser Model}
As we consider that  the browsers are honest in UPPRESSO model, therefore, we only focus on how the browsers interactive with the scripts. 

We firstly introduce the windows and documents of the browser model.

\vspace{1mm}\noindent\textbf{Window}. A window \myss{w} is a term of the form \myss{w = \myangle{nonce, documents, opener}}, representing the  the concrete browser window in the system. The \myss{nonce} is the window reference to identify each windows. The \myss{documents} is the set of documents (defined below) including the current document and cached documents (for example, the documents can be viewed via the "forward" and "back" buttons in the browser). The \myss{opener} represents the widow is created in which document, for instance, while a user clicks the href in document \myss{d} and it creates a new window \myss{w}, there is \myss{w.opener \equiv d.nonce}. 

\vspace{1mm}\noindent\textbf{Document}. A document \myss{d} is a term of the form
\begin{equation*}
  \myangle{nonce, location, referrer, script, scriptstate, scriptinputs, subwindows, active}
\end{equation*} 
where document is the HTML content in the window.  The \myss{nonce} is to locate the document. \myss{Location} is the URL where the document is loaded. \myss{Referrer} is same as the Referer header defined in HTTP standard. \myss{script} is the scripting process downloaded from each servers. \myss{scriptstate} is define by the script, different in each scripts.  \myss{scriptinputs} is the message transmitted into the scripting process. \myss{subwindows} is the set of \myss{nonce} of document's created windows. \myss{active} represents whether this document is active or not.

A scripting process is the dependent process relying on the browser, which can be considered as a relation \myss{R} mapping a message input and a message output. And finally the browser will conduct the command in the output message. Here we give the description of the form of input and output. 
\begin{itemize}
\item \textbf{Scripting Message Input. } The input is the term in the form
\begin{equation*}
\myangle{tree, docnonce, scriptstate, stateinputs,cookies,localStorage, sessionStorage, ids, secret}
\end{equation*}
\item \textbf{Scripting Message Output. }The output is the term in the form
\begin{equation*}
\myangle{scriptstate, cookies, localStorage, sessionStorage, command}
\end{equation*}
\end{itemize}
The \myss{tree} is the relations of the opened windows and documents, which are visible to this script. \myss{Docnonce} is the document nonce. The  \myss{Scriptstate} is a term of the form defined by each script. \myss{Scriptinputs} is the message transmitted to script. However, the \myss{scriptinputs} are defined as standardized forms, for example postMessage is one of the forms of \myss{scriptinputs}. \myss{Cookies} is the set of cookies belong to the document's origin. \myss{LocalStorage} is the storage space for browser and \myss{sessionStorage} is the space for each HTTP sessions.  \myss{Ids} is the set of user IDs while \myss{secret} is the password to corresponding user ID. The \myss{command} is the operation which is to be conducted by the browser. Here we only introduce the form of commands used in UPPRESSO system. We have defined the postMessage and XMLHTTPRequest (for HTTP request) message which are the \myss{commands}. Moreover, a term in the form \myss{\myangle{\mathtt{IFRAME}, URL, WindowNonce}} asks the browser to create this document's subwindow and it visits the server with the URL.



\subsection{Model Of UPPRESSO}
In this section, we will introduce the model of processes in UPPRESSO system, containing IdP server process, RP server process, IdP scripting process and RP scripting process. We will focus on the state form and relation $R$. They can describe that what kind of event can be accepted by the process in each states, and the content of new output events and states.
\subsection{IdP Server Process}
The state of IdP server process is a term in the form \myss{\myangle{ID, p, SignKey, sessions, users, RPs, Validity, Tokens}}. Other data stored at IdP but not used during SSO authentication are not mentioned here.
\begin{itemize}
\item \myss{ID} is the identifier of IdP.
\item \myss{p} is the large prime mentioned before.
\item \myss{SignKey} is the private key used by IdP to generate signatures.
\item \myss{sessions} is the term in the form of \myss{\myangle{\myangle{Cookie, session}}}, the Cookie uniquely identify the session and sessions store the  browser uploaded message.
\item \myss{users} is the set of user information. And each user informations contains the \myss{username, password, uid}  and other user attributes.
\item \myss{RPs} is the set of RP information which consists of ID of RP \myss{(PID_{RP})}, \myss{Endpoints} the set of RP's validity endpoints and \myss{Validity}. 
\item \myss{Validity} is the validity for IdP generated signatures. 
\item \myss{Tokens} is the set of IdP generated Identity proofs.
\end{itemize}
To make the description clearer, we also provide the \myss{functions} to define the complicated procedure. 
\begin{itemize}
\item \myss{\mathtt{SecretOfID(u)}} is used to search the user \myss{u}'s password.
\item \myss{\mathtt{UIDOfUser(u)}} is used to search the user \myss{u}'s \myss{uid}.
\item \myss{\mathtt{ListOfPID()}} is the set of IDs of registered RP.
\item \myss{\mathtt{EndpointsOfRP(r)}} is the set of endpoints registered by the RP with ID \myss{r}. 
\item \myss{\mathtt{ModPow(a, b, c)}} is the result of \myss{a^b \mod c}.
\item \myss{\mathtt{CurrentTime()}} is the system current time.
\end{itemize}

The relation of IdP process $R^i$ is shown as Algorithm~\ref{alg1}.

\begin{breakablealgorithm}
  \caption{$R^i$}
  \label{alg1}
  \begin{algorithmic}[1]
  \REQUIRE \myss{\myangle{a, f, m}, s}
  \mystate{\myss{s:=s'}}
  \mystate{\myss{n, method, path, parameters, headers, body} \textbf{such that}}\\
  \ \ \myss{\myangle{\mathtt{HTTPReq},n,method,path,parameters,headers,body} \equiv m}\\
  \ \ \textbf{if} \myss{possible}; \textbf{otherwise} stop \myss{\myangle{}, s'}
  \myif{path \equiv /script}
  \mystate{\myss{m':=\myangle{\mathtt{HTTPResp},n,200, \myangle{}, \mathtt{IdPScript}}}}
  \mystop{f, a, m'}
  \myelse{path \equiv /login}   
  \mystate{\myss{cookie := headers[Cookie]}}
  \mystate{\myss{session := s'.sessions[cookie]}}
  \mystate{\myss{username:=body[username]}}
  \mystate{\myss{password:=body[password]}}
  \myif{password \not\equiv \mathtt{SecretOfID}(username)}
  \mystate{\myss{m' :=\myangle{\mathtt{HTTPResp},n,200,\myangle{},\mathtt{LoginFailure}}}}
  \mystop{f,a,m'}
  \ENDIF
  \mystate{\myss{session[uid] := \mathtt{UIDOfUser}(username)}}
  \mystate{\myss{m' :=\myangle{\mathtt{HTTPResp},n,200,\myangle{},\mathtt{LoginSucess}}}}
  \mystop{f,a,m'}
  \myelse{path \equiv /loginInfo}
  \mystate{\myss{cookie := headers[Cookie]}}
  \mystate{\myss{session := s'.sessions[cookie]}}
  \mystate{\myss{username := session[username]}}
  \myif{username \not\equiv \mathtt{null}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp},n,200,\myangle{},\mathtt{Logged}}}}
  \mystop{f,a,m'}
  \ENDIF
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp},n,200,\myangle{},\mathtt{Unlogged}}}}
  \mystop{f,a,m'}
  \myelse{path \equiv /dynamicRegistration}
  \mystate{\myss{PID_{RP} := body[PID_{RP}]}}
 \mystate{\myss{Endpoint := body[Endpoint]}}
  \mystate{\myss{Nonce := body[Nonce]}}
  \myif{PID_{R}P \in \mathtt{ListOfPID()}}
  \mystate{\myss{Content :=\myangle{Fail, PID_{RP}, Nonce}}}
  \mystate{\myss{Sig := \mathtt{Sig}(Content, s'.SignKey)}}
  \mystate{\myss{RegistrationResult := \myangle{Content, Sig}}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, RegistrationResult}}}
  \mystop{f,a,m'}
  \ENDIF
  \mystate{\myss{Validity := \mathtt{CurrentTime} ()+ s'.Validity}}
 \mystate{\myss{s'.RPs := s'.RPs +  ^{\myangle{}} \myangle{PID_{RP}, Endpoint, Validity}}}
  \mystate{\myss{Content := \myangle{OK, PID_{RP}, Nonce, Validity}}}
  \mystate{\myss{Sig := \mathtt{Sig}(Content, s'.SignKey)}}
  \mystate{\myss{RegistrationResult := \myangle{Content, Sig}}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, RegistrationResult}}}
  \mystop{f,a,m'}
  \myelse{path \equiv /authorize}
  \mystate{\myss{cookie := headers[Cookie]}}
  \mystate{\myss{session := s'.sessions[cookie]}}
  \mystate{\myss{username := session[username]}}
  \myif{username \equiv \mathtt{null}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystop{f,a,m'}
  \ENDIF
  \mystate{\myss{PID_{RP} := parameters[PID_{RP}]}}
  \mystate{\myss{Endpoint := parameters[Endpoint]}}
  \myif{PID_{RP} \notin \mathtt{ListOfPID}() \lor Endpoint \notin \mathtt{EndpointsOfRP}(PID)}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystop{f,a,m'}
  \ENDIF
  \mystate{\myss{UID := session[uid]}}
  \mystate{\myss{PID_U := \mathtt{ModPow}(PID_{RP}, UID, s'.p)}}
  \mystate{\myss{Validity := \mathtt{CurrentTime} ()+ s'.Validity}}
  \mystate{\myss{Content := \myangle{PID_{RP}, PID_U, s'.ID, Validity}}}
  \mystate{\myss{Sig := \mathtt{Sig}(Content, s'.SignKey)}}
  \mystate{\myss{Token := \myangle{Content, Sig}}}
  \mystate{\myss{s'.Tokens := s'.Tokens + ^{\myangle{}}Token}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \myangle{Token, Token}}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystop{}
  \end{algorithmic}
\end{breakablealgorithm}


\subsection{RP process}
The state of RP server process is a term in the form \myss{\myangle{ID_{RP}, Endpoints, IdP, Cert, sessions, users}}. Other attributes are not mentioned here. 
\begin{itemize}
\item \myss{ID_{RP}} and \myss{Endpoints} are RP's registered information at IdP.
\item \myss{Cert} is the IdP signed RP information containing \myss{ID_{RP}, Endpoints} and other attributes.
\item \myss{IdP} is the term of the for \myss{\myangle{ScriptUrl, p, q, PubKey}}, where \myss{ScriptUrl} is the site to download IdP script, \myss{p} and \myss{q} are large prime defined before, and \myss{PubKey} is used to verify the IdP signed content.
\item \myss{sessions} is same as it in RP process.
\item \myss{users} is the set of RP registered user which is uniquely identified by the \myss{Account}.
\end{itemize}
 The new \myss{functions} are defined as follows
 \begin{itemize}
 \item \myss{\mathtt{ExEU}(a, q)} is the Extended Euclidean algorithm, of which the result in RP process the \myss{a^{-1} \mod q}.
  \item \myss{\mathtt{Random}()} is a newly generated random number.
  \item \myss{\mathtt{RegisterUser}(Account)} add the new user with \myss{Account} into RP's user list.
 \end{itemize}
The relation of RP process $R^r$ is shown as Algorithm~\ref{alg2}.

\begin{breakablealgorithm}
  \caption{$R^r$}
  \label{alg2}
  \begin{algorithmic}[1]
  \REQUIRE \myss{\myangle{a, f, m}, s}
  \mystate{\myss{s:=s'}}
  \mystate{\myss{n, method, path, parameters, headers, body} \textbf{such that}}\\
  \ \ \myss{\myangle{\mathtt{HTTPReq},n,method,path,parameters,headers,body} \equiv m}\\
  \ \ \textbf{if} \myss{possible}; \textbf{otherwise} stop \myss{\myangle{}, s'}
  \myif{path \equiv /script}
\mystate{\myss{m':=\myangle{\mathtt{HTTPResp},n,200, \myangle{}, \mathtt{RPScript}}}}
  \mystop{f, a, m'}  
  \myelse{path \equiv /login}   
  \mystate{\myss{m'  := \myangle{\mathtt{HTTPResp},n,302,\myangle{\myangle{Location, s'.IdP.ScriptUrl}}, \myangle{}}}}
  \mystop{f, a, m'}
  \myelse{path \equiv /startNegotiation}
  \mystate{\myss{cookie := headers[Cookie]}}
  \mystate{\myss{session := s'.sessions[cookie]}}
  \mystate{\myss{N_U := parameters[N_U]}}
  \mystate{\myss{PID_{RP} := \mathtt{ModPow}(s'.ID_{RP}, N_U, s'.IdP.p)}}
  \mystate{\myss{t := \mathtt{ExEU}(N_U, s'.IdP.q)}}
  \mystate{\myss{session[N_U] := N_U}}
  \mystate{\myss{session[PID_{RP}] := PID_{RP}}}
  \mystate{\myss{session[t] := t}}
  \mystate{\myss{session[state] := expectRegistration}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \myangle{Cert, s'.Cert}}}}
 \mystop{f, a, m'}
 \myelse{path \equiv /registrationResult}
 \mystate{\myss{cookie := headers[Cookie]}}
  \mystate{\myss{session := s'.sessions[cookie]}}
  \myif{session[state] \not\equiv expectRegistration}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystate{\myss{RegistrationResult := body[RegistrationResult]}}
  \mystate{\myss{Content:=RegistrationResult.Content}}
  \myif{\mathtt{checksig}(Content, RegistrationResult.Sig, s'.IdP.PubKey) \equiv \mathtt{FALSE}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystate{\myss{session := \mathtt{null}}}
  \mystop{f, a, m'}
  \ENDIF
  \myif{Content.Result \not\equiv OK}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystate{\myss{session := \mathtt{null}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystate{\myss{PID_{RP} := session[PID_{RP}]}}
  \mystate{\myss{N_U := session[N_U]}}
  \mystate{\myss{Nonce := \mathtt{Hash}( N_U)}}
  \mystate{\myss{Time := \mathtt{CurrentTime}()}}
  \myif{PID_{RP} \not\equiv Content.PID_{RP} \lor Nonce \not\equiv Content.Nonce \lor Time > Content.Validity}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystate{\myss{session := \mathtt{null}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystate{\myss{session[PIDValidity] := Content.Validity}}
  \mystate{\myss{Endpoint \in s'.Endpoints}}
  \mystate{\myss{session[state] := expectToken}}
  \mystate{\myss{Nonce' := \mathtt{Random}()}}
  \mystate{\myss{session[Nonce] := Nonce'}}
  \mystate{\myss{Body := \myangle{PID_{RP}, Endpoint, Nonce'}}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, Body}}}
  \mystop{f, a, m'}
  \myelse{path \equiv /uploadToken}
 \mystate{\myss{cookie := headers[Cookie]}}
  \mystate{\myss{session := s'.sessions[cookie]}}
  \myif{session[state] \not\equiv expectToken}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystate{\myss{Token := body[Token]}}
  \myif{\mathtt{checksig}(Token.Content, Token.Sig, s'.IdP.PubKey) \equiv \mathtt{FALSE}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystate{\myss{PID_{RP} := session[PID_{RP}]}}
  \mystate{\myss{Time := \mathtt{CurrentTime}()}}
  \mystate{\myss{PIDValidity := session[PIDValidity]}}
  \mystate{\myss{Content := Token.Content}}
  \myif{PID_{RP} \not\equiv Content.PID_{RP} \lor Time>Content.Validity \lor Time>PIDValidity}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{Fail}}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystate{\myss{PID_U := Content.PID_U}}
  \mystate{\myss{t := session[t]}}
  \mystate{\myss{Account := \mathtt{ModPow}(PID_U, t, s'.IdP.p)}}
  \myif{Account \in \mathtt{ListOfUser}()}
  \mystate{\myss{\mathtt{RegisterUser}(Account)}}
  \ENDIF
  \mystate{\myss{session[user] := Account}}
  \mystate{\myss{m' := \myangle{\mathtt{HTTPResp}, n, 200, \myangle{}, \mathtt{LoginSuccess}}}}
  \mystop{f, a, m'}
  \ENDIF
  \mystop{}
  \end{algorithmic}
\end{breakablealgorithm}

\subsection{IdP scripting process}
The state of IdP scripting process \myss{scriptstate} is a term in the form \myss{\myangle{IdPDomain, Parameters,p, q, refXHR}}, where 
\begin{itemize}
\item \myss{IdPDomain} is the IdP's host.
\item \myss{Parameters} is used to store the parameters received from other process.
\item \myss{p} is the large prime defined before.
\item \myss{q} is used to label the procedure point in the login.
\item \myss{refXHR} is the nonce to mapping HTTP request and response.
\end{itemize}
 The new \myss{functions} are defined as follows
 \begin{itemize}
 \item \myss{\mathtt{PARENTWINDOW}(tree,docnonce)}. The first parameter is the input relation tree defined before, and the second parameter is the nonce of a document. The output returned by the function is the current window's opener's nonce if it exists and is visible to this document.  
  \item \myss{\mathtt{CHOOSEINPUT}(inputs,pattern)}. The first parameter is a set of messages, and the second parameter is a pattern. The result returned by the function is the message in \myss{inputs} matching the \myss{pattern}.
  \item \myss{\mathtt{RandonUrl}()} returns a newly generated host string. 
 \end{itemize}
 The relation of IdP scripting process $script\_idp$ is shown as Algorithm~\ref{alg3}.

\begin{breakablealgorithm}
  \caption{$script\_idp$}
  \label{alg3}
  \begin{algorithmic}[1]
  \REQUIRE \myss{\myangle{tree, docnonce, scriptstate, scriptinputs, cookies, localStorage, sessionStorage, ids, secret}}
  \mystate{\myss{ s' := scriptstate}}
  \mystate{\myss{command := \myangle{}}}
  \mystate{\myss{target := \mathtt{PARENTWINDOW}(tree,docnonce)}}
  \mystate{\myss{IdPDomain := s'.IdPDomain}}
  \SWITCH{\myss{s'.q}}
    \CASE{\myss{start}}
      \mystate{\myss{N_U := \mathtt{Random}()}}
      \mystate{\myss{command := \myangle{\mathtt{POSTMESSAGE}, target, \myangle{\myangle{N_U, N_U}}, \mathtt{null}}}}
      \mystate{\myss{s'.Parameters[N_U] := N_U}}
      \mystate{\myss{s'.q := expectCert}}
    \ENDCASE
    \CASE{\myss{expectCert}}
      \mystate{\myss{pattern := \myangle{\mathtt{POSTMESSAGE}, *, Content, *}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern)}}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{Cert := input.Content[Cert]}}
      \mystate{\myss{s'.Parameters[Cert] := Cert}}
      \myif{\mathtt{checksig}(Cert.Content, Cert.Sig, s'.PubKey) \equiv \mathtt{null}}
      \mystate{\myss{\textbf{stop}\ \myangle{}}}
      \ENDIF
      \mystate{\myss{N_U := s'.Parameters[N_U]}}
      \mystate{\myss{PID_{RP} := \mathtt{ModPow}(Cert.Content.ID_{RP}, N_U, s'.p)}}
      \mystate{\myss{s'.Parameters[PID_{RP}] := PID_{RP}}}
      \mystate{\myss{Endpoint := \mathtt{RandomUrl}()}}
      \mystate{\myss{s'.Parameters[Endpoint] := Endpoint}}
      \mystate{\myss{Nonce := \mathtt{Hash}(N_U)}}
      \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, IdPDomain, /dynamicRegistration,\myangle{} }}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \langle\mathtt{XMLHTTPREQUEST}, Url, \mathtt{POST},} \\\ \ \ \ \myss{ \myangle{\myangle{PID_{RP}, PID_{RP}}, \myangle{Nonce, Nonce}, \myangle{Endpoint, Endpoint}}, s'.refXHR\rangle}}
      \mystate{\myss{s'.q := expectRegistrationResult}}
       \ENDIF
      \ENDCASE
      \CASE{expectRegistrationResult}
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{RegistrationResult := input.Body[RegistrationResult]}}
      \myif{ RegistrationResult.Content.Result \not\equiv OK}
      \mystate{\myss{s'.q := stop}}
      \mystate{\myss{\textbf{stop}\ \myangle{}}}
      \ENDIF
      \mystate{\myss{command := \myangle{\mathtt{POSTMESSAGE}, target, \myangle{\myangle{RegistrationResult, RegistrationResult}}, \mathtt{null}}}}
      \mystate{\myss{s'.q := expectProofRquest}}
      \ENDIF
      \ENDCASE
      \CASE{expectProofRquest}
      \mystate{\myss{pattern := \myangle{\mathtt{POSTMESSAGE}, *, Content, *}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern)}}
      \myif{input \not\equiv \mathtt{null}}
       \mystate{\myss{PID_{RP} := input.Content[PID_{RP}]}}
       \mystate{\myss{Endpoint_{RP} := input.Content[Endpoint]}}
       \mystate{\myss{s'.Parameters[Nonce] := input.Content[Nonce]}}
       \mystate{\myss{Cert := s'.Parameters[Cert]}}
      \mystate{\myss{s'.Parameters[Endpoint_{RP}] := Endpoint_{RP}}}
      \myif{Endpoint_{RP} \notin Cert.Content.Endpoints \lor PID_{RP} \not\equiv s'.Parameters[PID_{RP}]}
      \mystate{\myss{s'.q := stop}}
      \mystate{\myss{\textbf{stop}\ \myangle{}}}
      \ENDIF
      \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, IdPDomain, /loginInfo, \myangle{}}}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{GET},\myangle{}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectLoginState}}
      \ENDIF
      \ENDCASE
      \CASE{expectLoginState}      
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \myif{input.Body \equiv \mathtt{Logged}}
      \mystate{\myss{username \in ids}}
      \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, IdPDomain, /login, \myangle{}}}}
     \ mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{POST},\myangle{\myangle{username, username}, \myangle{password, secret}}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectLoginResult}}
      \myelse{input.Body \equiv \mathtt{Unlogged}}
      \mystate{\myss{PID_{RP} := s'.Parameters[PID_{RP}]}}
      \mystate{\myss{Endpoint := s'.Parameters[Endpoint]}}
      \mystate{\myss{Nonce := s'.Parameters[Nonce]}}
      \mystate{\myss{Url := \langle \mathtt{URL}, \mathtt{S}, IdPDomain, /authorize,}\\\ \ \ \  \myss{\myangle{\myangle{PID_{RP}, PID_{RP}}, \myangle{Endpoint, Endpoint}, \myangle{Nonce, Nonce}} \rangle}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{GET},\myangle{}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectToken}}
      \ENDIF
      \ENDIF
      \ENDCASE
      \CASE{expectLoginResult}
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \myif{input.Body \not\equiv \mathtt{LoginSuccess}}
      \mystate{\myss{\textbf{stop}\ \myangle{}}}
      \ENDIF
      \mystate{\myss{PID_{RP} := s'.Parameters[PID_{RP}]}}
      \mystate{\myss{Endpoint := s'.Parameters[Endpoint]}}
      \mystate{\myss{Nonce := s'.Parameters[Nonce]}}
      \mystate{\myss{Url := \langle \mathtt{URL}, \mathtt{S}, IdPDomain, /authorize,}\\\ \ \ \  \myss{\myangle{\myangle{PID_{RP}, PID_{RP}}, \myangle{Endpoint, Endpoint}, \myangle{Nonce, Nonce}} \rangle}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{GET},\myangle{}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectToken}}
      \ENDIF
      \ENDCASE
      \CASE{expectToken}
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{Token := input.Body[Token]}}
      \mystate{\myss{RPOringin := \myangle{s'.Parameters[Endpoint_{RP}], \mathtt{S}}}}
      \mystate{\myss{command := \myangle{\mathtt{POSTMESSAGE},target,\myangle{Token,Token},RPOrigin}}}
      \mystate{\myss{s .q := stop}}
     \ENDIF      
    \ENDCASE
  \ENDSWITCH
\mystate{\myss{\textbf{stop}\ \myangle{s',cookies,localStorage,sessionStorage,command}}}
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{RP scripting process}
The state of RP scripting process \myss{scriptstate} is a term in the form \myss{\myangle{IdPDomain, RPDomain, Parameters, q, refXHR}}. The \myss{RPDomain} is the host string of the corresponding RP server, and other terms are defined same as them in IdP scripting process.

Here we define another new function \myss{\mathtt{SUBWINDOW}(tree, docnonce)}. This function takes the \myss{tree} define above and the current document's \myss{nonce} as the input. And it selects the \myss{nonce} of the first window opened by this document as the output. However, if there is not the opened windows, it will return the null.

The relation of RP scripting process $script\_rp$ is shown as Algorithm~\ref{alg4}.
\begin{breakablealgorithm}
  \caption{$script\_rp$}
  \label{alg4}
  \begin{algorithmic}[1]
\REQUIRE \myss{\myangle{tree, docnonce, scriptstate, scriptinputs, cookies, localStorage, sessionStorage, ids, secret}}
\mystate{\myss{ s' := scriptstate}}
  \mystate{\myss{command := \myangle{}}}
  \mystate{\myss{IdPWindow := \mathtt{SUBWINDOW}(tree,docnonce).nonce}}
  \mystate{\myss{RPDomain := s'.RPDomain}}
  \mystate{\myss{IdPOringin := \myangle{s'.IdPDomian, \mathtt{S}}}}
  \SWITCH{\myss{s'.q}}
    \CASE{\myss{start}}
    \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, RPDomain, /login, \myangle{}}}}
    \mystate{\myss{command := \myangle{\mathtt{IFRAME}, Url, \_SELF}}}
    \mystate{\myss{s'.q := expectN_U}}
    \ENDCASE
    \CASE{\myss{expectN_U}}
    \mystate{\myss{pattern := \myangle{\mathtt{POSTMESSAGE}, *, Content, *}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern)}}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{N_U := input.Content[N_U]}}
      \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, RPDomain, /startNegotiation, \myangle{}}}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{POST},\myangle{\myangle{N_U, N_U}}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectCert}}
      \ENDIF
      \ENDCASE
      \CASE{\myss{expectCert}}
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{Cert := input.Content[Cert]}}
      \mystate{\myss{command := \myangle{\mathtt{POSTMESSAGE}, IdPWindow, \myangle{\myangle{Cert, Cert}}, IdPOringin}}}
      \mystate{\myss{s'.q := expectRegistrationResult}}
      \ENDIF
      \ENDCASE
      \CASE{\myss{expectRegistrationResult}}
      \mystate{\myss{pattern := \myangle{\mathtt{POSTMESSAGE}, *, Content, *}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern)}}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{RegistrationResult := input.Content[RegistrationResult]}}
      \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, RPDomain, /registrationResult, \myangle{}}}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{POST},\myangle{\myangle{RegistrationResult, RegistrationResult}}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectTokenRequest}}
      \ENDIF
      \ENDCASE
      \CASE{\myss{expectTokenRequest}}
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{PID_{RP} := input.Content.Body[PID_{RP}]}}
      \mystate{\myss{Endpoint := input.Content.Body[Endpoint]}}
      \mystate{\myss{Nonce := input.Content.Body[Nonce]}}
      \mystate{\myss{command := \langle\mathtt{POSTMESSAGE}, IdPWindow}, \\\ \ \ \  \myss{\myangle{\myangle{PID_{RP}, PID_{RP}}, \myangle{Endpoint, Endpoint}, \myangle{Nonce, Nonce}},  IdPOringin\rangle}}
      \mystate{\myss{s'.q := expectToken}}
      \ENDIF
      \ENDCASE
      \CASE{\myss{expectToken}}
      \mystate{\myss{pattern := \myangle{\mathtt{POSTMESSAGE}, *, Content, *}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern)}}
      \myif{input \not\equiv \mathtt{null}}
      \mystate{\myss{Token := input.Content[Token]}}
      \mystate{\myss{Url := \myangle{\mathtt{URL}, \mathtt{S}, RPDomain, /uploadToken, \myangle{}}}}
      \mystate{\myss{s'.refXHR :=  \mathtt{Random}()}}
      \mystate{\myss{command : = \myangle{\mathtt{XMLHTTPREQUEST}, Url, \mathtt{POST},\myangle{\myangle{Token, Token}}, s'.refXHR}}}
      \mystate{\myss{s'.q := expectLoginResult}}
      \ENDIF
      \ENDCASE
      \CASE{\myss{expectLoginResult}}
      \mystate{\myss{pattern := \myangle{\mathtt{XMLHTTPREQUEST},Body,s'.refXHR}}}
      \mystate{\myss{input := \mathtt{CHOOSEINPUT}(scriptinputs,pattern) }}
      \myif{input \not\equiv \mathtt{null}}
      \myif{input.Body \equiv \mathtt{LoginSuccess}}
      \mystate{\myss{LoadHomepage}}
      \ENDIF
      \ENDIF
    \ENDCASE
    \ENDSWITCH

\end{algorithmic}
\end{breakablealgorithm}
\end{appendices}