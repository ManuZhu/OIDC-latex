\section{Security Analysis}
\label{sec:analysis}
\begin{figure*}
  \centering
  \includegraphics[width=0.9\linewidth]{fig/game1.pdf}
  \vspace{-6mm}
  \caption{The Game.}
  \label{fig:game}
\vspace{-7mm}
\end{figure*}
In this section, we propose the security properties of privacy-preserving SSO schemes and then give the proofs that UPPRESSO follows the security properties.
\subsection{Security Properties}
\subsection{The Web Model}
\label{subsec:webmodel}
The Dolev-Yao model abstracts the entities in a system, such as browsers and web servers, as {\em atomic processes}, which communicate with each other through the {\em events}. \cite{SPRESSO} also defines {\em scripting processes} to model client-side scripting such as JavaScript, so a web system consists of a set of atomic and scripting processes. The state of a system, called a {\em configuration}, consists of the current states of all atomic processes and all the events that can be accepted by these processes. We list the definitions of these notations as below \cite{SPRESSO}.

%\vspace{1mm}
\noindent{\em Messages}  are the basic data carriers among web nodes, such as HTTP requests and responses.
\begin{comment}
are defined as formal terms without variables (i.e., ground terms) over a {\em signature}. %Terms are defined as names, variables and function symbols. A function symbol with arity 0 (with no arguments) is a constant symbol.
The signature $\Sigma$ consists of a finite set of function symbols (with arity). For messages in this mode, the signature $\Sigma$ contains constants such as ASCII strings and nonce, sequence symbols such as n-ary sequences $\langle \rangle$, $\langle . \rangle$, $\langle . ,. \rangle$, and function symbols that model cryptographic primitives such as $\mathtt{encrypt}, \mathtt{decrypt}$ and digital signatures. For example, an HTTP request can be modeled as a ground term containing a type (e.g., $\mathtt{HTTPReq}$), a nonce, a method (e.g., $\mathtt{GET}$ or $\mathtt{POST}$), a domain, a path, URL parameters, request headers and a message body, over the $\Sigma$ in the sequence symbol format. So,
an HTTP GET request for the domain {\sf exa.com/path?para=1} with empty header and body can be represented as: $m:=\langle\mathtt{HTTPReq},n,\mathtt{GET},exa.com,/path,\langle \langle para, 1\rangle \rangle ,\langle \rangle,\langle \rangle \rangle$.
\end{comment}

\noindent{\em Events} are the basic communication elements in the model. An event contains the addresses of sender and receiver and a message.
%An event is of the form $\langle a, f, m \rangle$, where $a$ and $f$ represent the addresses of the sender and receiver respectively, and $m$ is the message to be transmitted.

\noindent{\em Atomic Processes.} An {\em atomic Dolev-Yao (DY) process} is a tuple $p=$ $(I^p, Z^p, R^p,s_0^p )$, where $I^p$ is the set of addresses that the process listens to, $Z^p$ is the set of states (i.e., terms) that describes the process, $s_0^p$ is an initial state, and $R^p$ is the mapping from an input state $s \in Z^p$ and an event $e$ to a new state $s'$ and an event $e'$. %It is worth noting that for one process in a state, only a finite set of events can be accepted by the process as the state and event are defined as the input of $R^p$.
Each atomic process also contains a set of nonces that it may use.

\noindent{\em Scripting Processes} represent client-side scripts loaded by the browser to provide server-defined functions to the browser. However, a scripting process must rely on an atomic process, such as the browser, and provide the relation $R$ called by this atomic process.


\noindent {\bf Web system.} We can represent the web infrastructure as a web system of the form ($\mathcal{W}$, $\mathcal{S}$, $\mathtt{script}$, $E^0$), where $\mathcal{W}$ is the set of atomic processes containing both honest and malicious processes, $\mathcal{S}$ is the set of scripting processes including honest and malicious scripts, $\mathtt{script}$ is the set of concrete script codes related to specific scripting processes in $\mathcal{S}$, and $E^0$ is the set of events acceptable to the processes in $\mathcal{W}$.

\noindent A {\em configuration} of this web system is a tuple ($S, E, N$), where $S$ is the current states of all processes in $\mathcal{W}$, $E$ is the set of events that the processes accept, and $N$ is a global sequence of nonces that have not been used by the processes yet.

\noindent A {\em run step} is the system migrating from configurations ($S, E, N$) to ($S', E', N'$) by processing an event $e \in E$.

\noindent\textbf{The Formal Model of UPPRESSO.}
Accordingly, we model UPPRESSO as a web system, which is defined as $\mathcal{UWS} = (\mathcal{W}, \mathcal{S}, \mathtt{script}, E^0)$. $\mathcal{W}$ is a finite set of atomic processes in UPPRESSO, which contains an IdP server process, a finite set of web servers for the honest RPs, a finite set of honest browsers, and a finite set of attacker processes. Here, we consider all the RP processes and browser processes are honest, and model an RP or a browser controlled by an adversary as an atomic attacker process.\
$\mathcal{S}$ is a finite set of scripting processes, which contains {\sf script\_rp}, {\sf script\_idp} and {\sf script\_attacker}, where {\sf script\_rp} and {\sf script\_idp} are honest scripts downloaded by an RP process and the IdP process, and {\sf script\_attacker} denotes a script downloaded by an attacker process that exists in all browser processes.
The details about each process are described in Appendix.

\subsection{Proof of Security}
\noindent\textbf{Authentication.}

The  confidentiality of identity proof is guaranteed because none of the honest would send it to a malicious party. The detail of the proof is shown in the Appendix. Here we only focus on the main point of confidentiality, preventing the honest parties from sending the identity proof to the adversary without $redirect_uri$ mechanism. IdP issues the signed $RP certificate$ for each RP, which contains the RP's correct endpoint for identity proof. It can be found in Figure~\ref{fig:process}, in step 4.5-4.6, the identity proof is generated and sent ton RP, and the identity proof is strictly transformed to the origin defined in $RP certificate$. The scheme achieves the same security property as $redirect_uri$ mechanism.

The integrity of identity proof is guaranteed as all the attributes contained are well protected by the signature, and the key is never leaked to the adversary. Moreover, it can be proved that the attributes included in the identity proof cannot be controlled by the adversary beside of $PID_{RP}$.

Due to the $PID_{RP}$ registration, in a valid period an $PID_{RP}$ is only available to an RP, restricted by the $hash(N_U)$. Therefore, in the valid period the identity proof can be only accepted by the specific RP.

The main point of identification is whether an RP accepted $Account$ can be controlled by an adversary may be the most noticeable question for readers.
For example, the adversary may try to make the conflict $Account_1=ID_{U_1}ID_{RP_1}$, $Account_2=ID_{U_2}ID_{RP_2}$, and $Account_1=Account_2$ possible, where $ID_{U_1}$ and $ID_{RP_1}$ belong to the honest user and RP.
Here we give the direct conclusion. \textbf{The $PID_U$ achieved by an adversary cannot be transformed into the honest user's $Account$ at an honest RP.}

The details of authentication proof are shown in Appendix.

\subsection{Proof of Privacy}
\begin{figure*}
  \centering
  \includegraphics[width=0.7\linewidth]{fig/dalgorithm.pdf}
  \caption{The distinguishing algorithm.}
  \label{fig:dalgorithm}
\end{figure*}
In this section, we will give the privacy proof and show that UPPRESSO is secure against both IdP-based login tracing and RP-based identity linkage attacks.

\noindent\textbf{IdP-based login tracing.}
As shown in figure~\ref{fig:process}, the only information that is related to the RP's identity and is accessible to the IdP is $PID_{RP}$, which is converted from $ID_{RP}$ using a random $N_U$. Since $N_U$ is randomly chosen from $\mathbb{Z}_n$ by the user and the IdP ha no control of the process, the IdP should treat $PID_{RP}$ as being randomly chosen from $\mathbb{G}$. So, the IdP cannot recognize the RP nor derive its real identity. Therefore, IdP-based identity linkage becomes impossible in UPPRESSO.

Next, we will prove that UPPRESSO prevents RP-based identity linkage based on the Decisional Diffie-Hellman (DDH) assumption \cite{GoldwasserK16}. Here, we briefly introduce the DDH assumption:
%\noindent\textbf{The DDH Assumption.}
Let $q$ be a large prime and $\mathbb{G}$ denotes a cyclic group of order $n$ of an elliptic curve $E(\mathbb{F}_q)$.
Assume that $n$ is also a large prime. Let $P$ be a generator point of $\mathbb{G}$. The DDH assumption for $\mathbb{G}$ states that for any probabilistic polynomial time (PPT) algorithm $D$, the two probability distributions \{$aP$, $bP$, $abP$\} and \{$aP$, $bP$, $cP$\}, where $a$, $b$, and $c$ are randomly and independently chosen from $\mathbb{Z}_n$, are computationally indistinguishable in the sense that there is a negligible $\sigma(n)$ with the security parameter $n$ such that:
%where $q$ and $n$ are large primitive number, and $P$ is the point of $\mathbb{G}$.
%For any probabilistic polynomial time (PPT) algorithm $D$, the distributions, \{$P$, $aP$, $bP$, $abP$\}$_{a,b \in \mathbb{Z}_n}$ and \{$P$, $aP$, $bP$, $cP$\}$_{a,b,c \in \mathbb{Z}_n}$, are computationally indistinguishable. There is a negligible $\sigma(k)$, where $k$ is the security parameter.
\vspace{-\topsep}
\begin{multline*}
Pr[D(P, aP, bP, abP)=1]-Pr[D(P, aP, bP, cP)=1]=\sigma(n)
\end{multline*}
\vspace{-\topsep}

\vspace{-2mm}
\noindent\textbf{RP-based identity linkage.}
At the very beginning, let us see the data exposed to RP during the authentication in the UPPRESSO system. 
We can find that, RP holds $ID_{RP}$,  generates $PID_{RP}$, $T$, $Account$, and receives $N_U$, registration result (containing $PID_{RP}$, hash($N_U$) and $Endpoint_U$), and identity proof (including $PID_{RP}$ and $PID_U$). Then we delete the irrelevant data, $Endpoint_U$, as it is generated randomly and does not participates and further calculation. And the repetitive data should also be deleted, for example, $PID_{RP}$ is generated as $PID_{RP}=N_U \cdot {ID_{RP}}$ so that $PID_{RP}$ can be omitted. Finally, the effective date collected by the RP during the authentication flow is $\langle ID_{RP}, N_U, PID_U\rangle$, while $PID_U$ equals to $ID_U \cdot{(N_U \cdot {ID_{RP})}}$. 

%We assume that collusive can correlate $PID_U$s at different RPs and guess if they belong to the same user. Thus, 
There is a data set, $\langle ID_{RP1}$, $N_{U1}$, $ID_U \cdot{(N_{U1} \cdot {ID_{RP1})}}$, $ID_{RP2}$, $N_{U2}$, $ID_U' \cdot{(N_{U2} \cdot {ID_{RP2})}}\rangle$, that RP-based identity linkage attack can be considered as RP guesses whether $ID_U$ equals $ID_U'$. 
Here, we can define the game, the adversary owns the same ability as the RP. The adversary receive the input $\langle ID_{RP1}$, $N_{U1}$, $ID_U \cdot{(N_{U1} \cdot {ID_{RP1})}}$, $ID_{RP2}$, $N_{U2}$, $ID_U' \cdot{(N_{U2} \cdot {ID_{RP2})}}\rangle$ from the challenger, and returns the result $b$. 
The $b$ is set 1, while adversary guess that $ID_U$ equals $ID_U'$, otherwise 0. The game is shown as Figure~\ref{fig:game}.
Therefore, whether the RP-based identity linkage attack is available is equivalent to whether adversary has the advantage on the guessing game. 
We define $Pr_1$ is the probability, while the adversary returns $b=1$ as $ID_U$ equals to $ID_U'$. And $Pr_2$ is the probability, while the adversary returns $b=1$ as $ID_U$ does not equal to $ID_U'$.
Adversary has the advantage on the guessing game means that 
\vspace{-\topsep}
\begin{equation}
Pr_1-Pr_2>\sigma(n)
\end{equation}
While an adversary has the advantage on the guessing game, based on the challenger and adversary, we can build a PPT distinguishing algorithm $D$ that breaks DDH assumption. The algorithm is shown as Figure~\ref{fig:dalgorithm}. That is, the input of $D$ in the form ($X$,$Y$,$Z$,$N$), while $X$,$Y$,$Z$,$N$ are points on the elliptic curve. The challenger receives the input and set $ID_{RP1}=X$, $ID_{RP2}=Y$, $PID_{U1}=N_{U1} \cdot{Z}$, and $PID_{U2}=N_{U2} \cdot{N}$.  At the end, $D$ returns the $b$ as the result. 
Now, we let ($P$, $aP$, $bP$, $abP$) and  ($P$, $aP$, $bP$, $cP$) be the input. Thus there is
\vspace{-\topsep}
\begin{multline*}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Pr[D(P,aP,bP,abP)=1]=\\ Pr[A(P, N_{U1}, b \cdot{N_{U1}P}, aP, N_{U2},b\cdot{N_{U2} aP})=1]=Pr_1\\
Pr[D(P,aP,bP,cP)=1]=\ \ \ \ \ \ \ \ \ \ 
\\ Pr[A(P, N_{U1}, b \cdot{N_{U1}P}, aP, N_{U2},c/a \cdot{N_{U2}aP})=1]=Pr_2
\end{multline*}
in the first equation $ID_{U} $ and $ ID_{U}'$ all equal to $b$, while in the second equation $ID_{U}$ does not equal to $ID_{U}'$, so that
\begin{equation}
Pr_1-Pr_2=\sigma(n)
\end{equation}
There is a contradiction between equation (4) and equation (5). Therefore, an adversary cannot have the advantage on the guessing game. Thus, the RP-identity linkage attack is not available.


