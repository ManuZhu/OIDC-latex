\section{The Design of UPPRESSO}
\label{sec:UPPRESSO}
This section provides the design of UPPRESSO.
We firstly present the detailed functions of identifier transformation, for trapdoor user identification and transformed RP designation.
Then, we provide an overview of UPPRESSO and describe the protocols.
Finally, we discuss the compatibility of UPPRESSO with OIDC.

\subsection{Functions of Identifier Transformation}
\label{subsec:overview}
As mentioned in Section \ref{sec:challenge},
the functions of identifier transformation
 are essential for privacy-preserving SSO systems.
In UPPRESSO,
$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$
    are constructed based on the discrete logarithm with public parameters $p$, $q$, and $g$, %% L不作为参数，我们说：e, n是RSA算法参数，不说2048是参数。
 where  $p$ is a large prime defining the finite field $GF(p)$,
 % $L$ is the length of $q$ in bits,  ($2^{L-1} < q < 2^L$)
  $q$ is a prime factor of ($p-1$), and $g$ is a generator of order $q$ in $GF(p)$.
%the prime number $q$  is the order of a multiplicative subgroup of $GF(p)$, which is generated with the generator $g$ by $\{g\ mod\ p, g^2\ mod\ p, ..., g^{q-1}\ mod\ p, 1=g^q\ mod\ p\}$.

The IdP assigns a  unique random number as  $ID_U$ ($1 < ID_U <q $) to each user,
 and a unique $ID_{RP}$ at the RP's initial registration.
$ID_{RP}$ is calculated as follows, where $r$ is a random number ($1 < r < q$) generated by the IdP.

\begin{equation}
    ID_{RP} = g^{r} \bmod p
   \label{equ:IDRP}
\end{equation}


In each login,
 the user and the visited RP negotiate $PID_{RP}$ as follows.
The RP chooses a random number $N_{RP}$ ($1 < N_{RP}<q $), and the user chooses another random number $N_{U}$ ($1 < N_{U}<q $).
Then, they cooperatively calculate $PID_{RP}$ as in Equation~\ref{equ:PIDRP}.

\begin{equation}
    \mathcal{F}_{ID_{RP} \mapsto PID_{RP}}: PID_{RP} = {ID_{RP}}^{N_{U} N_{RP}} \bmod p
   \label{equ:PIDRP}
   \end{equation}


$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ satisfies the following requirements. % described in Section~\ref{subsec:challenges}.
     %That is, the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ is invoked to generate $PID_{RP}$ for each login, while
First,
it is computationally infeasible for
    the IdP to derive $ID_{RP}$ from $PID_{RP}$ due to the discrete logarithm problem.
$N_{U}$ and $N_{RP}$  serves as nonces to ensure that (\emph{a}) $PID_{RP}$ is valid only for this login as well as the identity proof,
     and (\emph{b}) the IdP cannot associate multiple ${PID_{RP}}$s for a same RP.
Finally,
    the cooperation by the user and the RP prevents a single malicious entity from manipulating the value of $PID_{RP}$.
%For example, the malicious user fails to make a correct RP accept a $PID_{RP}$ used in another login, while the collusive RPs fail to use a same or correlated $PID_{RP}$s for different logins.

On receiving an identity proof request of
    $ID_U$ and $PID_{RP}$ from an authenticated user,
the IdP calculates $PID_U$ as Equation~\ref{equ:PIDU},
    and binds it in the identity proof.

\begin{equation}
 \mathcal{F}_{ID_{U} \mapsto PID_{U}}: PID_U = {PID_{RP}}^{ID_U} \bmod p
 \label{equ:PIDU}
\end{equation}

% The function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ satisfies the requirements described in Section~\ref{subsec:challenges}.
We have $PID_U = {ID_{RP}}^{N_UN_{RP}ID_U}  = g^{rN_UN_{RP}ID_U} \bmod p$ from Equations~\ref{equ:IDRP}, ~\ref{equ:PIDRP} and~\ref{equ:PIDU}.
The discrete logarithm problem ensures that the RP cannot derive $ID_U$ from $PID_U$.
Moreover,
    provided that $r$ is kept secret to the RP,
    collusive RPs cannot link a user's $PID_U$s at different RPs.
    % who can never know $r$ and $ID_U$. %have different $ID_{RP}$. %discrete logarithm of $ID_{RP}$ modulo $ID_{RP}^'$
If $r$ is known to the RP,
    two collusive RPs might attempt to associate a user's $PID_U$s by checking whether the equality ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds or not,
        because ${PID_{U_1}} = g^{r_1N_{U_1}N_{RP_1}ID_{U_1}} \bmod p$ and ${PID_{U_2}} = g^{r_2N_{U_2}N_{RP_2}ID_{U_2}} \bmod p$.


Finally, the RP derives $Account$ for the user %with the function $\mathcal{F}_{PID_{U} \mapsto Account}$
 as Equation~\ref{equ:Account}.
Here, we define $T = (N_UN_{RP})^{-1} \bmod q$ as the RP's trapdoor.
As $q$ is a prime number and $1< N_U, N_{RP} < q$, $q$ is coprime to $N_U N_{RP}$, and then $T$ that satisfies $T (N_U N_{RP}) = 1 \bmod q$ always exists.

\begin{equation}
   \mathcal{F}_{PID_{U} \mapsto Account}: Account = {PID_U}^{T} \bmod p
   \label{equ:Account}
   \end{equation}

We have $Account = {ID_{RP}}^{ID_U} \bmod p$ as Equation~\ref{equ:AccountNotChanged} shows,
 from Equations and \ref{equ:PIDRP}, \ref{equ:PIDU}, and \ref{equ:Account}.
So in a user's multiple logins at an RP, the RP derives an identical $Acount$.

 \begin{multline}\label{equ:AccountNotChanged}
   Account =  {PID_{U}}^{T} = {({PID_{RP}}^{ID_U})}^{{(N_UN_{RP})^{-1} \bmod q}}\\
   = {ID_{RP}} ^ {ID_U N_U N_{RP} T \bmod q} = {ID_{RP}}^{ID_U} \bmod p
 \end{multline}

$\mathcal{F}_{PID_{U} \mapsto Account}$ satisfies the following requirements. %described in Section~\ref{subsec:challenges}.
Similar to the analysis of $PID_U$,
    the RP cannot derive $ID_U$ from $Account$,
        and
    collusive RPs cannot link a user's $Account$s at different RPs.

\noindent\textbf{Trapdoor User Identification.} %is supported with these three functions.
In a user's multiple logins, the RP expresses different $PID_U$s and have corresponding $T$s,
 so that always derives the identical $Account$.
%$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$
The comprehensive design of identifier-transformation functions
 prevents collusive RPs from linking a user's $PID_U$s and $Account$s at different RPs, and therefore prevents RP-based identity linkage.

\noindent\textbf{Transformed RP Designation.} %is also supported with $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, together
    % with  a user-centric verification. 放入到后面写！这里只是谈ID transformation
The $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ ensures that the user and RP cooperatively generate a fresh $PID_{RP}$ in each login,
 while $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ ensures that the IdP generates the exact $PID_U$ for the $ID_U$ who logins at $PID_{RP}$.
The IdP will bind $PID_{U}$ with $PID_{RP}$ in the identity proof, which designates this identity proof to $PID_{RP}$.
%Therefore, the $PID_{RP}$ is designated to $ID_{RP}$.
Finally, the transformed RP designation is provided through the two-phase designations.
The function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ prevents the curious IdP from linking the $PID_{RP}$s of different logins at an RP, and therefore avoids  the  IdP-based login tracing.

\subsection{UPPRESSO Overview}
\label{implementations}
In addition to the identifier-transformation functions,
    UPPRESSO needs to introduce more steps at the user to facilitate these identifier transformations.
It is worthy noting that,
    in order to protect user privacy against both the IdP and the visited RP,
        these steps have to be conducted at the user.
Firstly,
    because the IdP is unaware of the visited RP and also the RP's endpoint to receive the identity proof,
        this endpoint shall be queried by the user from the trusted IdP indirectly to ensure confidentiality;
        otherwise, an incorrect endpoint leaks the identity proofs.
In UPPRESSO this is implemented as an RP certificate signed by the IdP,
    which is composed of $ID_{RP}$, the RP's endpoint and other supplementary information.
Then, the user determines the endpoint by itself,
    while in commonly-used OIDC systems, the endpoint is configured by the IdP.
Secondly,
    we handle $PID_{RP}$ in two phases:
        it is registered at the trusted IdP with a one-time endpoint,
            and then $PID_{RP}$ is included in the identity proof as common identity proofs.
Therefore,
    they are implemented as two phases compatible with OIDC.
Finally,
    after the negotiation of $PID_{RP}$,
        it is registered at the IdP by the authenticated user.
This cannot be finished by the RP; otherwise,
    the IdP will associate $PID_{RP}$ and $ID_{RP}$.


%user-centric verification,  both the user and RP checks the uniqueness of $PID_{RP}$, while the user further checks that $PID_{RP}$ is exactly generated for the RP $ID_{RP}$,  and then sends the identity proof  only  to this RP.

UPPRESSO runs with four procedures, including system initialization, RP initial registration, user registration and SSO login.
The system initialization is conducted only once by the IdP to establish the system.
The RP initial registration is launched by each RP to obtain the necessary configurations including a unique identifier $ID_{RP}$ and its RP certificate $Cert_{RP}$ from the IdP, before it provides services for users,
    and each RP launches this procedure only once.
The user registration is launched only once by each user to set up a unique user identifier $ID_U$ and the corresponding user credential.
   % where $ID_U$ is generated by the IdP and only provided to the corresponding user.
Finally, the SSO login is launched when a user attempts to log in an RP,
    and it is designed based on the functions of identifier transformation.

The procedure for user registration is the same as that in typical SSO systems.
Therefore, we focus on the procedures of system initialization, RP initial registration and SSO login.
For clear understand, we list the notations in Table~\ref{tbl:notations}.


\begin{table}[tb]
    \caption{The notations used in UPPRESSO.}
    \centering
%    \begin{tabular}{|c|c|c|}
    \setlength{\tabcolsep}{1.2mm}
    \begin{tabular}{|p{1.12cm}|p{4.65cm}|p{2.23cm}|}
    \hline
    {\textbf{Notation}} & {\textbf{Definition}} & {\textbf{Attribute}} \\
    \hline
    {$p$} & {A large prime.} & {Long-term constant} \\
    \hline
    {$q$} & {A large  prime factor of ($p-1$).} & {Long-term constant} \\
    \hline
%    {$L$} & {Length of $q$. } & {Long-term} \\    \hline
     {$g$} & {A generator of order $q$ in $GF(p)$. } & {Long-term constant} \\
     \hline
   % \hline
    %{$SK_{ID}$, $PK$} & {The private/public key to sign/verify identity proof.} & {System-unique} \\
    {$SK$, $PK$} & {The private/public key of IdP. } & {Long-term constant} \\
    \hline
    {$ID_{RP}$} & {$ID_{RP}=g^r \bmod p$, an RP's unique identity.} & {Long-term constant} \\
    \hline
%    {$r$} & {value for $ID_{RP}=g^r \bmod p$.} & {Secret, Long-term} \\
%    \hline
    {$Cert_{RP}$} & {An RP certificate, containing the RP's identity and endpoint.} & {Long-term constant} \\
    \hline
    {$ID_U$} & {A user's unique identity.} & {Long-term constant} \\
    \hline
     {$Account$} & {$Account = {ID_{RP}}^{ID_U} \bmod p$, a user's identifier at an RP.} & {Long-term constant} \\
    \hline
    {$PID_{RP}$} & {$PID_{RP} = {ID_{RP}}^{N_{U} N_{RP}} \bmod p$, an RP's pseudo-identifier.} & {One-time variable} \\
    \hline
    {$PID_U$} & {$PID_U = {PID_{RP}}^{ID_U} \bmod p$, a user's pseudo-identifier.} & {One-time variable}\\
    \hline
    {$N_U$} & {A user-generated nonce for $PID_{RP}$.} & {One-time variable} \\
    \hline
    {$N_{RP}$} & {An RP-generated nonce for $PID_{RP}$.} & {One-time variable} \\
    \hline
    {$Y_{RP}$} & {$Y_{RP} = {ID_{RP}}^{N_{RP}} \bmod p$, the public value for $N_{RP}$.} & {One-time variable} \\
    \hline
    {$T$} & {$T=(N_U N_{RP})^{-1} \bmod q$, the trapdoor to derive $Account$.} & {One-time variable} \\
    \hline
    \end{tabular}
    \label{tbl:notations}
\end{table}

\vspace{1mm}\noindent \textbf{System Initialization.} The IdP %chooses $L$,
 generates a large prime $p$, a prime factor $q$ of $p-1$
  and a generator $g$ of order $q$ as the parameters for the discrete logarithm problem. %~\cite{gallagher2013digital}.
The IdP generates one key pair ($SK$, $PK$) to sign identity proofs and RP certificates.
The lengths of $p$, $q$ and ($SK$, $PK$) shall satisfy the requirements of security strength.

The IdP keeps $SK$ secret, while $p$, $q$, $g$ and $PK$ are public parameters.
%The values of $p$, $q$, $g$ remain the same during the full lifecycle of an SSO system.
%While, the asymmetric key pair ($SK$, $PK$) will be updated when necessary. For example, when $SK$ is leaked, IdP must update ($SK$,$PK$).

\vspace{1mm}\noindent\textbf{RP Initial Registration.}
An RP registers itself at the IdP to request $ID_{RP}$ and $Cert_{RP}$ as follows:
\begin{itemize}
\item The RP sends a registration request to the IdP,
    including the RP's endpoint (e.g., URL) for receiving the identity proof.
\item The IdP chooses a unique random number $r$ ($1 < r < q$), calculates $ID_{RP} = g^r \bmod p$,
signs $[ID_{RP}, Endpoint_{RP}, *]$ using $SK$, where $*$ is  supplementary information such as the RP's common name,
and returns $Cert_{RP} = [ID_{RP}, Endpoint_{RP}, *]_{SK}$ to the RP, where $[\cdot]_{SK}$ means a message signed using $SK$.
\item The RP  verifies $Cert_{RP}$ using $PK$,  and then accepts $ID_{RP}$ and $Cert_{RP}$.
\end{itemize}

Note that, $ID_{RP}$ cannot be chosen by the RP,
 and it must be chosen by the IdP and $r$ is kept unknown to the RP.
On the contrary,
    $ID_U$ may be chosen by the user or the IdP,
    provided that it is unique for each user.

\vspace{1mm}\noindent\textbf{SSO Login.}
Once a user attempts to log into an RP, the SSO login is initiated.
%We use the OIDC implicit protocol flow as an example, to demonstrate  how to integrate the three functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the typical SSO systems.
As shown in Figure~\ref{fig:process}, the SSO login consists of four phases,
 RP identifier transformation,
  $PID_{RP}$ registration,
  identity proof generation and $Account$ calculation.
In the RP identifier transforming, the user and the RP negotiate $PID_{RP} = {ID_{RP}}^{N_{U} N_{RP}} \bmod p$.
Then, the user registerers $PID_{RP}$ at the IdP.
The user requests the identity proof from the IdP,
    and the IdP calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ and signs the identity proof.
Finally,
    in the $Account$ calculation, the RP derives $Account = {{PID_{U}}}^{{(N_UN_{RP})^{-1} \bmod q}} \bmod p$ after verifying the identity proof,
    and allows the user to log in as $Account$.

\subsection{SSO Login Flow of UPPRESSO}
\label{sebsec:loginprocess}
Figure~\ref{fig:process} shows the detailed SSO login protocol of UPPRESSO. %the SSO login sub-protocol provides the secure SSO service and prevents both the IdP-based login tracing and RP-based identity linkage.
 % prevents the curious IdP from obtaining the RP's identifying information during the interchanges,
%  and avoids the adversary to break the security and user's privacy.
We describe the detailed processes as follows.

\begin{figure*}
  \centering
  \includegraphics[width=0.65\linewidth]{fig/process.pdf}
  \caption{Process for each user login.}
  \label{fig:process}
\end{figure*}

\vspace{1mm}\noindent\textbf{RP Identifier Transforming.}
In this phase, the user and RP cooperative to generate $PID_{RP}$ as follows:
\begin{itemize}
  \item [1.1] The user sends a login request to trigger the negotiation of $PID_{RP}$.
  \item [1.2] The RP chooses a random $N_{RP}$ ($1 < N_{RP} <q$), calculates $Y_{RP}={ID_{RP}}^{N_{RP}} \bmod p$; % (Step 2.1.1);
   and sends $Y_{RP}$ with $Cert_{RP}$  to the user. % (Step 2.1.2).
  \item [1.3] The user verifies $Cert_{RP}$, extracts $ID_{RP}$ from the valid $Cert_{RP}$, chooses a random $N_U$ ($1 < N_U <q$) to calculate $PID_{RP}={Y_{RP}}^{N_{U}} \bmod p$, and sends $N_U$ %with $PID_{RP}$
       to the RP.
  \item [1.4] The RP verifies $N_{U} \neq 0 \bmod q$, calculates $PID_{RP}$ with $N_U$ and $Y_{RP}$, %checks its consistency with the received one,
   derives the trapdoor $T={(N_U N_{RP})}^{-1} \bmod q$; and
   acknowledges the negotiation by responding with $N_{RP}$.
  \item [1.5] The user verifies that $N_{RP} \neq 0 \bmod q$ and $Y_{RP} = {ID_{RP}}^{N_{RP}} \bmod p$.
   %sends the calculated $PID_{RP}$ to the user (Step 2.1.6).
%  \item The user checks the consistency of the received $PID_{RP}$ with the stored one.
\end{itemize}

The user will halt the negotiation,
     if  $Cert_{RP}$ is invalid, $N_{RP} = 0 \bmod q$, or $Y_{RP} \neq {ID_{RP}}^{N_{RP}} \bmod p$.
The verification of $Y_{RP}$ and $N_{RP}$ ensures the order of $Y_{RP}$ (and also $PID_{RP}$) is $q$,
    and prevents a malicious RP from choosing an arbitrary $Y_{RP}$ (then $PID_{RP}$) of order less than $q$,
        which makes it less difficult for the RP to derive $ID_U$ from $PID_U$.
 %or the received $PID_{RP}$ is different from the stored one. The RP also halts the process if the $PID_{RP}$ sent by the user is inconsistent with the calculated one.
%The user verifies that  \textcolor[rgb]{1.00,0.00,0.00}{$PID_{RP}$ is in the cyclic  group defined by $g$},
%$PID_{RP} \neq g^0 \bmod p$;
%    if $PID_{RP} = g^0 \bmod p$, $PID_U = {g}^{0*ID_U}$ is constant for all users.
%This case appears only if  $N_U = 0 \bmod q$ or $N_{RP} = 0 \bmod q$.

\vspace{1mm}\noindent\textbf{$\mathbf{PID_{RP}}$ Registration.}
The user registers $PID_{RP}$ at the IdP as follows.
\begin{itemize}
  \item [2.1] The user creates an one-time endpoint to hide the RP's endpoint from the IdP, and sends the ${PID_{RP}}$ registration request $[PID_{RP}, Hash(N_{RP}, N_U), Endpoint_U]$ to the IdP.
  \item [2.2] The IdP authenticates the user if she has not been authenticated yet.
  The IdP verifies that $PID_{RP}$ is unique among unexpired $PID_{RP}$s,
    and then signs the response $[PID_{RP}, Hash(N_{RP}, N_U), Validity]_{SK}$,
        where $Validity$ is the validity period.
The IdP returns the signed response to the user.
  \item [2.3] The user forwards the registration result to the RP.
  \item [2.4] The RP verifies the IdP's signature, and accepts it only if $PID_{RP}$ and $Hash(N_{RP}, N_U)$ match those in the negotiation and it is in the validity period.
\end{itemize}

%If $RegRes$ is $OK$, the RP identifier refreshing completes. Otherwise, the user and RP will renegotiate the $PID_{RP}$.
$Hash(N_{RP}, N_U)$ is attached as the nonce to avoid the result is accepted by two or more RPs,
 which have different $ID_{RP}$s but generate a same $PID_{RP}$ with a negligible possibility.
The IdP ensures $PID_{RP}$ is unique among unexpired ones;
 otherwise, one identity proof for one $PID_{RP}$ might be accepted by other RPs.
%The RP checks if Hash($N_{RP}$, $N_U$) matches,
%    to ensure this is signed for it (not for other RPs).
More details are analyzed in Section~\ref{sec:analysis}.

\vspace{1mm}\noindent\textbf{ID Proof Generation.}
In this phase, the RP continues the process of the user login and obtains $PID_U$ generated by the IdP. The processes are as follows.
\begin{itemize}
  \item [3.1] The RP uses $PID_{RP}$ and $Endpoint_{RP}$ to construct an identity proof request for a set of user's attributes.  %, which is the same as the one in  OIDC.

  \item [3.2] The user first confirms the scope of the requested attributes and verifies $PID_{RP}$ with the negotiated one. The user replaces the endpoint with the registered one-time $Endpoint_U$, and sends the modified identity proof request to the IdP.
  \item [3.3] The IdP verifies whether $PID_{RP}$ and $Endpoint_U$ have been registered and unexpired, and
   calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ for the authenticated user.
\item [3.4] The IdP constructs and signs the identity proof $[PID_{RP}, PID_U, Iss, ValTime, Attr]_{SK}$, where $Iss$ is the identifier of the IdP,  $ValTime$ is the validity period, $Attr$ contains the requested attributes. Then, the IdP sends the identity proof to the one-time endpoint at the user.
  \item [3.5] The user extracts the RP endpoint in $Cert_{RP}$,
   and forwards the identity proof to the RP through this endpoint.
\end{itemize}
The user halts the process if $PID_{RP}$ in the identity proof request is inconsistent with  the negotiated one.
The IdP rejects the identity proof request, if the pair of $PID_{RP}$ and $Endpoint_U$ has not been registered.


\vspace{1mm}\noindent\textbf{$\mathbf{Account}$ calculation.}
Finally, RP derives the user's  $Account$ and completes the user login as follows.
\begin{itemize}
\item[4.1]
The RP verifies the identity proof, including the signature, the validity period, and the consistency between $PID_{RP}$ and the negotiated one.
\item [4.2] The RP extracts $PID_U$, and calculates $Accout = {PID_U}^T \bmod p$; and sends the $Success$ as the login result to the user. If any fails, the RP rejects this login.
\end{itemize}
%
%\begin{figure}[t]
%  \centering
%  \includegraphics[width=\linewidth]{fig/overview1.pdf}
%  \caption{UPPRESSO compatibility with OIDC.}
%  \label{fig:UPPRESSO}
%\end{figure}
%

\subsection{Compatibility with OIDC}
\label{subsec:compatible}
The design of UPPRESSO can be integrated in the traditional SSO systems, %to  prevent the IdP-based login tracing and RP-based identity linkage.
and it only requires small modifications to implement the SSO login flow of UPPRESSO (i.e., the most important protocol of UPPRESSO).
Next, we compare it with OIDC to demonstrate the compatibility of UPPRESSO.

As mentioned above,
    the SSO login flow of UPPRESSO is composed of four phases, namely,
        RP identifier transforming, $PID_{RP}$ registration, identity proof generation, and $Account$ calculation.
RP identifier transforming is conducted between a user and the RP, which is specific to UPPRESSO,
    while the others adopt the communication patterns of some OIDC flows.

First of all,
    UPPRESSO doesn't introduce any new role, nor change the security assumptions on each role (i.e., user, IdP and RP).
$PID_{RP}$ registration can be viewed as the RP dynamic registration flow of OIDC~\cite{DynamicRegistration},
    where an entity registers its identity and endpoint at the IdP.
In UPPRESSO,
    this process is launched by any authenticated user who provides a candidate of the identifer,
      the registration response includes a signature from the IdP,
        and the registration will become invalid after a validity period.
These differences will bring very small modifications.


Identity proof generation and $Account$ calculation of UPPRESSO,
    finish the same steps as the implicit protocol flow of OIDC,
        except some parameters are modified as follows.
$ID_U$ is transformed to $PID_U$ by the IdP, and this modification is actually allowed in OIDC;
    for example, PPID allows various designs to calculate $PID_U$ from $ID_U$.
The calculation of $Account$ from $PID_U$ bound in the identity proof,
    can be viewed as a step by the RP to derive its user account after the implicit protocol flow of OIDC ends.
The final modification is
    the replacement of endpoint by the user, to forward the identity proof to the RP.
In fact, this message forwarding is common when an application-layer network proxy is deployed.
So
identity proof generation and $Account$ calculation of UPPRESSO,
    can be viewed as a particular but compatible implementation of the implicit protocol flow of OIDC.
Finally,
    identity proof generation and $Account$ calculation of UPPRESSO,
        can be also implemented as the authorization code flow of OIDC with small modifications,
        which is discussed in Section \ref{sec:discussion}.

%As shown in Figure~\ref{fig:process}, in UPPRESSO, the SSO protocol for identity proof is the same as in OIDC; the formats of identity proof and corresponding request are the same as in OIDC; the correctness checks on the identity proof request at the IdP (i.e., consistency of RP' identifier and endpoint with the registered one) are the same as in OIDC; the correctness checks on the identity proof (i.e., consistency of RP' identifier with the one in the request, integrity, validity time, freshness, and etc.) at the RP are the same as in OIDC.
%The above modifications could be completed automatically for each login, without affecting other communication pattern.

%以下为描述Step 2.3到7的详细内容.
%That is, the RP construct a request for identity proof (Step 2.3); the user redirects this request to the IdP (Step 2.5); the IdP generates the identity proof (Step 4), and sends it to the user (Step 5.1) who redirects it to the RP (Step 5.3); and finally the RP verifies the identity proof (Step 6).

%However, UPPRESSO achieves privacy preservation by integrating  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, and  introduces the following modifications on OIDC.

%\begin{enumerate}
%  \item The identity proof is bound with $PID_{RP}$ instead of $ID_{RP}$, which introduces the RP identifier transforming (Steps 1.2-1.5)  and $PID_{RP}$ registration (Steps 2.1-2.4).
%  \item The identity proof is designated to one-time endpoint instead of RP's identifying endpoint, which requires the user to register the one-time endpoint in Step 2.1 and replace it with the original endpoint in Step 3.2.
%  \item IdP generates $PID_U$ based on ($PID_{RP}$, $ID_U$) instead of ($ID_{RP}$, $ID_U$).
%  \item The RP calculates $Account$ from the changing $PID_U$ instead of an unchanged one.
%\end{enumerate}

%上述modification如何实现的，简单描述
%to add: PID_{RP} transforming 和 RP identifer refreshing在user和RP的页面自己完成了。 都用现成的数据格式
%one-time endpoint 和endpoint
%The user automatically invokes the JavaScript functions to complete RP identifier transforming, one-time endpoint generating/replacing and $PID_{RP}$ registration for each login.
%While, the RP server and IdP server provide the corresponding web service to complete the processing automatically.

%The protocol of RP identifier transformation is based Diffie-Hellman key exchange~\cite{DiffieH76}, while $N_U$ is provided to RP for computing the trapdoor and $N_{RP}$ is provided to the user for verifying the correctness of $Y_{RP}$.

\begin{comment}
\vspace{1mm}\noindent \textbf{Consistency with OIDC.}
As shown in Figure~\ref{fig:UPPRESSO}, the architecture of UPPRESSO is the same as the one in OIDC. UPPRESSO does not introduce any new entity, but only integrates the three function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the processes at the IdP, RP, and user.

The formats of the  identity proof and corresponding request, and the verification of the identity proof,  are almost same in OIDC and UPPRESSO.
The only difference is that $ID_{RP}$ and endpoint are replaced with the privacy-preserving versions, i.e., $PID_{RP}$ and one-time endpoint, in UPPRESSO.
As $PID_{RP}$ is also unique and corresponds exactly to $ID_{RP}$, and one-time endpoint corresponds to the RP's endpoint correctly,
 the binding, integrity and confidentiality of identity proof will also be ensured in UPPRESSO, and there is no degradation on the security of OIDC.

\vspace{1mm}\noindent \textbf{Minimal modification to OIDC.}
UPPRESSO only requires small modification on OIDC to integrate $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$.
For $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, we directly use them to replace original functions for $PPID$ at the IdP and the $Account$ at the RP.
For $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, we inject a negotiation process and a dynamic registration for each SSO login,
 where the negotiation process between the user and RP generates a $PID_{RP}$,
  while the dynamic registration is used to check the uniqueness of $PID_{RP}$.
In UPPRESSO, the dynamic registration is slightly modified as follows: an RP identifer ($PID_{RP}$)  is added in the request, and a signature ($Sig_{Res}$)  is included in the response for its verification at the RP.
\end{comment}




