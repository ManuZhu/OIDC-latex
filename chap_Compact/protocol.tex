\section{The Design of UPPRESSO}
\label{sec:UPPRESSO}
Next, we present the main design of UPPRESSO. First, we describe our design for the three identifier-transformation functions and the details of the transformed RP designation and trapdoor user identification schemes. Then, we provide an overview of the UPPRESSO system and its login flow. Finally, we discuss the compatibility of UPPRESSO with OIDC. 


\subsection{Identifier-transformation Functions in UPPRESSO}
\label{subsec:overview}

As discussed in Section \ref{sec:challenge}, the identifier-transformation functions are essential for privacy-preserving SSO systems.
In UPPRESSO, the three functions, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, are all constructed based on the discrete logarithm problem with public parameters $p$, $q$, %and $g$, %% L不作为参数，我们说：e, n是RSA算法参数，不说2048是参数。
where $p$ is a large prime defining the finite field $GF(p)$,
 % $L$ is the length of $q$ in bits,  ($2^{L-1} < q < 2^L$)
and $q$ is a prime factor of ($p-1$).%, and $g$ is a generator of order $q$ in $GF(p)$.
%the prime number $q$  is the order of a multiplicative subgroup of $GF(p)$, which is generated with the generator $g$ by $\{g\ mod\ p, g^2\ mod\ p, ..., g^{q-1}\ mod\ p, 1=g^q\ mod\ p\}$.

Without loss of generality, we assume the IdP assigns long-term identifiers $ID_U$ to a user and $ID_{RP}$ to an RP when they first register at the IdP. In particular, the IdP assigns a unique random number to each user as $ID_U$, where $1<ID_U<q$, and $ID_{RP}$ is a generator of order $q$ in $GF(p)$.% For each RP, the IdP selects a random number $r$, where $1 < r < q$, and computes a unique $ID_{RP}$ as:
%\begin{equation}
  %  ID_{RP} = g^{r} \bmod p
   %\label{equ:IDRP}
%\end{equation}
%\noindent where $r$ is kept secret from the RP.

\vspace{1mm}\noindent {\bf RP Identifier Transformation.} In each login session, the user negotiates with the RP she tries to log in, and computes a pseudo-identifier $PID_{RP}$ for the RP cooperatively. The user chooses a random number $N_{RP}$ ($1 < N_{RP}<q $), and RP provides the $ID_{RP}$ for user to calculate $PID_{RP}$ following Equation~\ref{equ:PIDRP}.
%First, the RP chooses a random number $N_{RP}$ ($1 < N_{RP}<q $), and the user chooses another random number $N_{U}$ ($1 < N_{U}<q $).
%Then, they exchange $N_{RP}$ and $N_{U}$ to calculate $PID_{RP}$ following Equation~\ref{equ:PIDRP}.
\begin{equation}
\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}: PID_{RP} = {ID_{RP}}^{N_{U}} \bmod p
\label{equ:PIDRP}
\end{equation}


The transformation function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ satisfies the following requirements. % described in Section~\ref{subsec:challenges}.
     %That is, the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ is invoked to generate $PID_{RP}$ for each login, while
First, it is computationally infeasible for the IdP to derive $ID_{RP}$ from $PID_{RP}$ due to the discrete logarithm problem. Moreover, the nonce $N_{U}$ ensures that: (\emph{a}) $PID_{RP}$ is valid only for this login and for the identity proof generated in this login, and (\emph{b}) $PID_{RP}$ is dynamically generated for this login and is different from other $PID_{RP}$s generated in other login session between the same user and RP. Therefore, the IdP cannot associate multiple $PID_{RP}$s of a same RP.
%wo nonces $N_{U}$ and $N_{RP}$ ensure that: (\emph{a}) $PID_{RP}$ is valid only for this login and for the identity proof generated in this login, and (\emph{b}) $PID_{RP}$ is dynamically generated for this login and is different from other $PID_{RP}$s generated in other login session between the same user and RP. Therefore, the IdP cannot associate multiple $PID_{RP}$s of a same RP. Finally, the cooperative generation process between the user and the RP prevents a single malicious entity from manipulating the value of $PID_{RP}$.
%For example, the malicious user fails to make a correct RP accept a $PID_{RP}$ used in another login, while the collusive RPs fail to use a same or correlated $PID_{RP}$s for different logins.


\vspace{1mm}\noindent {\bf User Identifier Transformation.} When the IdP receives an identity proof request for $ID_U$ and $PID_{RP}$ from an authenticated user, it follows the transformation function in Equation~\ref{equ:PIDU} to calculate $PID_U$ and includes it in the identity proof.
\begin{equation}
 \mathcal{F}_{ID_{U} \mapsto PID_{U}}: PID_U = {PID_{RP}}^{ID_U} \bmod p
 \label{equ:PIDU}
\end{equation}

% The function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ satisfies the requirements described in Section~\ref{subsec:challenges}.
From Equations%~\ref{equ:IDRP}, 
~\ref{equ:PIDRP} and~\ref{equ:PIDU}, we see that $PID_U = {ID_{RP}}^{N_UID_U} \bmod p$.
The discrete logarithm problem ensures that the RP cannot derive $ID_U$ from $PID_U$.

%Moreover, $ID_{RP}$ is generated following Equation~\ref{equ:IDRP} to introduce a random $r$ that is unknown to the RP, so that for a given $ID_U$, $PID_U$ is determined by $r$, $N_{U}$ and $N_{RP}$ together. Otherwise, if two collusive RPs know $r_1$ and $r_2$ respectively, they can check if ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds, which means a same user logs into them in two SSO sessions (i.e., $ID_{U_1}==ID_{U_2}$).

%Moreover, since $r$ is unknown to the RP, collusive RPs cannot link a user's $PID_U$s at different RPs. If $r$ is known to the RP, two collusive RPs might attempt to associate a user's $PID_U$s by checking whether the equality ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds or not, because ${PID_{U_1}} = g^{r_1N_{U_1}N_{RP_1}ID_{U_1}} \bmod p$ and ${PID_{U_2}} = g^{r_2N_{U_2}N_{RP_2}ID_{U_2}} \bmod p$.

\vspace{1mm}\noindent {\bf User Account Transformation.} The RP can derive a unique $Account$ for each user %with the function $\mathcal{F}_{PID_{U} \mapsto Account}$
following Equation~\ref{equ:Account}.
\begin{equation}
   \mathcal{F}_{PID_{U} \mapsto Account}: A = {PID_U}^{T} \bmod p
   \label{equ:Account}
   \end{equation}
Here, we define $T = N_U^{-1} \bmod q$ as the RP's trapdoor.
As $q$ is a prime number and $1< N_U < q$, $q$ is coprime to $N_U$. Also, there always exists a $T$ that satisfies $T N_U = 1 \bmod q$. Moreover, from Equations~\ref{equ:PIDRP}, \ref{equ:PIDU} and \ref{equ:Account}, we have $A = {ID_{RP}}^{ID_U} \bmod p$, derived as below.
\begin{multline}\label{equ:AccountNotChanged}
   A=  {PID_{U}}^{T} = {({PID_{RP}}^{ID_U})}^{{N_U^{-1} \bmod q}}\\
   = {ID_{RP}} ^ {ID_U N_U N_U^{-1} \bmod q} = {ID_{RP}}^{ID_U} \bmod p
\end{multline}

Therefore, when a user logins at an RP multiple times, the RP can always derives the same $Account$ to identity the user. Finally, the transformation function $\mathcal{F}_{PID_{U} \mapsto Account}$ satisfies the following requirements: %described in Section~\ref{subsec:challenges}.
(a) due to the discrete logarithm problem, the RP cannot derive $ID_U$ from $Account$, and (b) collusive RPs cannot link a user's $Account$s at different RPs.

These three identifier-transformation functions enable {\em transformed RP designation} and {\em trapdoor user identification} to satisfy all the security and privacy requirements of an SSO. %desirable for a secure and privacy-preserving SSO service.

\vspace{1mm}\noindent\textbf{Transformed RP Designation.} %is also supported with $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, together
    % with  a user-centric verification. 放入到后面写！这里只是谈ID transformation
$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ ensures that the user and RP cooperatively generate a fresh $PID_{RP}$ in each login,
 while $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ ensures that the IdP generates the exact $PID_U$ for the $ID_U$ who logins at $PID_{RP}$.
The IdP will bind $PID_{U}$ with $PID_{RP}$ in the identity proof, which designates this identity proof to $PID_{RP}$.
%Therefore, the $PID_{RP}$ is designated to $ID_{RP}$.
Finally, the transformed RP designation is provided through two phases.
The function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ prevents the curious IdP from linking $PID_{RP}$s of different logins at an RP, and therefore avoids IdP-based login tracing.

\vspace{1mm}\noindent\textbf{Trapdoor User Identification.} %is supported with these three functions.
In a user's multiple logins, the RP expresses different $PID_U$s and has the corresponding $T$s,
 so that derives the identical $Account$.
%$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$
The comprehensive design of identifier-transformation functions
 prevents collusive RPs from linking a user's $PID_U$s and $Account$s at different RPs, and therefore prevents RP-based identity linkage.




\subsection{UPPRESSO Overview}
\label{implementations}

The UPPRESSO system has four procedures, namely system initialization, RP initial registration, user registration, and SSO login.


\vspace{1mm}\noindent \textbf{System Initialization.} System initialization is conducted once by the IdP to establish the entire system. In particular, the IdP %chooses $L$,
generates a large prime $p$, and a prime factor $q$ of $p-1$
% and a generator $g$ of order $q$ 
 as the parameters of the discrete logarithm problem. %~\cite{gallagher2013digital}.
The IdP also generates one key pair ($SK$, $PK$) to sign identity proofs and RP certificates.
The lengths of $p$, $q$ and ($SK$, $PK$) should satisfy the required security strength. Then, the IdP keeps $SK$ secret, while announcing $p$, $q$ and $PK$ are public parameters.
%The values of $p$, $q$, $g$ remain the same during the full lifecycle of an SSO system.
%While, the asymmetric key pair ($SK$, $PK$) will be updated when necessary. For example, when $SK$ is leaked, IdP must update ($SK$,$PK$).

\vspace{1mm}\noindent\textbf{RP Initial Registration.} RP initial registration is launched by each RP to obtain the necessary configurations from the IdP, including a unique identifier $ID_{RP}$ and its corresponding RP certificate $Cert_{RP}$. %before it provides services for users, and
Each RP launches this procedure only once. In particular, an RP registers itself at the IdP and requests $ID_{RP}$ and $Cert_{RP}$ as follows:
\begin{itemize}
\item The RP sends a registration request to the IdP,
    including the RP endpoint (e.g., URL) to receive identity proofs.
\item The IdP generates the unique generator $ID_{RP}$,
%chooses a unique random number $r$ ($1 < r < q$), calculates $ID_{RP} = g^r \bmod p$,
signs $[ID_{RP}, Endpoint_{RP}, *]$ using $SK$, where $*$ denotes the supplementary information such as the RP's common name, and returns $Cert_{RP} = [ID_{RP}, Endpoint_{RP}, *]_{SK}$ to the RP, where $[\cdot]_{SK}$ means the message is signed using $SK$.
\item The RP verifies $Cert_{RP}$ using $PK$ and accepts $ID_{RP}$ and $Cert_{RP}$ if they are valid.
\end{itemize}


Note that, $ID_{RP}$ cannot be chosen by the RP. It must be generated by the IdP.% with $r$ unknown to the RP.

\vspace{1mm}\noindent\textbf{User registration.} UPPRESSO takes the same user registration process as other SSO systems to set up a unique user identifier $ID_U$ and the corresponding user credential. User registration is launched only once by each user. $ID_U$ can be chosen by either the user or the IdP, as long as it is unique for each user.

\vspace{1mm}\noindent\textbf{SSO Login.} Finally, an SSO login procedure will be launched when a user attempts to log into an RP. It is designed on top of the identifier-transformation functions.
%Once a user attempts to log into an RP, the SSO login is initiated.
%We use the OIDC implicit protocol flow as an example, to demonstrate  how to integrate the three functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the typical SSO systems.
As shown in Figure~\ref{fig:process}, the SSO login consists of five phases,
namely, scripts downloading, RP identifier transformation, $PID_{RP}$ registration, identity proof generation and $Account$ calculation. 
At the scripts downloading phase, browser firstly downloads the scripts from RP and IdP server.
In RP identifier transformation, the user and the RP negotiate $PID_{RP} = {ID_{RP}}^{N_{U}} \bmod p$.
Next, the user registers $PID_{RP}$ at the IdP. It is worth noting that this step has to be conducted by the user but not the RP. Otherwise, the IdP can associate $PID_{RP}$ and $ID_{RP}$. To register $PID_{RP}$, the user needs to create a new endpoint and submit it with $PID_{RP}$ to the IdP.
%To facilitate identifier transformations, a few more configurations are needed at the user end.
Then, the RP requests the identity proof, and the IdP calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ and signs the identity proof. Finally, in $Account$ calculation, the RP derives $A = {{PID_{U}}}^{{(N_U)^{-1} \bmod q}} \bmod p$ after verifying the identity proof and allows the user to log in under $Account$.

%In addition to the identifier-transformation functions, UPPRESSO needs to introduce more steps at the user.
%It is worth noting that in order to protect user privacy against both the IdP and the visited RP, these steps have to be conducted at the user. Firstly, because 
Moreover, as the IdP is unaware of the visited RP and also the RP's endpoint to receive the identity proof, this endpoint shall be queried by the user from the trusted IdP indirectly to ensure confidentiality; otherwise, an incorrect endpoint leaks the identity proofs.
In UPPRESSO this is implemented as an RP certificate signed by the IdP, which is composed of $ID_{RP}$, the RP's endpoint and other supplementary information. Then, the user determines the correct endpoint by itself, while in commonly-used OIDC systems, the endpoint is configured by the IdP.
%Secondly, we handle $PID_{RP}$ in two phases: it is registered at the trusted IdP with a one-time endpoint, and then $PID_{RP}$ is included in the identity proof as common identity proofs designated to the RP.
%Therefore, they are implemented as two phases compatible with OIDC.
%Moreover, after the negotiation of $PID_{RP}$, it is registered at the IdP by the authenticated user.
%This cannot be finished by the RP; otherwise, the IdP will associate $PID_{RP}$ and $ID_{RP}$.


%user-centric verification,  both the user and RP checks the uniqueness of $PID_{RP}$, while the user further checks that $PID_{RP}$ is exactly generated for the RP $ID_{RP}$,  and then sends the identity proof  only  to this RP.

\subsection{SSO Login Flow of UPPRESSO}
\label{sebsec:loginprocess}

We illustrate the steps of the SSO login protocol of UPPRESSO in Figure~\ref{fig:process}, %the SSO login sub-protocol provides the secure SSO service and prevents both the IdP-based login tracing and RP-based identity linkage.
 % prevents the curious IdP from obtaining the RP's identifying information during the interchanges,
%  and avoids the adversary to break the security and user's privacy.
and describe the detailed processes as follows.

\begin{figure*}
  \centering
  \includegraphics[width=0.68\linewidth]{fig/process-js.pdf}
  \caption{The flow of a user login in UPPRESSO.}
  \label{fig:process}
\end{figure*}

\vspace{1mm}\noindent\textbf{Scripts Downloading.}
At the beginning, the user downloads the scripts from RP server and IdP server as follows:\\

\begin{itemize}
\item[1.1] The user  visits the RP's script site and downloads the script.
\item[1.2] The script opens a new window in the browser visiting the login path at RP server.
\item[1.3] The visit to RP's login path is redirected to IdP's script.
\item[1.4] The new window visits  the IdP's script site and downloads the script.
\end{itemize}

\vspace{1mm}\noindent\textbf{RP Identifier Transformation.}
In this phase, the user and the RP cooperate to generate $PID_{RP}$ as follows:
\begin{itemize}
\item[2.1] The IdP script chooses a random number $N_U$ ($1 < N_U <q$) and sends it to RP script through postMessage, then RP script sends $N_U$ to RP server.
\item[2.2] The RP  verifies $N_{U} \neq 0 \bmod q$, calculates $PID_{RP}$ with $N_U$, derives the trapdoor $T={(N_U N_{RP})}^{-1} \bmod q$; and  acknowledges the negotiation by responding with $Cert_{RP}$. The $Cert_{RP}$ is transmitted from RP script to IdP script through postMessage.
\item[2.3] The IdP script verifies $Cert_{RP}$, extracts $ID_{RP}$ from the valid $Cert_{RP}$,  calculate $PID_{RP}={ID_{RP}}^{N_{U}} \bmod p$, creates a one-time endpoint to hide the RP's endpoint from the IdP and calculates $Nonce=Hash(N_U)$.


 % \item [1.1] The user sends a login request to trigger the negotiation of $PID_{RP}$.
%  \item [1.2] The RP chooses a random number $N_{RP}$ ($1 < N_{RP} <q$), calculates $Y_{RP}={ID_{RP}}^{N_{RP}} \bmod p$, % (Step 2.1.1);
%   and sends $Y_{RP}$ with $Cert_{RP}$  to the user. % (Step 2.1.2).
%  \item [1.3] The user verifies $Cert_{RP}$, extracts $ID_{RP}$ from the valid $Cert_{RP}$, chooses a random number $N_U$ ($1 < N_U <q$) to calculate $PID_{RP}={Y_{RP}}^{N_{U}} \bmod p$, and sends $N_U$ %with $PID_{RP}$
%       to the RP.
%  \item [1.4] The RP verifies $N_{U} \neq 0 \bmod q$, calculates $PID_{RP}$ with $N_U$ and $Y_{RP}$, %checks its consistency with the received one,
 %  derives the trapdoor $T={(N_U N_{RP})}^{-1} \bmod q$; and
%   acknowledges the negotiation by responding with $N_{RP}$.
 % \item [1.5] The user verifies that $N_{RP} \neq 0 \bmod q$ and $Y_{RP} = {ID_{RP}}^{N_{RP}} \bmod p$.
   %sends the calculated $PID_{RP}$ to the user (Step 2.1.6).
%  \item The user checks the consistency of the received $PID_{RP}$ with the stored one.
\end{itemize}

The user halts the negotiation, if  $Cert_{RP}$ is invalid.
%The verification of $Y_{RP}$ and $N_{RP}$ ensures the order of $Y_{RP}$ (and also $PID_{RP}$) is $q$,
  %  and prevents a malicious RP from choosing an arbitrary $Y_{RP}$ (then $PID_{RP}$) of order less than $q$,
    %    which makes it less difficult for the RP to derive $ID_U$ from $PID_U$.
 %or the received $PID_{RP}$ is different from the stored one. The RP also halts the process if the $PID_{RP}$ sent by the user is inconsistent with the calculated one.
%The user verifies that  \textcolor[rgb]{1.00,0.00,0.00}{$PID_{RP}$ is in the cyclic  group defined by $g$},
%$PID_{RP} \neq g^0 \bmod p$;
%    if $PID_{RP} = g^0 \bmod p$, $PID_U = {g}^{0*ID_U}$ is constant for all users.
%This case appears only if  $N_U = 0 \bmod q$ or $N_{RP} = 0 \bmod q$.

\vspace{1mm}\noindent\textbf{$\mathbf{PID_{RP}}$ Registration.}
The user registers $PID_{RP}$ at the IdP.
\begin{itemize}

\item[3.1] The IdP script sends the ${PID_{RP}}$ registration request $[PID_{RP}, Hash( N_U), Endpoint_U]$ to the IdP.
\item[3.2] The IdP verifies that $PID_{RP}$ is unique among unexpired $PID_{RP}$s,
    and then signs the response $[PID_{RP}, Hash( N_U), Validity]_{SK}$,
        where $Validity$ is the validity period.
\item[3.3] The IdP script forwards the registration result to the RP server through RP script.
\item[3.4] The RP verifies the IdP's signature, and accepts it only if $PID_{RP}$ and $Hash(N_U)$ match those in the negotiation and it is in the validity period.


 % \item [2.1] The user creates a one-time endpoint to hide the RP's endpoint from the IdP, and sends the ${PID_{RP}}$ registration request $[PID_{RP}, Hash(N_{RP}, N_U), Endpoint_U]$ to the IdP.
  %\item [2.2] The IdP authenticates the user if she has not been authenticated yet.
  %The IdP verifies that $PID_{RP}$ is unique among unexpired $PID_{RP}$s,
   % and then signs the response $[PID_{RP}, Hash(N_{RP}, N_U), Validity]_{SK}$,
      %  where $Validity$ is the validity period.
%The IdP returns the signed response to the user.
 % \item [2.3] The user forwards the registration result to the RP.
  %\item [2.4] The RP verifies the IdP's signature, and accepts it only if $PID_{RP}$ and $Hash(N_{RP}, N_U)$ match those in the negotiation and it is in the validity period.
\end{itemize}

%If $RegRes$ is $OK$, the RP identifier refreshing completes. Otherwise, the user and RP will renegotiate the $PID_{RP}$.
$Hash(N_U)$ is attached as the nonce to avoid the registration result is accepted by two or more RPs,
 which have different $ID_{RP}$s but generate a same $PID_{RP}$.  % with a negligible possibility.
The IdP ensures $PID_{RP}$ is unique among unexpired ones;
 otherwise, one identity proof for one $PID_{RP}$ might be accepted by other RPs.
%The RP checks if Hash($N_{RP}$, $N_U$) matches,
%    to ensure this is signed for it (not for other RPs).
More details are analyzed in Section~\ref{sec:analysis}.

\vspace{1mm}\noindent\textbf{ID Proof Generation.}
In this phase, the user login continues and the IdP signs the identity proof. % The processes are as follows.
\begin{itemize}
\item[4.1] The RP uses $PID_{RP}$ and $Endpoint_{RP}$ to construct an identity proof request for a set of user's attributes, and the request is forwarded to IdP script through RP script.
\item[4.2] The IdP authenticates the user if she has not been authenticated yet. 
 \item[4.3] The user first confirms the scope of the requested attributes. IdP script verifies the $PID_{RP}$ with the negotiated one and $Endpoint_{RP} \in Cert_{RP}$, replaces the endpoint with the registered one-time $Endpoint_U$ and then sends the modified identity proof request to the IdP server.
 \item [4.4] The IdP verifies whether $PID_{RP}$ and $Endpoint_U$ have been registered and unexpired, and
   calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ for the authenticated user.
\item[4.5] The IdP constructs and signs the identity proof $[PID_{RP}, PID_U, Iss, ValTime, Attr]_{SK}$, where $Iss$ is the identifier of the IdP,  $ValTime$ is the validity period, $Attr$ contains the requested attributes. 
\item[4.6]Then, the IdP sends the identity proof to the one-time endpoint at the user. The IdP script forwards the identity proof to RP script with the origin $Endpoint_{RP}$ and RP script sends it to the server.

%  \item [3.1] The RP uses $PID_{RP}$ and $Endpoint_{RP}$ to construct an identity proof request for a set of user's attributes.  %, which is the same as the one in  OIDC.

 %\item [3.2] The user first confirms the scope of the requested attributes and verifies $PID_{RP}$ with the negotiated one. The user replaces the endpoint with the registered one-time $Endpoint_U$, and sends the modified identity proof request to the IdP.
%  \item [3.3] The IdP verifies whether $PID_{RP}$ and $Endpoint_U$ have been registered and unexpired, and
%   calculates $PID_U = {PID_{RP}}^{ID_U} \bmod p$ for the authenticated user.
%\item [3.4] The IdP constructs and signs the identity proof $[PID_{RP}, PID_U, Iss, ValTime, Attr]_{SK}$, where $Iss$ is the identifier of the IdP,  $ValTime$ is the validity period, $Attr$ contains the requested attributes. Then, the IdP sends the identity proof to the one-time endpoint at the user.
%  \item [3.5] The user extracts the RP endpoint in $Cert_{RP}$,
  % and forwards the identity proof to the RP through this endpoint.
\end{itemize}

The user halts the process if $PID_{RP}$ in the identity proof request is inconsistent with  the negotiated one.
The IdP rejects the identity proof request, if the pair of $PID_{RP}$ and $Endpoint_U$ has not been registered.


\vspace{1mm}\noindent\textbf{$\mathbf{Account}$ calculation.}
Finally, RP derives the user's  $Account$ and completes the user login as follows.
\begin{itemize}
\item[5.1]
The RP verifies the identity proof, including the signature, validity period, and the consistency between $PID_{RP}$ and the negotiated one. If any fails, the RP rejects this login.
\item [5.2] The RP extracts $PID_U$, calculates $Accout = {PID_U}^T \bmod p$, and allows the user to log in.
\end{itemize}
%
%\begin{figure}[t]
%  \centering
%  \includegraphics[width=\linewidth]{fig/overview1.pdf}
%  \caption{UPPRESSO compatibility with OIDC.}
%  \label{fig:UPPRESSO}
%\end{figure}
%

\subsection{Compatibility with OIDC}
\label{subsec:compatible}

As described above, the SSO login protocol of UPPRESSO follows a same logic flow of OIDC login protocol with small modifications to transform the identifiers. Next, we will discuss these necessary modifications and demonstrate its compatibility with OIDC. This indicates that it can be easily integrated with other commonly adopted SSO systems.

First, UPPRESSO does not introduce any new role nor change the security assumptions for each role. %(i.e., user, IdP and RP).
Moreover, among the five phases of its SSO login flow, only the scripts downloading and RP identifier transformation phase are newly introduced by UPPRESSO, while the other three ($PID_{RP}$ registration, identity proof generation and $Account$ calculation) adopt similar communication pattern as OIDC flows.

In particular, the $PID_{RP}$ registration phase can be viewed as a variant of the RP dynamic registration flow of OIDC~\cite{DynamicRegistration}, where an entity registers its identity and endpoint at the IdP. The RP endpoint is the required parameter for dynamic registration, therefore, here we add the $Endpoint_U$ to meet the requirement of registration process. Different from OIDC, in UPPRESSO, this process can be launched by any authenticated user who obtains an RP identifier, the registration response includes a signature by the IdP, and the registration will become invalid after a validity period. However, these changes only require small modifications to the RP dynamic registration flow of OIDC.
%These differences (i.e., the RP identifier not provided by the IdP, the registration response signed by the IdP, and the automatically-expired registration) bring very small modifications.

The identity proof generation and $Account$ calculation phases adopt the same steps and functions as the implicit protocol flow of OIDC but calling a few different parameters. First, in identity proof generation, $PID_U$ transformed from $ID_U$ is used to replace $ID_U$, which is directly supported by OIDC, similar as in PPID approaches that also convert $ID_U$ into $PID_U$. The calculation of $Account$ from $PID_U$ %bound in the identity proof,
can be viewed as a customized step by the RP to derive its user account after the implicit protocol flow of OIDC ends. 
%Another modification is the replacement of endpoint by the user for transmitting the identity proof to the RP.
%In fact, this message forwarding is common when an application-layer network proxy is deployed. 
So,the identity proof generation and $Account$ calculation phases of UPPRESSO can be viewed as a particular but compatible implementation of the implicit protocol flow of OIDC.

It is worth noting that the identity proof generation and $Account$ calculation phases of UPPRESSO can be also implemented as the authorization code flow of OIDC with small modifications, which will be discussed in Section \ref{sec:discussion}.

%As shown in Figure~\ref{fig:process}, in UPPRESSO, the SSO protocol for identity proof is the same as in OIDC; the formats of identity proof and corresponding request are the same as in OIDC; the correctness checks on the identity proof request at the IdP (i.e., consistency of RP' identifier and endpoint with the registered one) are the same as in OIDC; the correctness checks on the identity proof (i.e., consistency of RP' identifier with the one in the request, integrity, validity time, freshness, and etc.) at the RP are the same as in OIDC.
%The above modifications could be completed automatically for each login, without affecting other communication pattern.

%以下为描述Step 2.3到7的详细内容.
%That is, the RP construct a request for identity proof (Step 2.3); the user redirects this request to the IdP (Step 2.5); the IdP generates the identity proof (Step 4), and sends it to the user (Step 5.1) who redirects it to the RP (Step 5.3); and finally the RP verifies the identity proof (Step 6).

%However, UPPRESSO achieves privacy preservation by integrating  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, and  introduces the following modifications on OIDC.

%\begin{enumerate}
%  \item The identity proof is bound with $PID_{RP}$ instead of $ID_{RP}$, which introduces the RP identifier transforming (Steps 1.2-1.5)  and $PID_{RP}$ registration (Steps 2.1-2.4).
%  \item The identity proof is designated to one-time endpoint instead of RP's identifying endpoint, which requires the user to register the one-time endpoint in Step 2.1 and replace it with the original endpoint in Step 3.2.
%  \item IdP generates $PID_U$ based on ($PID_{RP}$, $ID_U$) instead of ($ID_{RP}$, $ID_U$).
%  \item The RP calculates $Account$ from the changing $PID_U$ instead of an unchanged one.
%\end{enumerate}

%上述modification如何实现的，简单描述
%to add: PID_{RP} transforming 和 RP identifer refreshing在user和RP的页面自己完成了。 都用现成的数据格式
%one-time endpoint 和endpoint
%The user automatically invokes the JavaScript functions to complete RP identifier transforming, one-time endpoint generating/replacing and $PID_{RP}$ registration for each login.
%While, the RP server and IdP server provide the corresponding web service to complete the processing automatically.

%The protocol of RP identifier transformation is based Diffie-Hellman key exchange~\cite{DiffieH76}, while $N_U$ is provided to RP for computing the trapdoor and $N_{RP}$ is provided to the user for verifying the correctness of $Y_{RP}$.

\begin{comment}
\vspace{1mm}\noindent \textbf{Consistency with OIDC.}
As shown in Figure~\ref{fig:UPPRESSO}, the architecture of UPPRESSO is the same as the one in OIDC. UPPRESSO does not introduce any new entity, but only integrates the three function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the processes at the IdP, RP, and user.

The formats of the  identity proof and corresponding request, and the verification of the identity proof,  are almost same in OIDC and UPPRESSO.
The only difference is that $ID_{RP}$ and endpoint are replaced with the privacy-preserving versions, i.e., $PID_{RP}$ and one-time endpoint, in UPPRESSO.
As $PID_{RP}$ is also unique and corresponds exactly to $ID_{RP}$, and one-time endpoint corresponds to the RP's endpoint correctly,
 the binding, integrity and confidentiality of identity proof will also be ensured in UPPRESSO, and there is no degradation on the security of OIDC.

\vspace{1mm}\noindent \textbf{Minimal modification to OIDC.}
UPPRESSO only requires small modification on OIDC to integrate $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$.
For $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, we directly use them to replace original functions for $PPID$ at the IdP and the $Account$ at the RP.
For $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$, we inject a negotiation process and a dynamic registration for each SSO login,
 where the negotiation process between the user and RP generates a $PID_{RP}$,
  while the dynamic registration is used to check the uniqueness of $PID_{RP}$.
In UPPRESSO, the dynamic registration is slightly modified as follows: an RP identifer ($PID_{RP}$)  is added in the request, and a signature ($Sig_{Res}$)  is included in the response for its verification at the RP.
\end{comment}




