%After we conceptualize the privacy problem into an identifier-transformation problem, the design of UPPRESSO is mainly about designing three identifier-transformation functions to generate pseudo-identities for the user and RP as well as linking the user's pseudo-identity to her account at an RP. In this section, we first present our design of these three functions to support {\em transformed RP designation} and {\em trapdoor user identification} properties, and then describe the details of the UPPRESSO system and its login flow.
%Finally, we discuss the compatibility of UPPRESSO with OIDC.


\subsection{Identity-Transformation Functions}
\label{subsec:overview}

We design three identity-transformation functions,
     $\mathcal{F}_{PID_{RP}}$, $\mathcal{F}_{PID_{U}}$ and $\mathcal{F}_{Acct}$,
    on an elliptic curve $\mathbb{E}$.
 %    where $G$ is a base point (or generator) of this elliptic curve and the order of $G$ is a big prime number denoted as $n$.
Table \ref{tbl:notations-protocol} lists the notations,
    and the subscript $j$ and/or the superscript $i$ may be omitted in the case of no ambiguity.

%the NIST elliptic curve $P$-256,
%the discrete logarithm problem with public parameters $p$, $q$, %and $g$, %% L不作为参数，我们说：e, n是RSA算法参数，不说2048是参数。
%$q$ is a large prime defining the finite field $\mathbb{F}_q$,
% $L$ is the length of $q$ in bits,  ($2^{L-1} < q < 2^L$)
%, and $g$ is a generator of order $q$ in $GF(p)$.
%the prime number $q$  is the order of a multiplicative subgroup of $GF(p)$, which is generated with the generator $g$ by $\{g\ mod\ p, g^2\ mod\ p, ..., g^{q-1}\ mod\ p, 1=g^q\ mod\ p\}$.

\begin{table}[tb]
\footnotesize
    \caption{The notations in the UPPRESSO protocols.}
    \centering
%    \begin{tabular}{|c|c|c|}
    \begin{tabular}{|p{1.0cm}|p{6.60cm}|} \hline
    {\textbf{Notation}} & {\textbf{Description}} \\ \hline
    {$\mathbb{E}$} & {An elliptic curve over a finite field $\mathbb{F}_q$.} \\ \hline
    {$G$, $n$}&{A base point (or generator) of $\mathbb{E}$, where the order of $G$ is a prime number $n$.} \\ \hline
%    {$q$} & {A large prime, the size of the underlying field.} \\ \hline
%    {$n$} & {the order of the base point $G$.} \\ \hline
    {$ID_U$} & {$ID_U = u$, $1 < u < n$; the user's unique identity at the IdP.} \\ \hline
   {$ID_{RP_j}$} & {$ID_{RP} = [r]G$, $1 < r < n$; the $j$-th RP's unique identity.} \\ \hline
    {$t$} & {The user-generated random integer in a login instance, $1 < t < n$.} \\ \hline
    {$PID_{RP_j}^i$} & {$PID_{RP} = [t]{ID_{RP}} = [tr]G$; the $j$-th RP's pseudo-identity, in the user's $i$-th login instance to this RP.} \\ \hline
    {$PID_{U,j}^i$} & {$PID_U = [{ID_U}]{PID_{RP}} = [utr]G$; the user's pseudo-identity, in the user's $i$-th login instance to the $j$-th RP.} \\ \hline
     {$Acct_j$} & {$Acct = [t^{-1}\bmod n]PID_{U} = [ID_U]ID_{RP} = [ur]G$; the user's account at the $j$-th RP.} \\ \hline
    {$SK$, $PK$} & {The IdP's key pair, a private key and a public key, to sign and verify identity tokens and RP certificates.} \\ \hline
%    {$T$} & {The trapdoor to derive $Account$: $T=N_U^{-1} \bmod n$.} \\ \hline
    {$Enpt_{RP_j}$} & {The $j$-th RP's endpoint, to receive the identity tokens.} \\ \hline
    {$Cert_{RP_j}$} & {A signed RP certificate, binding $ID_{RP_j}$ and $Enpt_{RP_j}$.} \\ \hline
%    {$PEnpt_{U,j}^i$} & {A user-generated random "pseudo-endpoint'', in the user's $i$-th login instance to the $j$-th RP.} \\ \hline
    \end{tabular}
    \label{tbl:notations-protocol}
\end{table}


%$ID_U$ is an integer satisfying $1<ID_U<n$,
%    and $ID_{RP}$ is a unique point on $\mathbb{E}$.
When a user is registering,
            a unique integer $u$ $(1 < u < n)$ is generated and $ID_U = u$ is assigned to this user.
When an RP is registering,
            a random number $r$ $(1 < r < n)$ is generated by the IdP, and $ID_{RP} = [r]G$, a unique point on $\mathbb{E}$, is assigned to this RP.
Here, $[r]G$ is the addition of $G$ on the curve $r$ times.
% For each RP, the IdP selects a random number $r$, where $1 < r < q$, and computes a unique $ID_{RP}$ as:
%\begin{equation}
  %  ID_{RP} = g^{r} \bmod p
   %\label{equ:IDRP}
%\end{equation}
%\noindent where $r$ is kept secret from the RP.

\vspace{1mm}
\noindent {\bf $\boldsymbol{ID_{\boldsymbol{RP}}}$-$\boldsymbol{PID_{\boldsymbol{RP}}}$ Transformation.} The user selects a random number $t$ ($1 < t <n$) as the trapdoor
         and calculates $PID_{RP}$.
%First, the RP chooses a random number $N_{RP}$ ($1 < N_{RP}<q $), and the user chooses another random number $N_{U}$ ($1 < N_{U}<q $).
%Then, they exchange $N_{RP}$ and $N_{U}$ to calculate $PID_{RP}$ following Equation \ref{equ:PIDRP}.
\begin{equation}
PID_{RP} = \mathcal{F}_{PID_{RP}}(ID_{RP}) = [t]{ID_{RP}} = [tr]G
\label{equ:PIDRP}
\end{equation}
%is a one-way function so that it

%wo nonces $N_{U}$ and $N_{RP}$ ensure that: (\emph{a}) $PID_{RP}$ is valid only for this login and for the identity token generated in this login, and (\emph{b}) $PID_{RP}$ is dynamically generated for this login and is different from other $PID_{RP}$s generated in other login session between the same user and RP. Therefore, the IdP cannot associate multiple $PID_{RP}$s of a same RP. Finally, the cooperative generation process between the user and the RP prevents a single malicious entity from manipulating the value of $PID_{RP}$.
%For example, the malicious user fails to make a correct RP accept a $PID_{RP}$ used in another login, while the collusive RPs fail to use a same or correlated $PID_{RP}$s for different logins.


\noindent {\bf $\boldsymbol{ID_U}$-$\boldsymbol{PID_U}$ Transformation.}
%Now, the identity token-request to the IdP contains a user identity $ID_U$ and a pseudo-identity of the RP $PID_{RP}$. Therefore,
On receiving an identity-token request with $ID_U$ and $PID_{RP}$,
    the IdP calculates $PID_{U}$.
\begin{equation}
 PID_{U} = \mathcal{F}_{PID_U}(ID_U, PID_{RP}) = [{ID_U}]{PID_{RP}} = [utr]G
 \label{equ:PIDU}
\end{equation}

%From Equations% \ref{equ:IDRP},
% \ref{equ:PIDRP} and \ref{equ:PIDU}, we see that $PID_U = ({N_UID_U} \bmod n) \cdot {ID_{RP}}$. So, $PID_U$ is a one-time pseudo-identity. It is only valid in one login session and one identity token.
%As expected, the RP cannot derive $ID_U$ from $PID_U$ due to the discrete logarithm problem, but it can associate a user's one-time pseudo-identity ($PID_U$) registered at the IdP with her long-term identifier registered at the RP (i.e., $Account$).

%Moreover, although the IdP does not know how the RP identifies the user (i.e. the user's $Account$ at the RP), involving $PID_{RP}$ in the generation of $PID_U$ indirectly links a user's one-time pseudo-identity at the IdP ($PID_U$) to her long-term identifier at the RP ($Account$) through a trapdoor.

%Moreover, $ID_{RP}$ is generated following Equation \ref{equ:IDRP} to introduce a random $r$ that is unknown to the RP, so that for a given $ID_U$, $PID_U$ is determined by $r$, $N_{U}$ and $N_{RP}$ together. Otherwise, if two collusive RPs know $r_1$ and $r_2$ respectively, they can check if ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds, which means a same user logs into them in two SSO sessions (i.e., $ID_{U_1}==ID_{U_2}$).

%Moreover, since $r$ is unknown to the RP, collusive RPs cannot link a user's $PID_U$s at different RPs. If $r$ is known to the RP, two collusive RPs might attempt to associate a user's $PID_U$s by checking whether the equality ${PID_{U_1}}^{r_2N_{U_2}N_{RP_2}} = {PID_{U_2}}^{r_1N_{U_1}N_{RP_1}} \bmod\ p$ holds or not, because ${PID_{U_1}} = g^{r_1N_{U_1}N_{RP_1}ID_{U_1}} \bmod p$ and ${PID_{U_2}} = g^{r_2N_{U_2}N_{RP_2}ID_{U_2}} \bmod p$.

\noindent {\bf $\boldsymbol{PID_U}$-$\boldsymbol{Acct}$ Transformation.}
The user sends the trapdoor $t$ to the target RP,
which calculates $PID_{RP}$ to verify the RP pseudo-identity designated in identity tokens.
On verifying a token binding $PID_U$ and $PID_{RP}$,
    it calculates $Acct$ as below.
\begin{equation}
   Acct = \mathcal{F}_{Acct}(PID_{U}, PID_{RP}) = [t^{-1} \bmod n]PID_{U}
   \label{equ:Account}
\end{equation}

From Equations \ref{equ:PIDRP}, \ref{equ:PIDU} and \ref{equ:Account}, it is derived that
%\begin{multline}\label{equ:AccountNotChanged}
%   A =  {PID_{U}}^{T}
%   = {({PID_{RP}}^{ID_U})}^{{N_U^{-1} \bmod q}} \\
%   = {ID_{RP}} ^ {ID_U N_U N_U^{-1} \bmod q}
%   = {ID_{RP}}^{ID_U} \bmod p
%\end{multline}
\begin{equation*}
   Acct =  [t^{-1}utr \bmod n]G = [ur]G = [ID_U]ID_{RP}
   \label{equ:AccountNotChanged}
\end{equation*}
The RP derives the \emph{identical permanent account} from different identity tokens in multiple login instances,
    with the help of $t$ from the user.
Given a user, the accounts at different RPs are inherently unique;
while, given an RP, the accounts of different users are also inherently unique.
Moreover,
    due to the elliptic curve discrete logarithm problem (ECDLP),
it is impossible for the RP to derive $ID_U$ from either $PID_U$ or $Acct$,
    and for the IdP to derive $ID_{RP}$ from $PID_{RP}$.
Section \ref{sec:analysis} presents the detailed proofs.



\subsection{The Designs Specific for Web Applications}
The designs specific for web applications,
enable UPPRESSO to work with commercial-off-the-shelf (COTS) browsers.
%More efficient but less portable implementations with browser extensions %and/or plug-ins
% are discussed in Section \ref{sec:discussion}.
%If a user visits the IdP and RPs through a client software,
%        the specific designs become unnecessary and the performance will be improved.
%
First of all, in UPPRESSO the IdP is not aware of the visited RP,
 so the user agents (or browsers) have to deal with the forwarding of identity tokens
    to the target RP, as well as the identity transformations.
On the contrary,
    in commonly-used SSO protocols the IdP needs this information to ensure confidentiality of identity tokens.
In the OIDC services, when an RP registers itself at the IdP, the \verb+redirect_uri+ parameter
    is set as the endpoint URL to receive tokens  \cite{OpenIDConnect}.
Then, %in an OIDC login instance,
 when the IdP wants to transmit identity tokens to an RP,
    it utilizes HTTP 302 redirection with this endpoint as the target URL in the HTTP response,
     so the user browser forwards it to the RP.
%This verified \verb+redirect_uri+  ensures the token is sent to the target RP.
   % which is designated in the token,
%and prevents attackers from intercepting it.

In UPPRESSO such functions of a user agent are implemented by web scripts within browsers.
Section \ref{sec:discussion} discusses more efficient but less portable implementations with browser extensions.
Two scripts downloaded from the visited RP and the IdP, respectively,
    and each is responsible for the communications with the origin web server.
Only the RP script is not enough to implement the user agent;
    otherwise, the script will leaks its origin to the IdP web server
    (e.g., if it requests the identity token,
    an HTTP request launched by the RP script will
automatically carry an HTTP \verb+referer+ header, which discloses the RP domain).
Moreover, a script from the honest IdP
ensures confidentiality of identity tokens (i.e., it is sent to only the designated RP)
and interacts with the user for the authorization of user attributes,
    for the RP might be malicious.

The RP script prepares $ID_{RP}$ and $Enpt_{RP}$ for the IdP script, through RP certificates.
An RP certificate is signed by the IdP during the RP registration,
     binding the RP's identity and its endpoint. % (i.e., $ID_{RP}$ and $Enpt_{RP}$).
In a login instance
    the RP will provide its certificate through the RP script, to the IdP script.
The IdP script %from the honest IdP,
    verifies the RP certificate to extract $ID_{RP}$ and $Enpt_{RP}$.
The IdP's public key is set in the IdP script, so 
 a user agent does not configure anything locally,
    as it does in popular SSO systems.

%Thus, to avoid the IdP server obtaining any evidence about the RP's identity and provide IdP's script with the RP certificate, the RP's script is also required to transmit the certificate to IdP script after it is downloaded from IdP server.

%As the server and its script would only communicate with each other based on HTTPS channel, the adversary cannot steal the identity token in such ways.
%However, while the IdP sends the identity token to RP, the identity token would be transmitted from IdP script to RP script during the SSO flow, that should be well protected with the RP certificate.
After using the extracted $ID_{RP}$ in identity transformations
    and receiving an identity token from the IdP,
    the IdP script needs to ensure the RP script will forward this token to $Enpt_{RP}$,
        which is bound with $ID_{RP}$ in the RP certificate.
The scripts communicate with each other within the browser through the \verb+postMessage+ HTML5 API,
%To avoid the honest user sending the identity token to an adversary,
and the receiver (i.e., the RP script)
 is restricted by the \verb+postMessage+ targetOrigin mechanism \cite{postm-targeto}.
When the IdP script sends identity tokens,
 the receiver's origin is set as a parameter, e.g., \verb+window.opener.postMessage(tkn, 'https://RP.com')+,
  so only a script from this origin is a legal receiver.
An origin parameter consists of
    the protocol (i.e., \verb+https://+),
    the domain  (i.e., \verb+RP.com+)
    and a port which may be implicit.
%The \emph{RP certificates} deals with the problem of mapping an identity proof with its targeting RP.
%That is, the IdP script derives the RP's $ID_{RP}$ and origin from the RP certificate, while the $PID_{RP}$ is generated with this $ID_{RP}$. Thus, the IdP script always know the targeting RP of an identity proof, therefore, the \verb+postMessage+ mechanism can guarantee that the identity proof would not be sent to the adversary.

Finally,
    the browser downloads the RP script when visiting an RP,
     and this RP script opens a new window that downloads the IdP script.
We shall prevent the referer leakage when the IdP script is downloaded.
Generally, when a browser window visits another website not belonging to its opener's origin,
 the HTTP request to this website automatically carries the \verb+referer+ header (i.e., the opener's origin).
This HTTP header leaks the visited RP's domain to the IdP.
Fortunately, in UPPRESSO this newly-opened window is a redirection from the RP to the IdP,
 but not a direct visit by the browser (Figure \ref{fig:process}, Steps 1.2-1.3).
This leakage is prevented by setting the header \verb+referrer-policy=no-referrer+ in the HTTP response from the RP, when it is redirected to the IdP.
Then the HTTP request to download the IdP script carries no \verb+referer+ header.
This setting is specified by W3C \cite{referer_policy} and widely supported.
We tested it in popular browsers including Chrome, Safari, Edge, Opera and Firefox, and confirmed no referer leakage.




%in the SSO login flow,
 %   the user has to deal with RP endpoints (i.e., the URLs to receive identity tokens) by himself.
%In existing SSO protocols,
 %   an RP initially registers its endpoint at the IdP,
  %      and then in each login instance, the IdP will set this endpoint in the identity-token response.
%This instructs the user browser to forward it correctly;
  %  otherwise, confidentiality of identity tokens might be broken.
%In UPPRESSO the IdP is not aware of the visited RP and cannot set the endpoints,
 %       so \emph{RP certificates} are designed to instruct the user agents (or browsers) about
  %          the RP endpoint of an RP.
%An RP certificate is a document signed by the IdP during the RP initial registration,
  %   binding the RP's identity and its endpoint.
%This attribute certificate is sent by the RP in the login flow,
  %  so a user forwards identity tokens to the verified endpoint.









%However, in such system, the scripts is used to communicate between RP and IdP servers instead of HTTP URL redirection.
%The two scripts communicates with each other within the user browser through the standard \verb+postMessage+ HTML5 API.

%This mechanism can achieve the same security goal as the \verb+redirect_uri+ mechanism\cite{ChenPCTKT14} in OIDC systems.

%The RP script maintains the communications with the RP,
%    and it does not communicates directly with the IdP because an HTTP request launched by the RP script
%            will automatically carry an HTTP \verb+Referer+ header, which discloses the RP's domain.
%The IdP script downloaded from the IdP,
%    is responsible for the communications with the IdP,
%    and two scripts communicates with each other within the user browser through the standard \verb+postMessage+ HTML5 API.



\subsection{The UPPRESSO Protocols}
\label{implementations}

\begin{figure*}[bt]
  \centering
  \includegraphics[height=0.58\textheight]{fig/process-js.pdf}
  \caption{The SSO login flow of UPPRESSO.}
  \label{fig:process}
\end{figure*}


\noindent \textbf{System Initialization.}
The IdP generates a key pair ($SK$, $PK$) to sign/verify identity tokens and RP certificates.
The IdP keeps $SK$ secret, while $PK$ is publicly known.


\vspace{1mm}
\noindent\textbf{RP Initial Registration.}
%Each RP launches an initial registration operation to finish configurations.
Each RP registers itself at the IdP to obtain $ID_{RP}$
 and its RP certificate $Cert_{RP}$ as follows:
\vspace{-\topsep}\begin{enumerate}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parskip}{0pt}
\item
An RP sends a registration request, including the endpoint to receive identity tokens
    and other information.
\item
The IdP generates a unique random number $r \in [1,n)$, and assigns $ID_{RP} = [r]G$ to the RP.
The IdP signs $Cert_{RP} = [ID_{RP}, Enpt_{RP}, *]_{SK}$,
     where $[\cdot]_{SK}$ means a message signed using $SK$ and $*$ denotes supplementary information such as the RP's common name and Email,
\item
The RP verifies $Cert_{RP}$ using $PK$,
    and accepts $ID_{RP}$ and $Cert_{RP}$ if they are valid.
\end{enumerate}

%Note that $ID_{RP}$ is generated by the IdP but not chosen by the RP;
%otherwise, a malicious RP might choose $ID_{RP}$ which reduces the difficulty to solve the ECDLP
%    (i.e., it is possible for the RP to derive $ID_U$ from $Acct = [ID_U]{ID_{RP}}$
%        or at least some information about $ID_U$).
%%%%%%%%%% 因为E上面的点，构成循环群、当n是素数的时候。所以，不会形成攻击。

%\vspace{1mm}
\noindent\textbf{User Registration.}
Each user registers once at the IdP to set up a unique identity $ID_U$ and the corresponding credential.
%This is similar to the steps in existing SSO systems.


\vspace{1mm}
\noindent\textbf{SSO Login.} A login instance %is typically launched through a browser,
%when a user attempts to visit an RP. It 
consists of four steps, namely script downloading, RP identity transformation,
identity-token generation, and $Acct$ calculation, as shown in Figure \ref{fig:process}.
In this figure,
    the operations by the IdP are linked by a vertical line,
        so are the RP's.
Two vertical lines split the user operations into two groups (i.e., in two browser windows),
    one of which is to communicate with the IdP,
                 and the other with the target RP.
Each solid horizontal line means some messages between the user and the IdP (or the RP),
            and each dotted line means a \verb+postMessage+ invocation between two scripts (or browser windows) within the user browser.

%In this figure, vertical bars stand for entity in the UPPRESSO system.
%At the user side, the vertical bars represent the browser's windows which are the containers of IdP and RP scripts.
%After a window is opened, the script in this window may change.
%For example, a window is opened at Step 1.2, and the script in this window belongs to the RP.
%However, after the redirection at Step 1.3, it visits the IdP server and downloads the script,
% so that the script inside this window changes into the IdP script.
%The main difference is that,
% the IdP script is only trusted by IdP server and allowed to communicate with IdP server.
% So does the RP script.

%%%, which calls three identifier-transformation functions following the login flow as shown in Figure \ref{fig:process}.
%%%Once a user attempts to login an RP, the SSO login is initiated.
%%%We use the OIDC implicit protocol flow as an example, to demonstrate  how to integrate the three functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ into the typical SSO systems.

%\vspace{1mm}
\noindent 1. {\em Script Downloading.}
The browser downloads the scripts from the visited RP and the IdP.
\vspace{-\topsep}\begin{itemize}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parskip}{0pt}
\item[1.1]
When attempting to visit any protected resources at the RP,
    the user downloads the RP script.
\item[1.2]
The RP script opens a window in the browser to visit the login path at the RP, which is then redirected to the IdP.
\item[1.3]
The redirection to the IdP downloads the IdP script.
\end{itemize}



%\vspace{1mm}
\noindent 2. {\em RP Identity Transformation.}
The user and the RP negotiate $PID_{RP} = [t]{ID_{RP}}$.
\vspace{-\topsep}\begin{itemize}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parskip}{0pt}
\item[2.1] The IdP script chooses a random number $t$ ($1 < t <n$) and sends it to the RP script through \verb+postMessage+.
Then, the RP script sends $t$ to the RP.
\item[2.2] On receiving $t$,
the RP verifies $1 < t < n$ and calculates $PID_{RP}$.
%To acknowledge the negotiation of $PID_{RP}$,
The RP replies with $Cert_{RP}$, which is then transmitted from the RP script to the IdP script,
    as well as the scope of requested user attributes.  % through \verb+postMessage+.
\item[2.3] The IdP script verifies $Cert_{RP}$, extracts $ID_{RP}$ and $Enpt_{RP}$ from $Cert_{RP}$ and calculates $PID_{RP}=[t]{ID_{RP}}$.
%It then creates a random endpoint $PEnpt_{U}$ for this login instance,
 %   to receive identity tokens from the IdP.
    % as the RP endpoint required by IdP.我们已经修改了协议，IdP并不require什么

\end{itemize}


%\vspace{1mm}
\noindent 3. {\em Identity-Token Generation.}
The IdP calculates $PID_U = [ID_U]{PID_{RP}}$ and signs the identity token. % The processes are as follows.
\vspace{-\topsep}\begin{itemize}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parskip}{0pt}
\item[3.1]
%The IdP script checks that $PID_{RP}$ is the one registered in Step 3.1
%            and $Enpt_{RP}$ matches the one in $Cert_{RP}$.
%Then, it %replaces $Enpt_{RP}$ with $PEnpt_{U}$ in the identity-token request and
The IdP script requests an identity token for $PID_{RP}$ and the user attributes.
 %by checking whether this user is authenticated by IdP.

\item[3.2] The IdP authenticates the user if he has not been authenticated yet.

\item [3.3]
After obtaining the user's authorization to enclose the requested attributes,
the IdP checks whether the received $PID_{RP}$ is valid,
%pair of $PID_{RPs}$ and $PEnpt_Us$ is in the list of unexpired $PID_{RP}$,
    and calculates $PID_U = [ID_U]{PID_{RP}}$ for the authenticated user.
The IdP then signs an identity token $[PID_{RP}, PID_U, Issuer, Validity, Attr]_{SK}$,
 where $Issuer$ is the IdP's identity, $Validity$ indicates the validity period, and $Attr$ contains the requested attributes.
\item[3.4] The IdP replies with the identity token.
\end{itemize}

%\vspace{1mm}
\noindent 4. {\em $Acct$ Calculation.}
The RP receives the identity token and allows the user to login.
\vspace{-\topsep}\begin{itemize}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\setlength{\parskip}{0pt}
\item [4.1]
The IdP script forwards the identity token to the RP script,
    which then sends it to the RP through $Enpt_{RP}$.
\item[4.2] The RP verifies the identity token, including the IdP's signature and its validity period.
It also verifies $PID_{RP}$ in the token matches the one negotiated in Step 2.2.
Then, the RP extracts $PID_U$, and calculates $Acct = [t^{-1}]{PID_U}$.

\item [4.3] The RP allows the user to login as $Acct$.

\end{itemize}


If any verification or check fails,
     the flow will be halted immediately.
For example, the user halts the flow
    on an invalid $Cert_{RP}$.
The IdP rejects a request, if the received $PID_{RP}$ is not on the elliptic curve $\mathbb{E}$.
Or, the RP rejects an identity token
    when $PID_{RP}$ in the token does not match the negotiated one.



\subsection{Compatibility with OIDC}
\label{subsec:compatible}
%We explain the compatibility with OIDC,
%    and this compatibility helps us to analyze, implement and deploy UPPRESSO.
% 这句话前面已经说过了


Among the four steps of the login flow in UPPRESSO,
    the script downloading prepares the user agent before other steps.
The user agent of SSO is responsible for the communications between the IdP and the RP,
    which are implemented by browser redirections in OIDC.
On the other hand, in UPPRESSO the scripts hide $Enpt_{RP}$ from the IdP,
%in UPPRESSO
 %   when sending the identity-token request,
  %      the script replaces $Enpt_{RP}$ with $PEnpt_{U}$,
    and forward the identity token to $Enpt_{RP}$ extracted from the RP certificate.
%    that to protect the identity token from being sent to adversaries. 这句话与Compatibility无关
So the IdP does not set \verb+redirect_uri+ in the HTTP response. % of identity tokens.

Most operations of RP identity transformation are conducted within browsers,
 while the RP only receives $t$ to calculate $PID_{RP}$ and responds with  $Cert_{RP}$.
The calculation of $PID_{RP}$ is viewed as an operation to prepare the RP identity in OIDC,
    and the static $Cert_{RP}$ is a supplementary message to users.
%The operations in the $PID_{RP}$ registration are almost identical to those in the RP Dynamic Registration of OIDC \cite{DynamicRegistration},
   % except that
   % in OIDC the IdP assigns the RP's identity  while in UPPRESSO this (pseudo-)identity is generated by the registered entity.
%Besides, the $PID_{RP}$ registration has a validity period.

The operations of identity-token generation and $Acct$ calculation,
    are actually identical to those of OIDC,
    because (\emph{a}) the calculation of $PID_U$ is viewed as a method to generate PPIDs
        and (\emph{b}) the calculation of $Acct$ is viewed as a mapping from the user identity in tokens
                    to a local account at the RP.

Finally,
    this compatibility is experimentally confirmed by our prototype implementation:
     only 20 lines of Java code in MITREid Connect \cite{MITREid}, an open-source OIDC system,
 are modified
    to build the IdP of UPPRESSO (see Section \ref{subsec:proto-imple}).
%It will help the adoption and deployment of UPPRESSO.

%It follows a similar logic flow as OIDC in SSO login and only requires small modifications to perform identifier transformation.
%Here, we explain the modification in each of the five steps of its SSO login flow to show that UPPRESSO is compatible with OIDC, which indicates UPPRESSO can be easily integrated with other commonly used SSO systems.
%Among the five steps,
% the {\em scripts downloading} and {\em RP identifier transformation} steps are newly introduced by UPPRESSO.
%The browser is required to download two scripts from the IdP and RP and most of the designed operations in these two steps are performed by the scripts in the browser.
%So, we require minimal modifications to the IdP and RPs providing new network interfaces (i.e., the new URLs for downloading resources).
%The other three steps adopt a similar communication pattern as OIDC.
%In particular, the {\em $PID_{RP}$ registration} step can be viewed as a variant of the RP dynamic registration flow of OIDC \cite{DynamicRegistration}, which allows an entity to register its identity and endpoint at the IdP.

%UPPRESSO can also support the authorization code flow of OIDC with small modifications (to be discussed in Section \ref{sec:discussion}).


%Different from OIDC in which only RPs can call a dynamic registration, UPPRESSO allows any authenticated user to launch this process and register an RP identifier with the IdP.
%The {\em identity token generation} and {\em $Account$ calculation} steps adopt the same steps and functions as the implicit protocol flow of OIDC, while using a few different parameters. First, in identity token generation, $PID_U$ transformed from $ID_U$ is used to replace $ID_U$, which is directly supported by OIDC, similar as in the PPID approaches that also convert $ID_U$ into $PID_U$. The calculation of $Account$ from $PID_U$
%can be viewed as a customized step by the RP to derive its user account after the implicit protocol flow of OIDC ends.

%So,the identity token generation and $Account$ calculation steps of UPPRESSO can be viewed as a particular but compatible implementation of the implicit protocol flow of OIDC. It is worth noting that the identity token generation and $Account$ calculation steps of
%As shown in Figure \ref{fig:process}, in UPPRESSO, the SSO protocol for identity token is the same as in OIDC; the formats of identity token and corresponding request are the same as in OIDC; the correctness checks on the identity-token request at the IdP (i.e., consistency of RP' identifier and endpoint with the registered one) are the same as in OIDC; the correctness checks on the identity token (i.e., consistency of RP' identifier with the one in the request, integrity, validity time, freshness, and etc.) at the RP are the same as in OIDC.
%The above modifications could be completed automatically for each login, without affecting other communication pattern.

%以下为描述Step 2.3到7的详细内容.
%That is, the RP construct a request for identity token (Step 2.3); the user redirects this request to the IdP (Step 2.5); the IdP generates the identity token (Step 4), and sends it to the user (Step 5.1) who redirects it to the RP (Step 5.3); and finally the RP verifies the identity token (Step 6).

%However, UPPRESSO achieves privacy preservation by integrating  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$, and  introduces the following modifications on OIDC.

%\begin{enumerate}
%  \item The identity token is bound with $PID_{RP}$ instead of $ID_{RP}$, which introduces the RP identifier transforming (Steps 1.2-1.5)  and $PID_{RP}$ registration (Steps 2.1-2.4).
%  \item The identity token is designated to one-time endpoint instead of RP's identifying endpoint, which requires the user to register the one-time endpoint in Step 2.1 and replace it with the original endpoint in Step 3.2.
%  \item IdP generates $PID_U$ based on ($PID_{RP}$, $ID_U$) instead of ($ID_{RP}$, $ID_U$).
%  \item The RP calculates $Account$ from the changing $PID_U$ instead of an unchanged one.
%\end{enumerate}

%上述modification如何实现的，简单描述
%to add: PID_{RP} transforming 和 RP identifer refreshing在user和RP的页面自己完成了。 都用现成的数据格式
%one-time endpoint 和endpoint
%The user automatically invokes the JavaScript functions to complete RP identifier transforming, one-time endpoint generating/replacing and $PID_{RP}$ registration for each login.
%While, the RP and IdP provide the corresponding web service to complete the processing automatically.

%The protocol of RP identifier transformation is based Diffie-Hellman key exchange \cite{DiffieH76}, while $N_U$ is provided to RP for computing the trapdoor and $N_{RP}$ is provided to the user for verifying the correctness of $Y_{RP}$.

