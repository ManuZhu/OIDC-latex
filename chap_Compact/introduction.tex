\section{Introduction}
\label{sec:intro}

%SSO的特点
%SSO的现状
Single sign-on (SSO) systems, such as OAuth~\cite{rfc6749}, OpenID Connect~\cite{OpenIDConnect} and SAML~\cite{SAML}, have been widely adopted as the identity management and authentication infrastructure in the Internet.
SSO enables a website, called the \emph{relying party} (RP), to delegate its user authentication to a trusted third party called the \emph{identity provider} (IdP).
Thus, a user can visit multiple RPs with only a single explicit authentication attempt on the IdP.
With the help of SSO, a user no longer needs to remember multiple credentials for different RPs; instead, she maintains only the credential for the IdP, which will generate \emph{identity proofs} for her visits to these RPs.
%        Moreover, SSO shifts the burden of user authentication from RPs to IdPs and reduces security risks and costs at RPs.
As a result, SSO has been widely integrated with many application services.
For example,
    we find that 80\% of the Alexa Top-100 websites~\cite{Alexa} support SSO,
 and the analysis on the Alexa Top-1M websites~\cite{GhasemisharifRC18} identifies 6.30\% with the SSO support.
Meanwhile, many email and social network providers (such as Google, Facebook, Twitter, etc.)
    are serving the IdP roles. %social identity providers to support social login.


%SSO系统的安全问题，需要保护identity proof的完整性，机密性，绑定性
%完整性：使用公开的为受保护的信息作为identity proof
%机密性：保证由IdP发送给对应的RP，并且传输过程中通道、user agent都是受到保护的
%绑定性：identity proof一定要与对应的RP实现绑定
%SPRESSO中关于impersonation和identity injection的描述。 Authentication is the most fundamental security property of an SSO system. That is, i) an adversary should not be able to log in to an RP, and hence, use the service of the RP, as an honest user, and ii) an adversary should not be able to log in the browser of an honest user under an adversary’s identity (identity injection).
%这段描述两个事情：1.secure authentication 就是能防住impersonation和identity injection。 然而，现在有很多攻击使得这两个无法得到保证。经过分析主要是这三个方面的原因：1)RP接受了未被完整性保护的内容；2)未绑定；3)泄露。
%binding 原文描述 ChenPCTKT14 CCS14 Friendcaster(Friendcaster是一款Facebook的第三方应用，比官方版的功能更加全面) blindly accepting an access token received from a user's device then using this token to exchange for the user's Facebook ID. A malicious application could obtain a legitimate access token from a user, then use this access token to log into Friendcaster as the user. cause they thought Facebook's access tokens were bound to relying parties and checked with every API call: \From Facebook's perspective, the API calls wouldn't appear to be originating from Friendcaster, but the attacker's own app."
%完整性原文描述 IEEE S&P2012~\cite{WangCW12}关于Google问题描述we found that the RPs of Google ID SSO often assume that message fields they require Google to sign would always be signed, which turns out to be a serious misunderstanding (Section 4.1). These problems make us believe that a complete answer to our question can only be found by analyzing SSO schemes on real websites.

The primary goal of SSO services is to implement secure user authentication~\cite{SPRESSO},
     i.e., to ensure that an honest user can always log in to an honest RP under the correct account.
To achieve this, an identity proof generated by the IdP should explicitly specify
            the authenticated user (i.e., \emph{user identification})
        and the RP to which the user attempts to log in (i.e., \emph{receiver designation}). The identify proof should be received only by that RP and user but not by any other entities (i.e., \emph{confidentiality}) and verified by the receiver (i.e., \emph{integrity}).

However, various attacks exploit vulnerabilities in different SSO systems to break at least one of these requirements~\cite{ChenPCTKT14, FettKS16,WangCW12,ZhouE14,WangZLG16,YangLLZH16,SomorovskyMSKJ12,MohsenS16},
where the adversaries attempt to either impersonate the victim user at an honest RP or %manipulate the victim user's browser to
log in to honest RPs under the adversary's identity. %(i.e., identity injection).
For example, Friendcaster was found to accept any received identity proof~\cite{ExplicatingSDK,ChenPCTKT14}
(i.e., a violation of receiver designation) so that a malicious RP could log in to Friendcaster as the victim user by replaying the identity proof received from the user to Friendcaster~\cite{MohsenS16}. \cite{WangCW12} reported that some RPs of Google ID SSO accepted user attributes that were not tied to the identity proof (i.e., a potential violation of integrity). As a result, a malicious user could insert arbitrary attributes (e.g., an email address) into the identity proof to impersonate another user at the RP.


%SSO 引入新的隐私问题
%IdP知道用户登录哪个RP
%RP之间可以合谋知道同一个用户登录哪些RP
Moreover, the adoption of SSO also raises several privacy concerns regarding online user tracking and profiling~\cite{maler2008venn,NIST2017draft}.
User privacy leaks in all existing SSO protocols and implementations.
Taking a widely used SSO protocol, OpenID Connect (OIDC), as an example, we explain its login process and the privacy leakage risk. As shown in Fig.~\ref{fig:OpenID}, upon receiving a user login request (Step 1), the RP constructs an authentication request with its identity and redirects it to the IdP (Step 2).
After authenticating the user, the IdP  generates an identify proof containing the identities of the user and the RP in Step 4, which is forwarded to the RP by the user in Step 5. Finally, the RP verifies the identity proof and allows the user to log in. In such authentication sessions, any curious IdP or multiple collusive RPs can easily break users' privacy as follows.
\begin{itemize}
\item {\em IdP-based visit tracing}. The IdP knows the identities of the RP and user in a single authentication session in Step 2 and Step 3, respectively. As a result, a curious IdP could easily discover all the RPs that the victim user attempts to visit and profile her online activities.

\item {\em RP-based identity linkage}. The RP learns user's identity from the identify proof. When the IdP generates identity proofs for a user, if a same user identifier is used in identity proofs generated for different RPs, % or the user's identifiers can be derived from each other,
which is the case of several widely deployed SSO systems~\cite{BrowserID,SPRESSO}, malicious RPs can collude to not only link the user's login activities at different RPs for online tracking but also correlate her attributes across multiple RPs~\cite{maler2008venn}.
\end{itemize}

%表一的不同形式（横排、还是竖排）
\begin{comment}
\begin{table}[tb]
    \caption{Three functions in privacy-preserving SSO.}
    \centering
    \tiny
    \begin{tabular}{|c|c|c|c|c|}
    \hline
    {Function} & {PPID} & {SPRESSO} & {BrowserID} & {UPRESSO} \\
    \hline
    {$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$} & {$PID_U=PPID$ (\checkmark)} & {$PID_U=ID_U$ ($\times$)} & {$PID_U=ID_U$ ($\times$)} & {$PID_U={PID_{RP}}^{ID_U}$ (\checkmark)} \\
    \hline
    {$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$} & {$PID_{RP}=ID_{RP}$ ($\times$)}  & {$PID_{RP}=Enc(ID_{RP}||nonce)$ (\checkmark)} & {$PID_{RP}=\bot)$ (\checkmark)} & {$PID_{RP}={ID_{RP}}^{n_U*n_{RP}}$ (\checkmark)} \\
    \hline
    {$\mathcal{F}_{PID_{U} \mapsto Account}$} & {$Account=PPID$ (\checkmark)} & {$Account=ID_U$ ($\times$)} & {$Account=ID_U$ ($\times$)} & {$Account={PID_{RP}}^{t}$ (\checkmark)} \\
    \hline
    \end{tabular}
    \label{tbl:compare}
\end{table}
\end{comment}

\begin{table}[tb]
    \caption{Three functions in privacy-preserving SSO.}
    \centering
    \setlength{\tabcolsep}{0.5mm}
    \begin{tabular}{|c|c|c|c|}
    \hline
    {Solutions} & {\tiny{$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$}} & {\tiny{$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$}} & {\tiny{$\mathcal{F}_{PID_{U} \mapsto Account}$}}\\
    \hline
    {PPID} & {\tiny{$Map[ID_U,ID_{RP}]$ (\checkmark)}} & {\tiny{$ID_{RP}$ ($\times$)}} & {\tiny{$PID_U$ (\checkmark)}}\\
    \hline
    {SPRESSO} & {\tiny{$ID_U$ ($\times$)}} & {\tiny{$Enc(ID_{RP}||nonce)$} (\checkmark)} &{\tiny{$ID_U$ ($\times$)}}\\
    \hline
    {BrowserID} & {\tiny{$ID_U$ ($\times$)}} & {\tiny{$\bot$ (\checkmark)}} &{\tiny{$ID_U$ ($\times$)}}\\
    \hline
    {UPRESSO} & {\tiny{${PID_{RP}}^{ID_U}$ (\checkmark)}}  & {\tiny{${ID_{RP}}^{N_U*N_{RP}}$ (\checkmark)}} & {\tiny{${PID_{U}}^{t}$ (\checkmark)}}\\
    \hline
    \end{tabular}
    \label{tbl:compare}
\end{table}

%google and facebook的负面新闻
%1. service provider（如DNS）知道你访问了，可以带来很多问题。但是还是不同的，DNS里profile需要评估的是two behavior vectors的similarities，而IdP中都不需要，因为IdP能够区分two behavior vectors 是否来自相同节点。

Large IdPs, especially social IdPs such as Google and Facebook, are known to be interested in collecting users' online behavioral information for various purposes (e.g., Screenwise Meter~\cite{googlenews}, Onavo~\cite{Onavo}). By simply serving the IdP role, these companies can easily collect a large amount of continuous data to reconstruct users' online traces. On the other hand, in today's Internet, many service providers host a variety of web services, which provides them an advantaged position to link a user's multiple logins at different RPs. Through an internal information integration, rich information can be obtained from the SSO data for user profiling.

While the privacy problems in SSO have been widely recognized~\cite{maler2008venn,NIST2017draft}, only a few solutions were proposed to protect user privacy~\cite{persona,SPRESSO}. Among them, Pairwise Pseudonymous Identifier (PPID)~\cite{OpenIDConnect, SAMLIdentifier} is a most straightforward and commonly adopted solution to defend against RP-based identity linkage. It requires the IdP to create different identifiers for the user when she logs in to different RPs, so that the pairwise pseudonymous identifiers of the same user cannot be used to link user logins at different RPs no matter they collude or not. As a recommended practice by NIST~\cite{NIST2017draft}, PPID has been specified in many widely adopted SSO standards including OIDC~\cite{OpenIDConnect} and SAML~\cite{SAMLIdentifier}. However, PPID-based approaches cannot prevent the IdP-based access tracing attacks, as the IdP still knows which RP the user visits.

To the best of our knowledge, only two schemes (i.e., BrowserID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO}) have been proposed so far to defend against IdP-based access tracing.
In BrowserID (and its prototype system known as Mozilla Persona~\cite{persona} and Firefox Accounts~\cite{FirefoxAccount}), IdP generates a user certificate to bind the user's unique identifier (i.e., email address) to a public key. With the corresponding private key, the user binds the receiving RP's identifier to the identity proof %(including the user certificate),
and sends it to that RP. In this way, the IdP does not need to know the RP's identity in the generation of identify proofs. SPRESSO requires the RP to create a pseudonymous identifier at each login for the IdP to generate the identity proof and therefore hides its real identifier from the IdP. The RP employs a third-party entity (named {\em forwarder}), which works as a proxy to receive the identity proof from the IdP and relay the identity proof to the corresponding RP. While the RPs' identifiers are protected from the IdP in both schemes, the IdP has to know the unique identifier (e.g., email address) of the user and includes it in the identity proof so that a same user can be recognized by a same RP in her multiple logins. As a result, both schemes are vulnerable to RP-based linkage attacks.

As described above, none of existing SSO systems could prevent both the RP-based identity linkage and IdP-based access tracing.
Here, we analyze these two privacy leakage problems formally.
Each user has one identifier at the IdP and each RP respectively, which is denoted as $ID_U$ at the IdP and $Account$ at the RP.
Each RP has one global unique identifier (denoted as $ID_{RP}$), and a privacy-preserving identifier $PID_{RP}$ (may be null) at IdP for each login.
$PID_{RP}$ is generated by the RP or the user, with the function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$. %F_{PID_{RP}}(ID_{RP})$.
And, IdP generates a  privacy-preserving user identifier ($PID_U$) with $ID_U$ and $PID_{RP}$, based on the function $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$. % $PID_{U}=F_{PID_{U}}(ID_U, PID_{RP})$.
While,  RP calculates $Account$ with the function  $\mathcal{F}_{PID_{U} \mapsto Account}$. %$Accout=F_{Accout}(PID_U, ID_{RP}, PID_{RP})$.
The three functions   have to satisfy:
\begin{itemize}
  \item To prevent RP-based identity linkage, $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ needs to ensure that $PID_{U}$ are  unlinkable among various RPs, while $\mathcal{F}_{PID_{U} \mapsto Account}$ needs to ensure that $Account$ are unlinkable among different RPs.
  \item To prevent IdP-based access tracing, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ needs to ensure that $PID_{RP}$ are  unlinkable for multiple logins at an RP.
  \item To ensure each RP obtains the unchanged $Account$ among the user's multiple logins,
  all the three functions need to be designed corporately,
   and therefore the output of $\mathcal{F}_{PID_{U} \mapsto Account}$ will be unchanged for a user's multiple logins at an RP.
\end{itemize}


Existing privacy-preserving schemes adopt either the unsatisfying $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ or $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$,
 which will simplify the construction of $\mathcal{F}_{PID_{U} \mapsto Account}$, but fail to provide the complete user privacy.
For example,
in PPID~\cite{OpenIDConnect, SAMLIdentifier},
$\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ outputs $ID_{RP}$ directly and $\mathcal{F}_{PID_{U} \mapsto Account}$ outputs  $PID_{U}$ as $Accout$, then IdP knows which RP the user visits;
in BrowserID~\cite{BrowserID} and SPRESSO~\cite{SPRESSO},
$\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ outputs $ID_U$ directly and $\mathcal{F}_{PID_{U} \mapsto Account}$ uses $ID_U$ as $Accout$ directly, then the collusive RPs could perform  RP-based identity linkage.




In this paper, we propose UPRESSO, an Unlinkable Privacy-REspecting Single Sign-On system,
which provides \textbf{all} the \textbf{satisfying} $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ based on the discrete logarithm problem, and prevents both the RP-based identity linkage and IdP-based access tracing.
In UPRESSO, for each login,   a one-way trapdoor function $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ is invoked with a randomly chosen trapdoor ($t$) to generate a random and unique $PID_{RP}$ which is anonymously registered it at the IdP by the user;
then IdP invokes a one-way function  $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$ to generate $PID_U$ with $PID_{RP}$ and $ID_U$, and issues the identity proof;
finally, RP checks the binding and integrity of the identity proof, and invokes $\mathcal{F}_{PID_{U} \mapsto Account}$ with $PID_U$, $ID_{RP}$, $PID_{RP}$ and the trapdoor $t$ to obtain the unchanged $Accout$ for the user at this RP.
Therefore, based on the discrete logarithm problem,
 UPRESSO ensures:
 (1) when a  user logs in to an RP, the RP can derive an unchanged $Accout$ from different $PID_U$, but cannot  derive $ID_U$;
 (2) when a user logs in to different RPs, various $PID_U$s and $Account$s are generated and collusive RPs cannot link the user's multiple logins;
 and (3) when an RP is visited during multiple logins, random $PID_{RP}$s are generated and the curious IdP cannot infer $ID_{RP}$ nor link these logins.



We have implemented a prototype of UPRESSO based on an open-source implementation of OIDC.
UPRESSO inherits the security properties from OIDC by achieving the binding, integrity and confidentiality of identity proof,
  and only requires small modifications to add the three functions $\mathcal{F}_{ID_{U} \mapsto PID_{U}}$, $\mathcal{F}_{ID_{RP} \mapsto PID_{RP}}$ and $\mathcal{F}_{PID_{U} \mapsto Account}$ for privacy protection.
Therefore,
 unlike  BrowserID and SPRESSO which are the non-trivial re-designs of the existing SSO systems,
UPRESSO is compatible with existing SSO systems,
 and doesn't require a completely new and comprehensive formal security analysis.


%我们的贡献
%提出协议
%考虑能否根据模型进行分析
%实现原型系统
The main contributions of UPRESSO are as follows:
\begin{itemize}
\item We systematically analyze the privacy issues in SSO systems and propose a comprehensive protection solution to hide users' traces from both curious IdPs and collusive RPs, for the first time. We also provide a systematic analysis to show that UPRESSO achieves the same security level as existing SSO systems.
\item We develop a prototype of UPRESSO that is compatible with OIDC and demonstrate its effectiveness and efficiency with experiment evaluations.
\end{itemize}




%文章结构
The rest of this paper is organized as follows. We introduce the background in Sections~\ref{sec:background}, and the challenges with solutions briefly~\ref{sec:challenge}. Section~\ref{sec:related} and Section~\ref{sec:UPRESSO} describe the threat model and the design of UPRESSO. A systematical analysis is presented in Section~\ref{sec:analysis}. We provide the implementation specifics and evaluation in Section~\ref{sec:implementation}, then introduce the related works in Section~\ref{sec:related}, and draw the conclusion finally.


