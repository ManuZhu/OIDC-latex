Definition 1
The secure system: In an UPPRESSO web system, some r ∈ RP that is honest, some i ∈ IDP that is honest, some u ∈ governor(i) with the browser b owning u being not fully corrupted. The Cookie where S(r).sessions[Cookie[sessionid]][u] ≡ AccountOf(u)，is not derivable from the attackers knowledge. 

证明Definition 1成立，使用反证法，证明Cookie derivable from the attackers knowledge不成立。

Assumption 1
Cookie is derivable from the attackers knowledge. (1) Attacker can receive the Cookie where S(r).sessions[Cookie[sessionid]][u] ≡ AccountOf(u); or (2) Attacker holds the Cookie where S(r).sessions[Cookie[sessionid]][user] /≡ AccountOf(u), it can set a run after which S(r).sessions[Cookie[sessionid]][user] ≡ AccountOf(u)

Lemma 1
The Cookie is not leakable.
Proof
	The browser follows the same origin policy
	The script do not send any Cookie

lemma 2
To set S(r).sessions[Cookie[sessionid]][user] ≡ AccountOf(u), the Cookie owner must know the Token where Token.Content[PID_RP] ≡ S(r).sessions[Cookie[sessionid]][PID_RP], ModPow(Token.Content[PID_U],  S(r).sessions[Cookie[sessionid]][t], S(i).p) ≡ AccountOf(u), Token.Content.Validity in S(r).sessions[Cookie[sessionid]][Validity], as well as S(r).sessions[Cookie[sessionid]][state] ≡ expectToken. 
Proof
	In the RP path ≡ /uploadTokenpart

Assumption 2
Token is derivable from the attackers knowledge. (1) Attacker cam forge the Token; or (2) Attacker can receive the Token

Lemma 3
Token can only be generated by IdP.
Proof
	RP line 102, checksig using S(r).CurrentIdP.pubKey, S(r).CurrentIdP在line 18被设定, IdP由parameters[IdP]决定，parameters[IdP]由RP script 10, 11决定，来自于RP script的初始值，不会被修改，并且在line 102验证签发Token的IdP的身份，所以攻击者无法伪造Token

lemma 4
The password is not leaked to the attacker
Proof
	password只在IdP script line 94使用，发送至IdPDomain， IdPDomain来自于scriptstate.Parameters[IdPDomain]，由IdP Script初始化设定为IdP domain，不会被修改，所以只会发送至IdP. password 在IdP server line 21被使用，不会发送给任何人，所以不会泄露


lemma 5
如果要满足 S(r).sessions[Cookie[sessionid]][user] ≡ AccountOf(u)， 那么Token中的PID_RP, PID_U一定满足PID_U ≡ ModPow(PID_RP, UIDOfUser(i, u), S(i).p)
Proof
	根据Account算法，计算AccountOf(u)为ModPow(IDofRP(i, r), UIDOfUser(i, u), S(i).p)
	在RP server line 120，设置 S(r).sessions[Cookie[sessionid]][user] := Account， 在line 116计算Account为ModPow(PID_U, t, S(i).p), 所以Account ≡ AccountOf(u) ≡ ModPow(PID_U, t, S(i).p)， As in line 50,计算得到t * (N_RP*N_U) ≡ 1 mod q， 所以PID_U ≡ ModPow(AccountOf(u), N_RP*N_U, S(i).p) ≡ ModPow(IDofRP(i, r), UIDOfUser(i, u)*N_RP*N_U, S(i).p)
	执行line 120之前，需要在line 110验证PID_RP ≡ S(r).sessions[Cookie[sessionid]][PID_RP]，S(r).sessions[Cookie[sessionid]][PID_RP]在line 53设置，在line 49生成，为ModPow(Y_RP, N_U,  S(i).p)，Y_RP在line 27生成，为 ModPow(IDofRP(i, r), N_RP, S(i).p)，所以PID_RP ≡ ModPow(IDofRP(i, r), N_RP*N_U, S(i).p) 
	所以PID_U ≡ ModPow(PID_RP, UIDOfUser(i, u), S(i).p)
	由于需要满足line 97，S(r).sessions[Cookie[sessionid]][state] ≡ expectToken, it is impossible to change PID_RP without changing N_RP, N_U or S(r).sessions[Cookie[sessionid]][state].


lemma 6
Cert不能被伪造
Proof略

lemma 7
RegistrationResult不能伪造
Proof略


lemma 8
If Token is a valid Token(defined in Lemma 2), 在IdP script发送Token时，scriptstate.Parameters[Cert].ID_RP ≡ IDofRP(i, r)
Proof 
	Assumption 3: scriptstate.Parameters[Cert].ID_RP /≡ IDofRP(i, r)
	反证
		let scriptstate.Parameters[Cert].ID_RP ≡ ID_attacker,
		IdP script在line 132设置发送Token，需要满足scriptstate.q ≡ expectToken,需要执行line 103，从state可以追溯到line 62验证RegistrationResult，结果来自IdP server line 59，需要PID_RP，Nonce，分别来自于 IdP script line 49， line 51，let Nonce ≡ hash(N1_attacker, N2_attacker). 
		To set S(r).sessions[Cookie[sessionid]][PID_RP]≡ PID_RP and S(r).sessions[Cookie[sessionid]][state] ≡ expectToken at the same time，需要在line 84验证Registration.Content.Nonce，在line 82计算Nonce为 hash(N_RP, N_U)，由于hash(N1_attacker, N2_attacker) 不可能等于hash(N_RP, N_U)，并且在Validity之内，由于IdP检查line 46，不会为相同的PID_RP签发拥有不同Nonce的RegistrationResult，所以在Validity之内，无法实现set S(r).sessions[Cookie[sessionid]][PID_RP]≡ PID_RP and S(r).sessions[Cookie[sessionid]][state] ≡ expectToken at the same time。所以与lemma 2冲突，Assumption 3不成立，反证结束。
	


lemma 9
The Token can not be received by the attacker. 
Proof
	Attacker attempt to receive the Token from RP server, RP script, IdP server or IdP script
	RP server 不发送任何Token，attacker cannot receive the Token from RP server 
	RP script line 101, 只将Token发送至RPDomain, RPDomain来自于scriptstate.Parameters[RPDomain]，由RP Script初始化设定为RP domain，不会被修改，所以只会发送至RP
	IdP server Token生成在IdP line 83，其中PID_U生成在line 80，根据lemma5，需要满足UID ≡ UIDOfUser(i, u)，UID在line 25生成,需要在line 21验证password，根据lemma 1和lemma 4，获得由于attacker不知道password，并且attacker无法验证成功的Cookie,所以无法获得token
	IdP script 只在line 132发送Token，目的地址由RPOrigin决定，根据 line 130，131，RPOrigin由scriptstate.Parameters[Endpoint_RP]决定，在line 74检查属于scriptstate.Cert.Content.Endpoints，根据lemma 6， lemma 8，RPOrigin属于domain(r)，所以Token不会发送给攻击者
反证了Assumption 2不成立
所以反证Assumption 1不成立
所以Definition 1成立


