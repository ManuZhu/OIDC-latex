\section{Analysis}
\label{sec:analysis}
In this section, we firstly prove the privacy of Recluse, i.e., avoiding the identity linkage at the colluded malicious RPs, 
and preventing the curious IdP from inferring the user's accessed RPs.
Then, we prove that Recluse does not degrade the security of SSO systems by comparing it with OIDC, which has been formally analyzed in~\cite{FettKS17}.


\subsection{Privacy}
\label{subsec:privacy}
\noindent{\textbf{Curious IdP.}} The curious IdP might be interested in the user accessed RP or infer the correlation of RPs in two or more login flows by performing the analysis on the content and timing of received messages. However, it fails to obtain the user's accessed RPs directly, nor classifies the accessed RPs for RP's information indirectly.
%The curious IdP can only perform the analysis on the content and timing of received messages, however it fails to obtain the user's accessed RPs directly, nor infer classifies the accessed RPs for RP's information indirectly.
\begin{itemize}
  \item The curious IdP might be interested in the RP's identity but fails to derive RP's identifying information (i.e., $RPID$ and correct endpoint) through a single login flow. IdP only receives $PRPID$ and one-time endpoint, and fails to infer the discrete logarithm (i.e., $RPID$) from $PRPID$ without the  trapdoor $t$  due to hardness of solving discrete logarithm, or the RP's endpoint from the independent one-time endpoint.
  \item It also might try to infer the correlation of RPs in two or more login flows but fails achieve the relationship between the $PRPID$s. The secure random number generator ensures the random for generating $PRPID$ and the random string for one-time endpoint are independent in multiple login flows. Therefore, curious IdP fails to classify the RPs based on $PRPID$ and one-time endpoint.
  %It also might try to achieve the relationship between the $PRPID$s but fails to infer the correlation of RPs in two or more login flows from a single user or multiple users. The secure random number generator ensures the random for generating $PRPID$ and the random string for one-time endpoint are independent in multiple login flows. Therefore, curious IdP fails to classify the RPs based on $PRPID$ and one-time endpoint.
  \item It even fails to obtain the correlation of RPs through analyzing the timing of received messages. IdP fails to map user's accessed RP in the identity proof to the origin of dynamic registration based on timing, as both the dynamic registration and the identity proof request are sent by the user instead of the RP.
\end{itemize}

\noindent{\textbf{Malicious RPs.}} The malicious RPs may attempt to link the user passively by combining the $PUID$s received by the colluded RPs, or actively by tampering with the provided elements (i.e., $Cert_{RP}$, $Y_{RP}$ and $PRPID$). However, these RPs still fail to obtain the $UID$ directly, or trigger the IdP to generate a same or derivable $PUID$s.
%The malicious RPs may attempt to link the user passively by combining the PPIDs received by the colluded RPs, or actively by tampering with the provided elements (i.e., $Cert_{RP}$, $Y_{RP}$ and $PRPID$). However, these RPs still fail to obtain the user's unique identifier directly, or trigger the IdP to generate a same or derivable PPIDs.
\begin{itemize}
\item A single RP might try to find out the $UID$ presenting the unchanged user identity but fails to infer the user's unique information (e.g., $UID$ or other similar ones) in the passive way. The $PUID$ is the only element received by RP that contains the user's unique information. However, RP fails to infer (1) $UID$ (the discrete logarithm) from $PUID$, due to hardness of solving discrete logarithm; (2) or $g^{UID}$ as the $r$ in $RPID_O=g^r$ is only known by IdP and never leaked, which prevents the RP from calculating $r^{-1}$ to transfer $Account=RPID^{UID}$ into  $g^{UID}$.
\item A single RP fails to actively tamper with the messages to make $UID$ leaked. The modification of  $Cert_{RP}$ will make the signature invalid and be found by the user. The malicious RP fails to control the calculation of $PRPID$ by providing an incorrect $Y_{RP}$ as another element $n_u$ is  controlled by the user. Also, the malicious RP fails to make an incorrect $PRPID$ (e.g., 1)  be used for $PUID$, as the honest IdP only accepts a primitive root as the $PRPID$ in the dynamic registration. The RP also fails to change the accepted $PRPID$ in Step 11 in Figure~\ref{fig:process}, as the user checks it with the cached one.
\item Two or more RPs might try to find out whether the $Account$s in each RP are belong to one user or not but fail to link the user in the passive way. The analysis can only be performed based on $Account$ and $PUID$. The $Account$ is independent among RPs, as the $RPID$ chosen by honest IdP is random and unique. The $PUID$s are  also independent due to the unrelated $PRPID$.
\item Two or more RPs also might to lead IdP to generate the $PUID$ same or  derivable into same $Account$ in each RP. Since the $PUID$ is generated related with the $PRPID$, corrupted RPs might choose the related $n_{RP}$ to correlate their $PRPID$, however, the $PRPID$ is also generated with the participation of $n_{U}$, so that RP does not have the ability to control the generation of $PRPID$. Moreover, corrupted RPs might choose the same $PPID$ to lead the IdP to generate the $PUID$ derivable into same $Account$, however, $RPID$ is verified by the user with through the $Cert_{RP}$, where the tampered $RPID$ is not acceptable to the honest user.
%achieve it in the active way, by attempting to make $PRPID$ correlative by manipulating $n_{RP}$ or use the same $RPID$. However, the random $n_u$ chosen by the honest user will ensure the independence of $PRPID$ to protect its own privacy.

\end{itemize}

Colluded RPs even fail to correlate the users based on the timing of users' requests, when the provided services are unrelated. For the related services, (e.g., the online payment accessed right after an order generated on the online shopping), the user may break this linking by adding an unpredicted time delay between the two accesses. The anonymous network may be adopted to prevent colluded RPs to classify the users based on IP addresses.

\begin{comment}
\begin{itemize}
  \item A \textbf{curious} RP fails to infer the user's unique identifier (i.e., UID) through $PUID$.
   \item A \textbf{colluded curious} RP fails to link a user between RPs.
  \item A \textbf{malicious} RP fails to make the UID leaked.
  \item The \textbf{colluded malicious RPs} fail to (actively) make the UID leaked.
  \item The \textbf{colluded malicious RPs} fail to actively trigger the generation of a same PPID or derivable PPIDs.
  \item The \textbf{colluded malicious RPs} fail to passively link a user between RPs.
\end{itemize}
\end{comment}

\subsection{Security}
\label{subsec:security}
Recluse protects the user's privacy without breaking the security. That is, Recluse still prevents the malicious RPs and users from breaking the identification, integrity, confidentiality and binding of identity proof.

In Recluse, all mechanisms for integrity are inherited from OIDC. The IdP uses the un-leaked private key $SK_{ID}$ to prevent the forging and modification of identity proof. The honest RP (i.e., the target of the adversary) checks the signature using the public key $PK_{ID}$, and only accepts the elements protected by the signature.

For the confidentiality of identity proof, Recluse inherits the same idea from OIDC, i.e., TLS, a trusted user agent and the checks. TLS avoids the leakage and modification during the transmitting. The trusted agent ensures the identity proof to be sent to the correct RP based on the endpoint specified in the $Cert_{RP}$. The  $Cert_{RP}$ is protected by the signature with the un-leaked private key $SK_{Cert}$, ensuring it  will never be tampered with by the the adversary. For Recluse, the checks at the IdP is exactly the same as OIDC, that is, checking the RP identifier and endpoint in the identity proof with the registered ones, preventing the adversary from triggering the IdP to
generate an incorrect proof or transmit to the incorrect RP. However, the user in Recluse performs a two-step check instead of the direct check based on the RPID in OIDC. Firstly, the user checks the correctness of $Cert_{RP}$ and extracts  $RPID$ and the endpoint. In the second step, the user checks that the RPID in identity proof is a fresh $PRPID$ negotiated based on the $RPID$ and the endpoint is the one-time one corresponding to the one in $Cert_{RP}$. This two-step check also ensures the identity proof for the correct RP ($RPID$) is sent to correct endpoint (one specified in $Cert_{RP}$).

The mechanisms for binding are also inherited from OIDC. The IdP binds the identity proof with $RPID$ and $PUID$. The correct RP checks the binding by comparing the $PRPID$ with the cached one, and provides the service  to the $Account$ based on $PUID$.

Recluse binds the identity proof with $PRPID$, instead of a random string unique for each RP assigned by IdP in OIDC. However, the adversary (malicious users and RPs) still fails to  make one identity proof (or its transformation) accepted by the other correct RP. As the correct RP only accepts the valid identity proof for its fresh negotiated $PRPID$, we only need to ensure one $PRPID$ (or its transformation) never be accepted by the other correct RP.
\begin{itemize}
\item $PRPID$ is unique in one IdP. The honest IdP checks the uniqueness of $PRPID$ in its scope during the dynamic registration, to avoid one $PRPID$ (in its generated identity proof) corresponding to two or more RPs.
\item The mapping of $PRPID$ and \verb+issuer+ globally unique. The identity proof contains the identifier of IdP (i.e., \verb+issuer+), which is checked by the correct RPs. Therefore, the same $PRPID$ in different IdPs will be distinguished.
\item The $PRPID$ in the identity proof is protected by the signature generated with $SK_{ID}$. The adversary fails to replace it with a transformation without invaliding the signature.
\item The correct RP or user prevents the adversary from manipulating the $PRPID$. For extra benefits, the adversary can only know or control one entity in the login flow (if controlling the two ends, no victim exists). The other correct one provides a random nonce ($n_u$ or $n_{RP}$) for $PRPID$. The nonce is independent from the ones previously generated by itself  and the ones generated by others, which prevents the adversary controlling the $PRPID$.

\end{itemize}

Recluse ensures the identification by binding the identity proof with $PUID$  in the form of $RPID^{UID}$, instead of a random string generated by the IdP. However, the adversary still fails to login at the correct RP using a same $Account$ as the uncontrolled user. Firstly, the adversary fails to  modify the $PUID$ directly in the identity protected by $SK_{ID}$. Secondly, the malicious users and RPs fail to trigger the IdP generate a wanted $PUID$, as they cannot (1) obtain the uncontrolled user's $PUID$ at the correct RP; (2) infer the $UID$ of any user from all the received  information (e.g., $PUID$) and the calculated ones (e.g., $Account$); and (3) control the $PRPID$ with the participation of a correct user or RP.

The design of Recluse makes it immune to some existing know attacks (e.g., CSRF, 307 Redirect, IdP Mix-Up~\cite{FettKS16} and Man-in-middle attack) on the implementations. The Cross-Site Request Forgery (CSRF) attack is  usually exploited by the adversary to perform the identity injection. However, in Recluse, the correct user logs  $PRPID$ and one-time endpoint in the session,  and perform the checks before sending the identity proof to the RP's endpoint, which prevents the CSRF attack.  The 307 Redirect attacks~\cite{FettKS16} is due to the implementation error at the IdP, i.e. returning the incorrect status code (i.e., 307), which makes the IdP leak the user's credential to the RPs during the redirection. In Recluse, the redirection is intercepted by the trusted user agent which removes these sensitive information. In the IdP Mix-up attack, the adversary works as the IdP to collect the makes \verb+access token+ and \verb+authorization code+ (identity proof in OAuth 2.0) from the victim RP. Same as OIDC, Recluse includes the \verb+issuer+ in the identity proof (protected by the $SK_{ID}$), avoiding the victim RP to send the sensitive information to the IdP. The user established the TLS connection with RP and IdP, which avoids the Man-in-middle attack.

\begin{comment}
In order to prove the privacy and security properties of Recluse system, we firstly demonstrate that for any adversary in the system, a user's access to an specific  RP untraceable from it to another one. Besides, we illustrate the potential attacks discussed in the previous work about SSO security and the security issues introduced by Recluse.


\subsection{Privacy}
We now define the undistinguishability of SSO system. It is in the SSO system, for an adversary controlling curious IdP, it is impossible to inspect whether two \verb+authentication flow+s are to same RP or not, however, for an adversary controlling malicious RPs, it is impossible to inspect whether two \verb+authentication flow+s are from same user or not.

Assuming there are two \verb+authentication flow+s from the same user to the same RP. In Recluse system, for the curious IdP, the only parameter related with RP is $rp\_id$, as other parameters are related or generated by user, such as $fake\_uri$. To break the undistinguishability, IdP tries to derive the $basic\_rp\_id$ of RP from $rp\_id$ or inspect whether the $rp\_id$s are generated by the same $basic\_rp\_id$. However, as $rp\_id$ is generated by the formula (1), so
$$basic\_rp\_id=rp\_id^{r^{-1}}modP\eqno(7)$$
However, $r$ and $r^{-1}$ is unknown to the IdP, so that IdP is unable to derive the $basic\_rp\_id$ from the $rp\_id$. Moreover, even the IdP suspects that the $rp\_id$ is generated by the specific RP, it is impossible for IdP to verify it as the  $rp\_id$ can be generated based on any primitive root of $P$. Besides, assuming that the $rp\_id$s in different \verb+authentication flow+s are $rp\_id_1$ and $rp\_id_2$ generated by $r_1$ and $r_2$. There is
$$rp\_id_1=rp\_id_2^{r_1/r_2}modp\eqno(8)$$
So only the entity who carries the $r_1$ and $r_2$ is able to verify whether $rp\_id_1$ and $rp\_id_2$ generated by the same RP.

Inspecting whether the users in two \verb+authentication flow+s are the same user relies on the $baisc\_user\_id$ or the relation between $user\_id$s or $user\_rp\_ids$. Assuming the same user log in different RPs where the $user\_id$s are $user\_id_1$ and $user\_id_2$, $user\_rp\_id$s are $user\_rp\_id_1$ and $user\_rp\_id_2$, and $basic\_rp\_id$s are $basic\_rp\_id_1$ and $basic\_rp\_id_2$. We define that $\alpha=\log_{basic\_rp\_id_2}basic\_rp\_id_1$. There is
$$user\_rp\_id_1=user\_rp\_id_2^\alpha\eqno(9)$$
and
$$user\_id_1=user\_id_2^{\alpha\cdot r_1/r_2}\eqno(10)$$
The $\alpha$ is unknown to the malicious, so that the adversary is unable to  inspect whether the two \verb+authentication flow+s are from the same user. However, the malicious also tries to lead the same user in two \verb+authentication flow+s using the same $user\_rp\_id$ or $user\_id$. According to formula (2) and (4), the user should use the same $basic\_rp\_id$ or $rp\_id$ in two \verb+authentication flow+s. So the $user\_rp\_id$ is impossible to be same as $basic\_rp\_id$ is issued by IdP and verified by user agent. And $rp\_id$ is generated through the negotiation between user and RP, so that RP is unable to lead the user to use the same $rp\_id$ in different \verb+authentication flow+s.

\subsection{Security Consideration in OpenID Connect}
As it has been defined in ~\cite{OpenIDConnect} Section 16, the security consideration of the OIDC design contains authentication and authorization. Now we list the security consideration of authentication and prove that Recluse achieves this goals.
\begin{enumerate}
\item \textbf{Server Masquerading. } The malicious server might masquerade as the RP or IdP using various ways through which user might leak its identity proof for RP or credentials on IdP. The Recluse mitigate this threat in following ways. 1) The server visited through user agent is authenticated by HTTPS; 2) The user agent verifies the RP certification which makes sure that the token is only sent to the corresponding RP instead of the masqueraded one; 3) The user agent only visit the IdP's endpoint listed in the RP certification which avoid the access to the masqueraded IdP.
\item \textbf{Token Manufacture/Modification. } The adversary might generate a bogus token or tamper the contents in the existing token, which enables the adversary log in any RP as any honest user. The receiver of token must have the ability to verify whether the token is issued by IdP without any modification or not. The token used in Recluse is signed by IdP with its private key, so that the token is unable to be constructed or modified.
\item \textbf{Access/ID Token Disclosure. } The adversary might try to obtain an honest user's token to the honest RP through various ways, which enables the adversary log in this RP as the honest user. It is required the tokenisi never exposed to anyone except the corresponding user and RP.
\item \textbf{Access/ID Token Redirect. } The malicious RP might use the token from an honest user to access other RPs as this user only if the token is also valid in other RPs. It is required the token issued for specific RP should bound with this RP which means the RP has the ability to verify whether a token is valid in itself. The token used in Recluse containing the $rp\_id$ and $user\_id$ is solely bound with specific RP and user, which is checked by the RP.
\item \textbf{Issuer Identifier. } The issuer identifier contained in the token should be completely same as it provided by the IdP, so that the verifier of token has the ability to obtain the corresponding public key. It is also implemented in Recluse.
\item \textbf{TLS Requirements. } To avoid network attacker the transmission in OIDC system should be protected by TLS. It is implemented in Recluse.
\item \textbf{Implicit Flow Threats. } In OIDC implicit flow, token is transmitted through user agent and the TLS protections are only between user agent and IdP, and between user agent and RP. It is required the token should not be leaked to the adversary by the user agent. The user agent of Recluse is deployed based on the Chrome browser as the trust base.
\end{enumerate}

It is discovered that the security consideration of authentication in OIDC can be included into the security consideration in Section~\ref{sec:background} as table ~\ref{tab:security-consideration}. however, the threats introduced by Recluse which breaks the security consideration and the methods to mitigate these threats has also been discussed in Section~\ref{sec:overview}.


\begin{table}
\label{tab:security-consideration}
\caption{Security Consideration}
\begin{tabular}{|c|c|}
\hline  % 在表格最上方绘制横线
Security Consideration of SSO & Security Consideration of OIDC\\
\hline  %在第一行和第二行之间绘制横线
Content Checking& \multicolumn{1}{p{120pt}|}{Server Masquerading}\\
\hline
Confidentiality& \multicolumn{1}{p{120pt}|}{Server Masquerading, Access/ID Token Disclosure, TLS Requirements, Implicit Flow Threats}\\
\hline
Integrity& \multicolumn{1}{p{120pt}|}{Token Manufacture/Modification, Issuer Identifier}\\
\hline
Binding& \multicolumn{1}{p{120pt}|}{Access/ID Token Redirect}\\
\hline
\end{tabular}
\end{table}

\subsection{Related Security Analysis}
\noindent\textbf{307 Redirect. }It has been discussed in~\cite{FettKS16} that IdP might redirect the user to the RP immediately after the user inputs the credentials. For example, the HTTP response to the user's POST message with \verb+username+ and \verb+password+ might be the redirection to RP carrying user's identity proof. That is, as long as the 307 status code is used for this redirection, the user's credentials are also transmitted to the RP. However, in Recluse the redirections are intercepted by the user agent and rebuild the HTTP GET request to RP or IdP which is unable to leak the POST data of the user.

\noindent\textbf{IdP Mix-Up. } It has been illustrated in~\cite{FettKS16} that the adversary might intercept the the user's access to RP and modify the user's choice of IdP, assuming that RP integrates the SSO service provided by both the honest IdP (named \verb+HIdP+) and malicious IdP (named \verb+MIdP+). The user obtains the \verb+access token+ and \verb+authorization code+ from the \verb+HIdP+ and uploads them to the RP, however, the RP considers that the \verb+access token+ and \verb+authorization code+ are issued by the \verb+MIdP+. Therefore, the RP tries to exchange for the protected resources using the \verb+access token+ and \verb+authorization code+ with \verb+MIdP+. With this, the adversary carries the honest user's \verb+access token+ and \verb+authorization code+ which make the adversary able to log in this RP as the identity of the honest user. However, the threat is mitigated by the OIDC implicit flow, as the \verb+ID token+ issued by IdP contains the issuer identifier, so that RP is able to find out which IdP the token is from.

\noindent\textbf{Cross-Site Request Forgery (CSRF). } The CSRF attack on the RP makes the identity injection possible, through which the adversary might lead the honest user to upload the adversary's \verb+ID token+ to the RP. However, in Recluse the cross origin request should be repudiated by both RP and IdP excepted the request from the origin of the user agent. Therefore the CSRF attack on Recluse is impossible.

PRIOIDC tries to protect user's privacy by keeping RP anonymous to IdP. IdP is able to get client\_id and redirect\_uri. As redirect\_uri is generated by user, it will show nothing about RP. IdP can only undermine user's privacy by get RP's identity from client\_id. It's described in Client-id-generating algorithm: $client\_id=basic\_rp\_id^r mod p$. $p$ is a large prime and basic\_rp\_id is a primitive element module $p$. And $r$ is the random number generated by user and RP. IdP can only find out RP's real identity by finding out $r^{-1}$ and let $1=r\cdot r^{-1} mod (p-1)$, so that $$basic\_rp\_id=client\_id^{r^{-1}}modp$$
But $r$ is secret shared by user and RP, and according to \textbf{Discrete Logarithm} problem calculating $r$ from client\_id is difficult. So basic\_rp\_id is invisible to IdP. In other way if IdP gets a user's repeatedly login, it is going to find out whether they are about the same RP. If there are two client\_ids from the same RP marked as $client\_id_{1}=basic\_rp\_id^{r_1}modp$ and $client\_id_{2}=basic\_rp\_id^{r_2}modp$. Client\_id$_{1}$ and client\_id$_{2}$ meet the following formula
$$client\_id_1=client\_id_2^{r_2/r_1}modp$$
So that only when knowing $r_1$ and $r_2$ IdP can find out the relevance between Client\_id$_{1}$ and client\_id$_{2}$. But $r_1$ and $r_2$ are invisible to IdP. So IdP is never able to undermine user's privacy.

RPs try to find out user's login trace in three ways: 1) Getting the user's unique id in IdP. 2) Finding the relevance among user\_rp\_ids. 3) Deducing user's login trace from IP address. As user's id is used in generating user\_id in id\_token, RP is able to obtain $user\_id=client\_id^{id}modp$. Client\_id is primitive element module $p$. Although client\_id, user\_id and $p$ are known by RP, according to \textbf{Discrete Logarithm} problem calculating id from user\_id is difficult. For different RPs, they are able to get user's user\_rp\_id. User\_rp\_ids from different RPs can be marked as $user\_rp\_id_1=basic\_rp\_id_1^{id}modp$ and $user\_rp\_id_2=basic\_rp\_id_2^{id}modp$. As basic\_rp\_id$_1$ and basic\_rp\_id$_2$ are primitive element module $p$, there is $0<\alpha<p$ and $basic\_rp\_id_1=basic\_rp\_id_2^\alpha modp$.So user\_rp\_id$_1$ and user\_rp\_id$_2$ meet the following formula
$$user\_rp\_id_1=user\_rp\_id_2^\alpha modp$$
So RP is able to deduce the relevance between user\_rp\_id$_1$ and user\_rp\_id$_2$ only when knowing $\alpha$. As basic\_rp\_id is generated by IdP and calculating $\alpha$ from basic\_rp\_ids, RP is never able to find the relevance. If an RP does not use the basic\_rp\_id from IdP, user is able to find it dishonest through rp\_certificate and stop the login. Most of current users use dynamic IPs so that it is impossible to get user's login trace from user's IP.


\subsection{Impersonation attack}
RP conducts impersonation attack by getting user's id\_token which is valid in other RPs. OpenID Connect protocol protect id\_token from malicious RP by keep RP owns unique client\_id and check RP's redirect\_uri during login. Unique client\_id makes one RP's id\_token invalid in other RPs. And IdP only redirects id\_token to it's relevant RP's redirect\_uri registered in IdP so that attacker is never able get RP's id\_token. There are three conditions for a malicious to try getting a validate id\_token. 1) Malicious RP has already finished client\_id negotiation with an RP as a user. As client\_id is generated by both RP and user, malicious RP is unable to get the id\_token with the same client\_id. 2)Malicious RP has got a user's id\_token, same as condition 1 malicious RP is unable to negotiate the same client\_id with another RP. 3) Malicious RP acts as the man in the middle between RP and user. As RP sends its URL in rp\_certificate user only sends its id\_token to this URL so that attacker can never achieve id\_token. As a summary, malicious is unable to conduct impersonation attack.

Malicious user is only able to conduct impersonation attack by tempering id\_token. If attacker has already get victim's user\_rp\_id, attacker is able to calculate $user\_id=user\_rp\_id^rmodp$. $r$ is shared by RP and attacker. However id\_token is protected by the signature generated by IdP so that it is impossible for attacker to log in RP as victim.

%External attacker is going to steal user's id\_token from network flow to make the attack. As all the network flows are protected by https, external attacker is unable to conduct the attack.
\subsection{Abduction attack}
To lead user to login an RP as attacker, attacker needs to make sure that user receive a malicious token from IdP. As https is used to protect parameters transforming between user and IdP, it's impossible to temper user's token during transmission. The other way to conduct the attack is phishing attack on IdP.
In traditional SSO protocol such as OAuth 2.0 and OpenID Connect, it is possible for malicious to conduct phishing attack on IdP. As it is shown in ~\ref{fig:OpenID} step 2, the request from user to IdP is built by RP. If an malicious RP set the IdP'url as its phishing site, an unwary user may input its id and password on the phishing website so that attacker is able to get the full control of user's account.
In PriOIDC as RP\_Cert contains IdP's url, user agent is going to compare the IdP's url in request and RP\_Cert. If they are not matched, the request is deemed invalid.

Phishing attack on RP in SSO system is quite different from it in normal website. In SSO system even an unwary user has visited a phishing RP's website, IdP is going to ask user to make sure RP's identity in ~\ref{fig:OpenID} step 2. The identity is bound with RP's client id and client id is bound with its redirect uri. If malicious RP constructs the request in ~\ref{fig:OpenID} step 2 to IdP with its personal client id, user is able to find out the true identity of RP and protect itself from phishing attack. In traditional SSO system if malicious uses a client id of another RP, IdP is going to redirect user to the corresponding redirect uri. In PriOIDC user agent is going to compare redirect uri from RP with the redirect uri in RP\_Cert.If uris are not matched, the request is regarded invalid. A phishing RP can never achieve another RP's token and never lead user to log in its website.

%In phishing attack, adversary forges an RP's web application and induces user to log in it. In the disguise of the real RP, phishing site must send the real RP's rp\_token to user. In obtaining token phase if RP redirects user to real IdP, user is going to send its id\_token to the address from rp\_certificate. RP is not able to get user's id\_token and User does not log in adversary's RP finally. If RP redirects user to a fake IdP, the URL in redirection request is not mapped with it in rp\_certificate. User is going to stop the login. So phishing attack is not possible.

%External attacker is willing to conduct abduction attack. Attacker is going to make the attack by temper user's id\_token into attacker's id\_token when id\_token is transformed on the network. But all the network flows are protected by https so that user's id\_token is secure.
%如果不同RP之间Basic_Client_ID 找到幂次的关系，那么就可以对应到同一个用户的身份


\subsection{Discussion}
An external attacker is also taken into account in SSO system. External attacker is able to capture and temper all the network flow through user, RP and IdP. External attacker's targets include impersonation attack, abduction attack and privacy undermining attack.
%As SSO login requires IdP and RP to adopt https, external attacker is unable to get user's login trace through network flows. And user's dynamic IP makes external attacker impossible to get user's login trace from user's IP.
If an attacker keeps its eye on a specific user, it is able to find that the user's login on different RPs. So it is easy for an external attacker to draw a user's login trace. Privacy protection is not effective for external attacker.
To protect user from privacy leaking a proxy is probably a appropriate scheme. Proxy is able to mix multi-user's request and keep user's login trace invisible to attacker. User's dynamic IP makes proxy impossible to get user's login trace from user's IP
External attacker is going to steal user's id\_token from network flow to make the attack and it is also going to make the attack by temper user's id\_token into attacker's id\_token when id\_token is transformed on the network. As all the network flows are protected by https, external attacker is unable to conduct the attacks.
\end{comment}
