\section{Security Analysis}
\label{sec:analysis}
%敌手目标：
%获得用户登录轨迹
%以受害者的身份登录RP
%使受害者以攻击者身份登录RP
In SSO system, malicious opponent's attacks can be concluded into 3 goals:
\begin{enumerate}
    \item Privacy undermining attack: Malicious opponent tries to get user's login trace on different RPs. 
    \item Impersonation attack: Attacker tries to log in RP as a victim's identity. In this way, attacker can get the full control of victim's account in RP.
    \item Abduction attack: Attacker also tries to lead user to upload users personal information to it. To achieve this goal, there are two ways. The first is letting a victim log in an RP as attacker's identity. In this way, if the RP is online storage system, victim may upload its privacy data to attacker's account. The other way is phishing attack. A malicious RP disguises it as another RP and abducts user to upload some information.
\end{enumerate}
%
\subsection{Privacy undermining attack}
PRIOIDC tries to protect user's privacy by keeping RP anonymous to IdP. IdP is able to get client\_id and redirect\_uri. As redirect\_uri is generated by user, it will show nothing about RP. IdP can only undermine user's privacy by get RP's identity from client\_id. It's described in Client-id-generating algorithm: $client\_id=basic\_rp\_id^r mod p$. $p$ is a large prime and basic\_rp\_id is a primitive element module $p$. And $r$ is the random number generated by user and RP. IdP can only find out RP's real identity by finding out $r^{-1}$ and let $1=r\cdot r^{-1} mod (p-1)$, so that $$basic\_rp\_id=client\_id^{r^{-1}}modp$$
But $r$ is secret shared by user and RP, and according to \textbf{Discrete Logarithm} problem calculating $r$ from client\_id is difficult. So basic\_rp\_id is invisible to IdP. In other way if IdP gets a user's repeatedly login, it is going to find out whether they are about the same RP. If there are two client\_ids from the same RP marked as $client\_id_{1}=basic\_rp\_id^{r_1}modp$ and $client\_id_{2}=basic\_rp\_id^{r_2}modp$. Client\_id$_{1}$ and client\_id$_{2}$ meet the following formula
$$client\_id_1=client\_id_2^{r_2/r_1}modp$$
So that only when knowing $r_1$ and $r_2$ IdP can find out the relevance between Client\_id$_{1}$ and client\_id$_{2}$. But $r_1$ and $r_2$ are invisible to IdP. So IdP is never able to undermine user's privacy.

RPs try to find out user's login trace in three ways: 1) Getting the user's unique id in IdP. 2) Finding the relevance among user\_rp\_ids. 3) Deducing user's login trace from IP address. As user's id is used in generating user\_id in id\_token, RP is able to obtain $user\_id=client\_id^{id}modp$. Client\_id is primitive element module $p$. Although client\_id, user\_id and $p$ are known by RP, according to \textbf{Discrete Logarithm} problem calculating id from user\_id is difficult. For different RPs, they are able to get user's user\_rp\_id. User\_rp\_ids from different RPs can be marked as $user\_rp\_id_1=basic\_rp\_id_1^{id}modp$ and $user\_rp\_id_2=basic\_rp\_id_2^{id}modp$. As basic\_rp\_id$_1$ and basic\_rp\_id$_2$ are primitive element module $p$, there is $0<\alpha<p$ and $basic\_rp\_id_1=basic\_rp\_id_2^\alpha modp$.So user\_rp\_id$_1$ and user\_rp\_id$_2$ meet the following formula
$$user\_rp\_id_1=user\_rp\_id_2^\alpha modp$$
So RP is able to deduce the relevance between user\_rp\_id$_1$ and user\_rp\_id$_2$ only when knowing $\alpha$. As basic\_rp\_id is generated by IdP and calculating $\alpha$ from basic\_rp\_ids, RP is never able to find the relevance. If an RP does not use the basic\_rp\_id from IdP, user is able to find it dishonest through rp\_certificate and stop the login. Most of current users use dynamic IPs so that it is impossible to get user's login trace from user's IP.

%As SSO login requires IdP and RP to adopt https, external attacker is unable to get user's login trace through network flows. And user's dynamic IP makes external attacker impossible to get user's login trace from user's IP.
\subsection{Impersonation attack}
RP conducts impersonation attack by getting user's id\_token which is valid in other RPs. OpenID Connect protocol protect id\_token from malicious RP by keep RP owns unique client\_id and check RP's redirect\_uri during login. Unique client\_id makes one RP's id\_token invalid in other RPs. And IdP only redirects id\_token to it's relevant RP's redirect\_uri registered in IdP so that attacker is never able get RP's id\_token. There are three conditions for a malicious to try getting a validate id\_token. 1) Malicious RP has already finished client\_id negotiation with an RP as a user. As client\_id is generated by both RP and user, malicious RP is unable to get the id\_token with the same client\_id. 2)Malicious RP has got a user's id\_token, same as condition 1 malicious RP is unable to negotiate the same client\_id with another RP. 3) Malicious RP acts as the man in the middle between RP and user. As RP sends its URL in rp\_certificate user only sends its id\_token to this URL so that attacker can never achieve id\_token. As a summary, malicious is unable to conduct impersonation attack. 

Malicious user is only able to conduct impersonation attack by tempering id\_token. If attacker has already get victim's user\_rp\_id, attacker is able to calculate $user\_id=user\_rp\_id^rmodp$. $r$ is shared by RP and attacker. However id\_token is protected by the signature generated by IdP so that it is impossible for attacker to log in RP as victim.  

%External attacker is going to steal user's id\_token from network flow to make the attack. As all the network flows are protected by https, external attacker is unable to conduct the attack.
\subsection{Abduction attack}
To lead user to login an RP as attacker, attacker needs to make sure that user receive a malicious token from IdP. As https is used to protect parameters transforming between user and IdP, it's impossible to temper user's token during transmission. The other way to conduct the attack is phishing attack on IdP. 
In traditional SSO protocol such as OAuth 2.0 and OpenID Connect, it is possible for malicious to conduct phishing attack on IdP. As it is shown in ~\ref{fig:OpenID} step 2, the request from user to IdP is built by RP. If an malicious RP set the IdP'url as its phishing site, an unwary user may input its id and password on the phishing website so that attacker is able to get the full control of user's account.
In PriOIDC as RP\_Cert contains IdP's url, user agent is going to compare the IdP's url in request and RP\_Cert. If they are not matched, the request is deemed invalid. 

Phishing attack on RP in SSO system is quite different from it in normal website. In SSO system even an unwary user has visited a phishing RP's website, IdP is going to ask user to make sure RP's identity in ~\ref{fig:OpenID} step 2. The identity is bound with RP's client id and client id is bound with its redirect uri. If malicious RP constructs the request in ~\ref{fig:OpenID} step 2 to IdP with its personal client id, user is able to find out the true identity of RP and protect itself from phishing attack. In traditional SSO system if malicious uses a client id of another RP, IdP is going to redirect user to the corresponding redirect uri. In PriOIDC user agent is going to compare redirect uri from RP with the redirect uri in RP\_Cert.If uris are not matched, the request is regarded invalid. A phishing RP can never achieve another RP's token and never lead user to log in its website. 

%In phishing attack, adversary forges an RP's web application and induces user to log in it. In the disguise of the real RP, phishing site must send the real RP's rp\_token to user. In obtaining token phase if RP redirects user to real IdP, user is going to send its id\_token to the address from rp\_certificate. RP is not able to get user's id\_token and User does not log in adversary's RP finally. If RP redirects user to a fake IdP, the URL in redirection request is not mapped with it in rp\_certificate. User is going to stop the login. So phishing attack is not possible.  

%External attacker is willing to conduct abduction attack. Attacker is going to make the attack by temper user's id\_token into attacker's id\_token when id\_token is transformed on the network. But all the network flows are protected by https so that user's id\_token is secure.
%如果不同RP之间Basic_Client_ID 找到幂次的关系，那么就可以对应到同一个用户的身份

\subsection{Discussion}
An external attacker is also taken into account in SSO system. External attacker is able to capture and temper all the network flow through user, RP and IdP. External attacker's targets include impersonation attack, abduction attack and privacy undermining attack. 
%As SSO login requires IdP and RP to adopt https, external attacker is unable to get user's login trace through network flows. And user's dynamic IP makes external attacker impossible to get user's login trace from user's IP.
If an attacker keeps its eye on a specific user, it is able to find that the user's login on different RPs. So it is easy for an external attacker to draw a user's login trace. Privacy protection is not effective for external attacker.
To protect user from privacy leaking a proxy is probably a appropriate scheme. Proxy is able to mix multi-user's request and keep user's login trace invisible to attacker. User's dynamic IP makes proxy impossible to get user's login trace from user's IP
External attacker is going to steal user's id\_token from network flow to make the attack and it is also going to make the attack by temper user's id\_token into attacker's id\_token when id\_token is transformed on the network. As all the network flows are protected by https, external attacker is unable to conduct the attacks.