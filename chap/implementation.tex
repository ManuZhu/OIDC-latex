\section{Implementation And Evaluation}
\label{sec:implementation}
We have implemented the prototype of Recluse, and compared its performance with the original OIDC implementation and SPRESSO.

\subsection{Implementation}
We adopt SHA-256 to generate the digest, and  RSA-2048 for the signature in  the $Cert_{RP}$, identity proof and the dynamic registration response. We  choose a random 2048-bit strong prime as $P$, and the smallest primitive root (3 in the prototype)  of $P$ as $g$. The  $n_u$, $n_{RP}$ and $UID$  are 256-bit odd numbers, which provides no less security strength than RSA-2048~\cite{barkerecommendation}.

The IdP is implemented based on MITREid Connect~\cite{OIDF}. an open-source OIDC Java implementation certificated by the OpenID Foundation~\cite{OIDF}. Alghough, OIDC standard specifies that RP's identifier should be generated by IdP in the dynamic registration, MITREid Connect allows the user to provide a candidate RP identifier to the IdP who checks the uniqueness, which simplifies the implementation of Recluse. In Recluse, we add 3 lines Java code for generation of $PPID$, remove 1 line for checking the registration token in dynamic registration, while the calculation of $RPID_O$, $Cert_{RP}$,  $PPID$, and the RSA signature is implemented using the Java built-in cryptographic libraries (e.g., BigInteger)

The user-side processing is implemented as a Chrome extension with about 330 lines JavaScript code and 30 lines  Chrome extension configuration files (specifying the required permissions). The cryptographic calculation in $Cert_{RP}$ verification, $RPID_T$ negotiation, dynamic registration, is based on an efficient JavaScript cryptographic library  jsrsasign~\cite{jsrsasign}. The Chrome extension clears the \verb+referer+ in the HTTP header, to avoid the RPs' URL leaked to the IdP.


We provide the SDK for RP to integrate Recluse easily. The SDK provides 3 functions:  RP initial registration, processing of the user's login request and  identity proof parsing. The Java SDK is implemented based on the Spring Boot framework  with about 1100 lines JAVA code. The cryptographic computation is completed through Spring Security library. The user's login request contains Step 2, 3, 6, 7 and 12 in Figure~\ref{fig:process}; while  identity proof parsing contains Step 18 in Figure~\ref{fig:process}.


\noindent\textbf{Cross-Origin Resource Sharing (CORS).} The chrome extension needs to construct cross-origin requests to communicate with the RP and IdP, which is forbidden by default by the same-origin security policy. Recluse adopts CORS to achieve this cross-origin communication. In details, we requires the RP and IdP to specify \verb+chrome-extension://chrome-id+ in the \verb+Access-Control-Allow-Origin+ field of its response header, which makes the request pass the permission checks at the browser. As \verb+chrome-id+ is unique assigned by the Google, no other (malicious) entity can perform the cross-origin communication.



% While the response of \verb+http://www.B.com+ is transmitted to browser, the browser is to check whether the response carries the \verb+Access-Control-Allow-Origin:+ \verb+http://www.A.com+ in the http header. If the \verb+Access-Control-Allow-Origin+ is missed, the response is intercepted by the browser. The request initiated by the Chrome extension belongs to the origin \verb+chrome-extension://chrome-id+, while the chrome-id is provided by Google when the extension is uploaded to chrome web store. Therefore, it is required that the RP and IdP's web interfaces accessed by the user agent should add the  \verb+Access-Control-Allow-Origin:+ \verb+chrome-extension://chrome-id+ in its http header to make CORS available.


\begin{comment}

In this section, we firstly illustrate the parameters requirement in Recluse. After, we describe how the prototype is built.

\subsection{Parameters Requirement}
The $SK_Cert$, $PK_CERT$, $SK_ID$ and $PK_ID$ are two pairs of 2048-bit RSA key for different modulus. The $P$ is the 2048-bit strong prime number, as $(P-1)/2$ is also a prime number. And the $g$ is the smallest primitive root of $P$. The $RPID_O$ is another primitive root of $P$ generated from $g$. The $n_u$, $n_RP$ and $UID$ are required 256-bit odd numbers, which satisfies the security consideration about Discrete Logarithm problem.

\subsection{Prototype Implementation}
The Recluse prototype is consisted of the IdP, the RP and the user agent.

The IdP is built base on the MITREid Connect, which is one of the open-source OpenID Connect implementations certificated by  the OpenID Foundation. The MITREid Connect is based on the Spring framework, one of the most popular MVC frame work implemented with JAVA. Compared with the MITREid Connect, the Recluse IdP introduces the novel $PPID$ generating algorithm and enables the RP to register the new $RPID_T$ through dynamic registration. To change the $PPID$ generating method, we add 3 lines of JAVA code. However, although the specification of OpenID Connect defines that the RP's identifier in dynamic registration should be generated by IdP, MITREid allows the RP to decide the identifier instead of the IdP. Therefore, we only need to delete 1 line of code about dynamic registration to avoid the IdP to verify the \verb+registration token+ related with the specific RP which is required in dynamic registration.

In Recluse, the user agent takes the responsibilities to negotiate the $PPID_T$ with RP, register the newly generated $PPID_T$ with IdP, tamper the authentication request with one-time endpoint and transmit the identity proof from IdP to RP. The implementation of user agent is based on the Chrome extension, the function provided by Google for developers to create the plug-in for Chrome browser. The extension is built by about 330 lines of JavaScript code and 30 lines of Chrome extension configuration files. The cryptographic operations of user agent is provided by the jsrsasign, one of the most popular libraries providing Modular Exponentiation computing on the Github.


We provide the Recluse SDK for RP developers, based on which the RP is easily to be built or transformed from the traditional OpenID Connect system. The SDK takes the responsibility to negotiate the RP's identifier, provide the web interface to user agent, verify the identity proof from the IdP and derive the $Account$ from the $PPID$. The SDK is implemented base on the Spring Boot framework, including about 1100 lines of JAVA code. The cryptographic operations is provided by Spring Security library. With the SDK, we simply build the prototype RP with about only 30 lines of JAVA code, which provides the two web interfaces for user initial login and user identity  proof uploading. It is convenient for developers to transform the traditional OpenID Connect system to Recluse.

Besides, there are also some security considerations about the implementation of SSO systems, it is to be discussed as follows.

\noindent\textbf{307 Redirect. }It has been discussed in~\cite{FettKS16} that IdP might redirect the user to the RP immediately after the user inputs the credentials. For example, the HTTP response to the user's POST message with \verb+username+ and \verb+password+ might be the redirection to RP carrying user's identity proof. That is, as long as the 307 status code is used for this redirection, the user's credentials are also transmitted to the RP. However, in Recluse the redirections are intercepted by the user agent and rebuild the HTTP GET request to RP or IdP which is unable to leak the POST data of the user.


\noindent\textbf{Cross-Origin Resource Sharing (CORS).} Same-origin policy enables the browser restrict the request from one origin to another, for example, the request from the the web page \verb+http://www.A.com+ to \verb+http://www.B.com+ should be intercepted by the browser as default. However, to , the CORS is provided in the http protocols which allows the cross-origin transmission. In Recluse, the CORS is required for identity proof request and transmission. However, we strictly define the allowed cross-origin request, only the request from user agent is permitted, by setting the header of the response from RP and IdP with \verb+Access-Control-Allow-Origin:+ \verb+chrome-extension://chrome-id+. It is able to prevent the possible Xss attacks.
% While the response of \verb+http://www.B.com+ is transmitted to browser, the browser is to check whether the response carries the \verb+Access-Control-Allow-Origin:+ \verb+http://www.A.com+ in the http header. If the \verb+Access-Control-Allow-Origin+ is missed, the response is intercepted by the browser. The request initiated by the Chrome extension belongs to the origin \verb+chrome-extension://chrome-id+, while the chrome-id is provided by Google when the extension is uploaded to chrome web store. Therefore, it is required that the RP and IdP's web interfaces accessed by the user agent should add the  \verb+Access-Control-Allow-Origin:+ \verb+chrome-extension://chrome-id+ in its http header to make CORS available.


\noindent\textbf{Cross-Site Request Forgery (CSRF). } The CSRF attack might lead the user to access the malicious url provided by the adversary's web page, through which the adversary might lead the honest user to upload the adversary's \verb+ID token+ to the RP. However, in Recluse the cross origin request should be repudiated by both RP and IdP excepted the request from the origin of the user agent, which is able to prevent the CSRF attack.


The implementation of Recluse IdP is based on the MITREid Connect, which is the open-source OpenID Connect implementation in Java on the Spring framework, one of the most popular MVC frame work. Until July 30, 2019, the project of MITREid Connect on github owns 233 uses and 994 stars. It has already been certified by the OpenID Foundation as well.

The implementation of user agent is based on the Chrome extension, the function provided by Google for developers to create the plug-in for Chrome browser. The main programming language of Chrome extension is JavaScript. The cryptographic computing of user agent is provided by the jsrsasign, which has 6878 uses and 1986 stars on github.

The implementation of RP SDK is also based on the Spring framework and the cryptographic computing is provided by the Java Platform, Standard Edition. An RP is able to use the service provided by the Recluse conveniently with this SDK. However, to make it convenient to evaluate the time cost of prototype system, we build the RP based on the Spring frame work instead of modifying the open-source RP implementation.

The modification of IdP introduces about 5 lines of code changing, including deleting 1 line about verifying the authority of dynamic registration, deleting 1 line about getting user identifier from database which is replaced by 3 lines about generating it through the user-id-generating algorithm. Additionally, to make the CORS (Cross-Origin Resource Sharing) available, we add 6 lines of configuration code. The implementation of user agent contains about 330 lines of code which imports 3 libraries and about 30 lines of configuration. The implementation of RP SDK is about 1100 lines. However, we easily build the simple RP with only 30 lines of code based on the RP SDK ignoring the auto generated code by Spring framework.

\noindent\textbf{CORS.} Same-origin policy enables the browser restrict the request from one origin to another, for example, the JavaScript code on the web page created by \verb+http://www.A.com+ defines the request to \verb+http://www.B.com+, which carries the \verb+Origin:+ \verb+http://www.A.com+ in its http header. While the response of \verb+http://www.B.com+ is transmitted to browser, the browser is to check whether the response carries the \verb+Access-Control-Allow-Origin:+ \verb+http://www.A.com+ in the http header. If the \verb+Access-Control-Allow-Origin+ is missed, the response is intercepted by the browser. The request initiated by the Chrome extension belongs to the origin \verb+chrome-extension://chrome-id+, while the chrome-id is provided by Google when the extension is uploaded to chrome web store. Therefore, it is required that the RP and IdP's web interfaces accessed by the user agent should add the  \verb+Access-Control-Allow-Origin:+ \verb+chrome-extension://chrome-id+ in its http header to make CORS available.
\end{comment}


