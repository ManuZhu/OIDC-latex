\section{Background}
\label{sec:back}
PriOIDC is an extension of OIDC to prevent the IdP from inferring the user's accessed RP, with the security of SSO systems under consideration. This section provides the necessary background information about OIDC and adopts OIDC as the example to present the security consideration of SSO systems. 

%Most of current IdPs\cite{Facebook} for web application use OAuth 2.0 authorization code flow. Because authorization code flow requires RP's secret for token exchanging. It actually achieves the binding of RP and access token. Although OAuth 2.0 implicit flow is not secure in authentication, many IdPs also use its modified version designed by each IdP for authentication.
%In this section, we firstly describe how OpenID Connect is defined. Then the discussion of SSO system is to illustrate that why OpenID Connect is chosen and the challenges and solutions of protecting user's privacy.
\subsection{OpenID Connect}%为什么只针对隐式模式
OpenID Connect (current version 1.0) is an extension of OAuth (current version 2.0). OAuth is originally designed for authorizing the RP to obtain the user's personal protected resources stored at the resource holder. That is, the RP obtains an access token generated by the resource holder after a clear consent from the user, and  uses the access token to obtain the specified resources of the user from the resource holder. However, plenty of RPs adopt OAuth 2.0 in the user authentication, which is not formally defined in the specifications~\cite{rfc6749,rfc6750}, and makes impersonation attack possible~\cite{ChenPCTKT14, WangZLG16}. For example, the access token isn't required tp be bound with the RP, the adversary may act as a RP to obtain the access token and use it to impersonate as the victim user in another RP.

%OAuth 2.0 is specifically designed for user authorization. It allows third party to access user's personal protected resources from resource holder. In OAuth 2.0 system everyone carrying user's access token is able to achieve user's protected resources from resource holder. Access token is not bound with any RP so that it is not appropriate for authentication. OpenID Connect offers an additional id token for user identifying so that it can be used in both authentication and authorization.

%OpenID Connect 1.0 is an extension of OAuth 2.0. OAuth 2.0 is specifically designed for user authorization. It allows third party to access user's personal protected resources from resource holder. In OAuth 2.0 system everyone carrying user's access token is able to achieve user's protected resources from resource holder. Access token is not bound with any RP so that it is not appropriate for authentication. OpenID Connect offers an additional id token for user identifying so that it can be used in both authentication and authorization.

OIDC is designed to extend OAuth for user authentication by binding the identity proof for authentication with the information of RP. OIDC provides three protocol flows: authorization code flow, implicit flow and hybrid flow (i.e., a mix-up of the previous two flows). In the authorization code flow, the identity proof is the authorization code sent by the IdP, which is bound with the RP, as only the target RP is able to obtain the user's attributes with this authorization code and the corresponding secret.

The implicit flow of OIDC achieves the binding between the identity proof and the RP, by introducing a new token (i.e., id token). In details, id token includes the user's PPID (i.e., \verb+sub+), the RP's identifier (i.e., \verb+aud+), the valid period and the other requested attributes. The IdP completes the construction of the id token by generating the signature of these elements with its private key, and sends it to the correct RP through the redirect URL registered previously.  The RP validates the id token, by verifying the signature with the IdP's public key, checking the correctness of the valid period and the consistency of \verb+aud+ with the identifier stored locally. Figure~\ref{fig:OpenID} provides the details in the implicit flow of OIDC, where the dashed lines represent the message transmission  in  the browser while the solid lines denote the network traffic. The detailed processes are as follows:
\begin{itemize}
    \item Step 1: User attempts to login at one RP.
    \item Step 2: The RP redirects the user to the corresponding IdP with a newly constructed request of id token. The request contains RP's identifier (i.e., \verb+client_id+), the endpoint (i.e., \verb+redirect_uri+) to receive the id token, and the set of requested attributes (i.e., \verb+scope+). Here, the \verb+openid+ should be included in \verb+scope+ to request the id token.
    \item Step 3: The IdP generates the id token and the access token for the user who has been authenticated already, and constructs the response with  endpoint (i.e., \verb+redirect_uri+)  in request if it has already been registered. If the user hasn't been authenticated, an extra authentication process is performed.
    \item Step 4, 5: The RP verifies the id token, identifies the user with \verb+sub+ in the id token, and requests the other attributes from IdP with the access token.
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{fig/implicit.pdf}\label{fig:OpenID}
  %\subfigure[Authorization Code Flow]{\includegraphics[width=\linewidth]{fig/openidconnect2.pdf}\label{fig:OpenID_code}}
  %\subfigure[Hybrid Flow]{\includegraphics[width=\linewidth]{fig/openidconnect3.pdf}\label{fig:OpenID_hybrid}}
  \caption{The implicit protocol flow of OIDC.}
  \label{fig:OpenID}
\end{figure}

\noindent\textbf{Dynamic Registration.} The id token (also, the authorization code) is bound with the RP's identifier. OIDC provides the dynamic registration\cite{DynamicRegistration} mechanism to register the RP dynamically. After the first successful registration, RP obtains a registration token from the IdP, and is able to update its information (e.g., the \verb+redirect URI+ and the  response type) by a dynamic registration process with the  registration token. One successful dynamic registration process  will make the IdP assign a new unique client id for this RP.

\subsection{Security Consideration}
OIDC is designed with the following security considerations, and various implementations of IdP and RP are also analyzed with the same security principles under the assumption that IdP is trusted. Here, we use the implicit flow of OIDC as an example to list the security considerations:
\begin{itemize}
    \item The contents in the id token are generated under a clear consent of the user. The contents include the RP's information and the range of exposed attributes.
    \item The confidentiality of the id token is ensured, that is, only the target RP obtains the id token which will never be leaked by the honest RP. The HTTPS connection is used to protect the id token between the IdP and the user, while the trusted user proxy (e.g., the browser) ensures the id token only sent to the correct URL (of RP) which is confirmed by the user and the IdP.
    \item  No one except the IdP is able to construct a valid id token, as only the IdP has the private key to generate a valid signature for the id token. Any modification in the id token makes the signature (then the id token) invalid.
    \item  The identity proof is only valid for the target RP, as the id token is bound with the identifier of the target RP, and the honest RP checks the consistency of the identifier in the id token with the one stored locally. 
\end{itemize}


%OpenID Connect enables RP to verify the identity of a user based on the authentication performed by IdP. As OpenID Connect can be used in both authentication and authorization, it provides three kinds of credentials for the authentication response, containing \emph{code, token, id\_token}. \emph{Code} and \emph{token} is defined in OAuth 2.0 and \emph{id\_token} is offered only by OpenID Connect. %\emph{Code} and \emph{token} is usually used in authorization and \emph{id\_token} is used in authentication.
%The credential chosen is decided by the response\_type value in authentication request. According to the different choices of response\_type value, the use of OpenID Connect protocol can be classified as three flows: Authorization Code Flow, Implicit Flow and Hybrid Flow. The relation of response\_type and flow type is showed in table~\ref{tab:relation}

\begin{comment}

\begin{table}
\caption{OpenID Connect response\_type Values }
\begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}ll}
\toprule
Response\_type Value& Flow\\
\hline
code& Authorization Code Flow\\
id\_token& Implicit Flow\\
id\_token token& Implicit Flow\\
code id\_token& Hybrid Flow\\
code token& Hybrid Flow\\
code id\_token token& Hybrid Flow\\
\bottomrule
\label{tab:relation}
\end{tabular*}
\end{table}

\noindent{\textbf{Implicit Flow.}} OpenID Connect implicit flow is shown in Figure~\ref{fig:OpenID}. All dashed lines in the figure represent the redirection by browser and solid lines represent direct network calls. Parameters on lines are important data transmitted during this call.

The OpenID Connect implicit flow is described as following steps:
\begin{itemize}
    \item Step 1: User tries to log in RP.
    \item Step 2: RP constructs token request and redirects user to IdP. Client\_id represents RP's identity, redirect\_uri represents the RP's address waiting for token and scope represents the permissions RP required from IdP. In OpenID Connect protocol, scope must contain \emph{openid}.
    \item Step 3: If IdP has authenticated user it is going to redirect user's authentication response. As response\_type requires \emph{token, id\_token}, IdP's response contains access\_token and id\_token. RP can identify a user by id\_token.
    \item Step 4, 5: RP is able to obtain user's protected resource from IdP by access\_token.
\end{itemize}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{fig/implicit.pdf}\label{fig:OpenID}
  %\subfigure[Authorization Code Flow]{\includegraphics[width=\linewidth]{fig/openidconnect2.pdf}\label{fig:OpenID_code}}
  %\subfigure[Hybrid Flow]{\includegraphics[width=\linewidth]{fig/openidconnect3.pdf}\label{fig:OpenID_hybrid}}
  \caption{The implicit protocol flow in OIDC.}
  \label{fig:OpenID}
\end{figure}

%Other Flows. Authorization code flow is similar to implicit flow. IdP firstly sends RP the authorization code instead of tokens. Then RP need use the code and a secret shared by RP and IdP to exchange for tokens with IdP. Hybrid flow is the combination of implicit flow and authorization code flow. RP is able to obtain code and token from IdP at the same time.
\end{comment}
\begin{comment}
\subsection{Security Consideration}
An RP must register a unique ID at IdP. To protect users' privacy, IdP should receive user's consent for specific RP before sending the PII to this RP. So IdP must get a valid ID from RP to represent RP's identity. And it has been discussed that the id token must be bound to the specific RP to avoid the reuse of token. It also requires that RP should provide the ID to IdP.

The redirect\_uri registered at IdP can avoid a malicious opponent to get a user's id token. IdP compares the redirect\_uri in the authentication request and uploaded during registration. Only when the redirect\_uri in the authentication has been uploaded during registration IdP is going to send the id token to requester. It guarantees that only the owner of the registered redirect\_uri is able to receive the id token issued for its registrant.


\subsection{Dynamic Registration}
Dynamic registration\cite{DynamicRegistration} is a function IdP provides RP to re-register its information at IdP. For dynamic registration, IdP issues each RP a registration token when the first registration of RP is finished. RP is able to register a new ID and redirect uri at IdP using the registration token.

To register a new RP at the IdP, firstly RP sends an HTTP POST message to the IdP with the parameters containing redirect uri, response type and other metadata parameters. This message is sent with the registration token. Upon successful registration, IdP generates a unique client id and returns it back with other registered metadata parameters.
\end{comment}


%流程

\begin{comment}
%\subsubsection{Analysis of OpenID Connect Flows}
%In OpenID Connect system, IdP is always able to get a user's login trace as it need to sign a id token with RP's id and user's id in it. Nist Special Publication 800-63C\cite{NIST} proposes that a user using the same IdP to authenticate to multiple RPs allows IdP to build a profile of user transactions.

%OpenID Connect 1.0 protocol is designed as extension protocol of OAuth 2.0 protocol. It can be seemed as an OAuth authentication version protocol. When OAuth protocol is firstly created there are other authentication protocols such as OpenID. So OAuth is specifically designed for user authorization. It allows third party to access user's personal protected resources from resource holder. Different from OpenID Connect 1.0, OAuth 2.0 usually offers two kinds of response type, code and token. In OAuth 2.0 protocol everyone carrying user's access token is able to achieve user's protected resources from resource holder. Access token is not bound with any RP so that it is not appropriate for authentication. It has been described in many works\cite{rfc6819}\cite{ChenPCTKT14}.
%Most of current IdPs\cite{Facebook} for web application use OAuth 2.0 authorization code flow. Because authorization code flow requires RP's secret for token exchanging. It actually achieves the binding of RP and access token. Although OAuth 2.0 implicit flow is not secure in authentication, many IdPs also use its modified version designed by each IdP for authentication.

%As OpenID Connect 1.0 is designed as an OAuth authentication version protocol, it can be used in both authentication and authorization. Id token is a security token that contains claims about authentication of a user for specific RP and it is represented as a JSON Web Token\cite{rfc7519}. In OpenID Connect 1.0 access token is mostly used for authorization. Id token is enough for user authentication. Code provides the benefit of not exposing id tokens to any malicious applications able to access user agent. Our protocol considers browser as the trust base so that authorization code flow is not necessary. We finally choose OpenID Connect 1.0 implicit flow with only response value of id\_token as the base of our enhanced protocol.

\subsection{Discussion of SSO System}
%OpenID Connect 1.0 protocol is designed as extension protocol of OAuth 2.0 protocol. When OAuth protocol is firstly created there are other authentication protocols such as OpenID. So OAuth is specifically designed for user authorization. It allows third party to access user's personal protected resources from resource holder. In OAuth 2.0 system everyone carrying user's access token is able to achieve user's protected resources from resource holder. Access token is not bound with any RP so that it is not appropriate for authentication.
%Most of current IdPs\cite{Facebook} for web application use OAuth 2.0 authorization code flow. Because authorization code flow requires RP's secret for token exchanging. It actually achieves the binding of RP and access token. Although OAuth 2.0 implicit flow is not secure in authentication, many IdPs also use its modified version designed by each IdP for authentication.

%为什么遵循openid connect，安全性得到了保证，已经被广泛使用
The reasons our privacy respecting single-sign-on protocol is designed based on OpenID Connect includes two main factors: 1) OpenID Connect 1.0 protocol and OAuth 2.0 protocol has been analysed in many previous works and they have been certified secure\cite{FettKS16}. So if the enhanced protocol can be insured as secure as OpenID Connect 1.0 protocol, it is deemed to be secure. 2) Current IdPs mostly use OAuth 2.0 and OpenID Connect 1.0 for user authentication\cite{Facebook}\cite{Google}. So it is convenient for developers to transfer their old system into the system with enhanced protocol if new protocol is similar with the previous one.

As OpenID Connect 1.0 is designed as an OAuth authentication version protocol, it can be used in both authentication and authorization. Id token is a security token that contains claims about authentication of a user for specific RP and it is represented as a JSON Web Token\cite{rfc7519}. In OpenID Connect 1.0 access token is mostly used for authorization. Id token is enough for user authentication. Code provides the benefit of not exposing id tokens to any malicious applications able to access user agent. Our protocol considers browser as the trust base so that authorization code flow is not necessary. We finally choose OpenID Connect 1.0 implicit flow with only response value of id\_token as the base of our enhanced protocol.

%单点登录系统中，IdP通过用户认证识别用户身份，通过client_id和redirect_uri识别RP身份。
%在不改变单点登录系统结构的情况下，由于IdP要向RP提供用户的身份信息，所以向IdP隐藏用户身份是不可行的
%向IdP隐藏RP身份要通过隐藏client_id和redirect_uri实现
%The ability of IdP. Discribe the solution of protecting users' privacy.
In OpenID Connect implicit flow, IdP gets a user's login trace in two ways. IdP gets RP's identity by client\_id and reditrct\_uri in redirect request (step 2) from RP. And IdP gets user's identity when authenticating the user (step 3). As IdP has to provide RP a user's authenticator bound with user's identity, it's not possible to keep user anonymous in IdP without modifying the structure of current SSO system. So it is only feasible to protect user's privacy by keeping RP anonymous in IdP. So it is needed to make client\_id and redirect\_uri unrelated with RP. But it introduces new challenges.

\subsubsection{Challenges}
%最直接的隐藏RP的方法是在登录过程中使用随机的client_id与redirect_uri
%简单的修改会带来两个方面的问题：流程问题与安全问题
%流程问题：IdP只识别注册过的client_id与redirect_uri；client_id与uid绑定，随机的client_id使每次的uid都不同
%安全问题：随机的client_id导致了不同RP之间的token可以混用；随机的redirect_uri导致IdP无法保证token只发送给对应的RP
%Security problems. The secure rules of sso system summarized from the previous research. And the simple solution will disobey which rules.
%Function problems. How the simple solution make the sso system failed.
%描述为何不能用户匿名
The simplest way to make RP anonymous in IdP is using random client\_id and redirect\_uri during each login. But the simple method will introduce some problems in two fields.

%关键句子表明问题的分类
Using random client\_id and redirect\_uri results in failure of authentication in current SSO system. IdP only accepts a request when the client\_id and redirect\_uri have been registered at IdP by an RP. So when using a random client\_id and redirect\_uri in a request, IdP will drop it as an invalid request. Additionally to protect user's privacy from RPs' collusion, it's required that IdP should provide different user\_ids for different client\_ids\cite{OpenIDConnect}. As a result, user\_id is bound to client\_id. While client\_id changing, user\_id changes. So a random client\_id for a RP means the user\_id is random too. If RP wants to provide a user personalize service user has to own a constant identity in RP. So randomness of client\_id means that RP can no more identify a user.

In the other field, anonymous RP causes secure problems. To avoid the misuse of id\_token among different RPs, RP judges the validation of id\_token through the client\_id in it. An client\_id represents a specific RP's identity, a id\_token with this client\_id is only valid in this specific RP. But when using a random client\_id, different RPs may share the same client\_id. When a user log in a malicious RP, this RP possibly logs in other RPs with the user's id\_token if they have the same client\_id. Additionally redirect\_uri is the address where RP waits for the id\_token. Before issuing a id\_token, IdP will check the validation of redirect\_uri to avoid attacker getting the id\_token. If the redirect\_uri is random, IdP can no more protect user from sending id\_token to an attacker.
\subsubsection{Solutions against the problems}
%通过协商生成client_id，任何一方无法控制client_id的生成
%用户代理控制token的发送，保证发送给对应的RP
%使用OpenID Connect 1.0的动态注册功能保证client_id与redirect_uri的有效性
%设计client_id与user id 的生成算法，使RP能够识别用户
With dynamic registration, a RP can register new random client\_id and redirect\_uri before sending a request to IdP for id\_token. And to avoid IdP finding out RP's identity through dynamic registration, the requirement of registration token is omitted. IdP will delete the expired registration to reduce storage stress.

To identify a user in different logins, RP must have the ability to transform the user\_id provided by IdP into a constant user identity for each user. Most of current SSO system generate user\_id as a random  character string. So a new user-id-generating algorithm has to be created for user authentication. As user\_id is required to be bound to random client\_id to protect from RPs' collusion, client\_id should be the primary input parameter to user-id-generating algorithm. To make user\_id able to be transformed into a constant user identity, it is a feasible way that generating client\_id through a client-id-generating algorithm. The user-id-generating algorithm and client-id-generating algorithm will be described detailedly in Section~\ref{sec:protocol}.

Misuse of id\_token only happens when different RPs use the same client\_id. Although IdP will keep the registered client\_id unique, an attacker is possible to be the executor of registration (RP or user) and tamper with the failed registration result. So victim will regard the repetitive client\_id as a validate one. To prevent misuse of id\_token, client-id-generating algorithm should require two random parameters respectively generated by RP and user. So even if an attacker possesses a user's id\_token (or negotiates a client\_id with RP), he is unable to negotiate the same client\_id with a RP (or get the id\_token with same client\_id from user).

As redirect\_uri is random, IdP is going to send id\_token to the invalidate address. User agent must intercept the id\_token redirection from IdP and send id\_token to RP. In PRISSO system IdP issues RP certification for each RP. A RP certification contains RP's identity and its address for token acceptance.  User gets the real acceptance address of RP from certification and makes sure that the id\_token is going to be sent to the RP. RP certification is also useful in defending phishing attack.
\end{comment}
