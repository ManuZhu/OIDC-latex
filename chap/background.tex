\section{Background and Preliminary}
\label{sec:background}


\subsection{OpenID Connect}
\label{subsec:OIDC}

To be compatible with existing SSO systems, UPRESSO is designed on top of OpenID Connect (OIDC)~\cite{OpenIDConnect}, one of the most prominent SSO authentication protocols~\cite{SAMLIdentifier}. In this section, we introduce OIDC and its implicit flow as an example to describe the authentication flows in SSO. Moreover, our proposed framework can also work for other flows with only minor modifications.

OIDC is an extension of OAuth 2.0 to support user authentication. As a typical SSO authentication protocol, OIDC involves three entities, i.e., {\em users}, {\em identity provider (IdP)}, and {\em relying parties (RPs)}. Users register at the IdP to create credentials and identifiers (e.g. $ID_U$), which are securely maintained by the IdP. Moreover, an RP also has to register at the IdP with its endpoint information to create its unique identifier. During an SSO process, a user is also responsible for redirecting the identity proof request from the RP to the IdP, checking the scope of user attributes in the identity proof returned by the IdP, and forwarding it to the RP. Usually, the redirection and checking are handled by a user-controlled software, called {\em user agent} (e.g., browser). The IdP maintains user credentials and attributes. Once requested, it authenticates the user and generates the identity proof, which contains user identifier (e.g., $PPID$ in OIDC), RP identifier (e.g. $ID_{RP}$), and a set of user attributes that the user consents to share with the RP. The identity proof is then returned to the registered endpoint of the RP (e.g., URL). RP can be any web server that provides continuous and personalized services to its users. When a user attempts to log in, the RP sends an identity proof request to the IdP through the user, and parses the received identity proof to authenticate and authorize the user.



%****** Add discussion about why implicit flow is used in this work
\noindent\textbf{Implicit flow of user login.}
OIDC supports three processes for SSO, known as {\em authorization code flow}, {\em implicit flow} and {\em hybrid flow} (i.e., a mix-up of the previous two).
In the implicit flow of OIDC, a new token, known as {\em id token}, is introduced as the identity proof, which contains user identifier (i.e., PPID), RP identifier (i.e., $ID_{RP}$), the issuer (i.e., IdP), issuing time, the validity period, and other requested attributes. The IdP signs the id token by its private key to ensure integrity.
Moreover, in the authorization code flow, the identity proof is an authorization code bound to the RP. Only the RP with the corresponding secret obtained during the registration at the IdP can extract the user attributes from the identify proof.



\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{fig/OIDC1.pdf}
  %\subfigure[Authorization Code Flow]{\includegraphics[width=\linewidth]{fig/openidconnect2.pdf}\label{fig:OpenID_code}}
  %\subfigure[Hybrid Flow]{\includegraphics[width=\linewidth]{fig/openidconnect3.pdf}\label{fig:OpenID_hybrid}}
  \caption{The implicit protocol flow of OIDC.}
  \label{fig:OpenID}
\end{figure}

As shown in Figure~\ref{fig:OpenID}, the implicit flow of OIDC consists of 7 steps: when a user attempts to log in to an RP (step 1), the RP constructs a request for identity proof, which is redirected by the user to the corresponding IdP (step 2). The request contains $ID_{RP}$, RP's endpoint and a set of requested user attributes. If the user has not been authenticated yet, the IdP performs an authentication process (step 3). If the RP's endpoint in the request matches the one registered at the IdP, it generates an identity proof (step 4) and sends it back to the RP (step 5). Otherwise, IdP generates a warning to notify the user about potential identity proof leakage. The RP verifies the id token (step 6), extracts user identifier from the id token and returns the authentication result to the user (step 7).



\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{fig/overview1.pdf}
  %\subfigure[Authorization Code Flow]{\includegraphics[width=\linewidth]{fig/openidconnect2.pdf}\label{fig:OpenID_code}}
  %\subfigure[Hybrid Flow]{\includegraphics[width=\linewidth]{fig/openidconnect3.pdf}\label{fig:OpenID_hybrid}}
  \caption{The UPRESSO.}
  \label{fig:UPRESSO}
\end{figure}

\noindent\textbf{RP dynamic registration.} OIDC provides a dynamic registration mechanism~\cite{DynamicRegistration} for the RP to renew its $ID_{RP}$ dynamically. % shown in Figure~\ref{fig:OpenID}.
When an RP first registers at the IdP, it obtains a registration token, with which the  RP can invoke the dynamic registration process to
%After a successful initial registration, RP obtains a registration token from the IdP, and
update its information (e.g., the endpoint). % by a dynamic registration process with the  registration token. %which enables the RP to integrate the service provided by IdP,
After each successful dynamic registration, the RP obtains a new unique $ID_{RP}$ from the IdP.
In this work we adopt dynamic registration to support the dynamic generated privacy-preserving RP identifier (e.g. $PID_{RP}$).


\subsection{Discrete Logarithm Problem}
\label{sec:dlp}

Discrete logarithm problem is adopted in UPRESSO for privacy-preserving user identifier (e.g. $PID_U$) and RP identifier (e.g. $PID_{RP}$) generation.
Here, we provide a brief description of the discrete logarithm problem.
Given a large prime $p$, its primitive root $g$ and a number $y$, it is computationally infeasible to derive the discrete logarithm (here $x$ and $g^xmodp=y$) of $y$ (detailed in~\cite{WXWM}), which is called discrete logarithm problem.
The hardness of solving discrete logarithm has been a base of the security of several security primitives, including Diffie-Hellman key exchange and Digital Signature Algorithm (DSA).
The $PID_U$ and $PID_{RP}$ generation is based on the modular exponentiation, which requires the parameters, such as $ID_{RP}$ and $PID_{RP}$, should be the primitive root mod $p$ to prevent the user and RP' identity leakage.
To calculate the primitive root for a given large prime $p$, we retrieve a primitive root $g_m$ mod $p$, and then calculate the $g = g_{m}^{t} mod \ P$, so that $g$ is another primitive root mod $p$ where $t$ is an integer coprime to $p-1$.


\begin{comment}
%, to prevent IdP from inferring $ID_{RP}$ from $PID_{RP}$, and allow the RP to derive $Account$ from $PID_U$ without obtaining the $ID_U$.
Here, we provide a brief description of the discrete logarithm problem.
A number $g$ ($0<g<p$) is called a primitive root modular a prime $p$, if for ${\forall}y$ ($0<y<p$), there is a  number $x$ ($0\le x <p-1$) satisfying $y=g^x \pmod p$.
And, $x$ is called the discrete logarithm of $y$ modulo $p$. Given a large prime $p$ and a number $y$, it is computationally infeasible to derive the discrete logarithm (here $x$) of $y$ (detailed in~\cite{WXWM}), which is called discrete logarithm problem. The hardness of solving discrete logarithm has been a base of the security of several security primitives, including Diffie-Hellman key exchange and Digital Signature Algorithm (DSA).
To calculate the primitive root for a given large prime $p$,  we retrieve the least primitive root $g_m$  mod $p$,
and then calculate the primitive root $g = g_{m}^{t} mod \ P$, where $t$ is an integer coprime to $p-1$.
A lemma is proposed to check whether an integrity $\mu$ is the primitive root modulo $p$ where $p=2q+1$ ($q$ is a prime), that is,  an integer $\mu \in (1, p-1)$ is a primitive root if and only if $\mu^2\neq 1 \ mod \ p$ and $\mu^q\neq 1 \ mod \ p$~\cite{Shoup,Wang}.
%The details are provided in~\cite{Shoup,Wang}.
\end{comment}

